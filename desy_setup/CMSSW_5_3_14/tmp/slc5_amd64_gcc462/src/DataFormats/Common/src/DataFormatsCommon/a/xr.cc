// Generated at Mon Jul 28 10:38:12 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "src/DataFormats/Common/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

#include "TBuffer.h"
#include "TVirtualObject.h"
#include <vector>
#include "TSchemaHelper.h"


namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("edm::reftobase") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("edmNew::dstvdetails") );
  ::Reflex::Type type_61 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_11 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2776 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2811 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_968 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_641 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1657 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_4533 = ::Reflex::TypeBuilder(Reflex::Literal("boost::any"));
  ::Reflex::Type type_3086 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Other"));
  ::Reflex::Type type_235 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_228 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_3072 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Hash<1>"));
  ::Reflex::Type type_3056 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_161 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_3084 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<int>"));
  ::Reflex::Type type_2902 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DataFrame"));
  ::Reflex::Type type_3052 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_1899 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_2999 = ::Reflex::TypeBuilder(Reflex::Literal("edm::BoolCache"));
  ::Reflex::Type type_2286 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_2284 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<bool>"));
  ::Reflex::Type type_3027 = ::Reflex::TypeBuilder(Reflex::Literal("edm::HLTPathStatus"));
  ::Reflex::Type type_2897 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ConstPtrCache"));
  ::Reflex::Type type_3024 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase"));
  ::Reflex::Type type_2283 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_3128 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>"));
  ::Reflex::Type type_2904 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperHolder"));
  ::Reflex::Type type_3063 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EventAuxiliary"));
  ::Reflex::Type type_2907 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<int>"));
  ::Reflex::Type type_2282 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2374 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_reference"));
  ::Reflex::Type type_3126 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<bool>"));
  ::Reflex::Type type_3079 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<int>"));
  ::Reflex::Type type_3099 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TriggerResults"));
  ::Reflex::Type type_3102 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_3125 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<float>"));
  ::Reflex::Type type_2973 = ::Reflex::TypeBuilder(Reflex::Literal("edm::HLTGlobalStatus"));
  ::Reflex::Type type_3062 = ::Reflex::TypeBuilder(Reflex::Literal("edm::MergeableCounter"));
  ::Reflex::Type type_3124 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<double>"));
  ::Reflex::Type type_3116 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCoreWithIndex"));
  ::Reflex::Type type_2981 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<int>"));
  ::Reflex::Type type_13296 = ::Reflex::EnumTypeBuilder(Reflex::Literal("edm::hlt::HLTState"));
  ::Reflex::Type type_3023 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DataFrameContainer"));
  ::Reflex::Type type_3031 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DoNotRecordParents"));
  ::Reflex::Type type_1787 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_3071 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<int>"));
  ::Reflex::Type type_2277 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2285 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_2994 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ConditionsInRunBlock"));
  ::Reflex::Type type_2985 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBaseVector<int>"));
  ::Reflex::Type type_2278 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3026 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ConditionsInLumiBlock"));
  ::Reflex::Type type_2976 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ConditionsInEventBlock"));
  ::Reflex::Type type_3127 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<unsigned int>"));
  ::Reflex::Type type_2290 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_3085 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DoNotSortUponInsertion"));
  ::Reflex::Type type_6785 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase"));
  ::Reflex::Type type_3117 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<int> >"));
  ::Reflex::Type type_2289 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::HLTPathStatus>"));
  ::Reflex::Type type_3025 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<int> >"));
  ::Reflex::Type type_2280 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::EventAuxiliary>"));
  ::Reflex::Type type_3070 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<unsigned int>"));
  ::Reflex::Type type_4621 = ::Reflex::TypeBuilder(Reflex::Literal("boost::noncopyable_::noncopyable"));
  ::Reflex::Type type_13235 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<int>"));
  ::Reflex::Type type_2940 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::HLTPathStatus>"));
  ::Reflex::Type type_2028 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::HLTPathStatus>"));
  ::Reflex::Type type_3069 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<unsigned long>"));
  ::Reflex::Type type_2933 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<int> >"));
  ::Reflex::Type type_2937 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::TriggerResults>"));
  ::Reflex::Type type_2532 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::HLTPathStatus>"));
  ::Reflex::Type type_2020 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<int> >"));
  ::Reflex::Type type_2025 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::TriggerResults>"));
  ::Reflex::Type type_3005 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<int> >"));
  ::Reflex::Type type_2931 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<bool> >"));
  ::Reflex::Type type_2934 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::PtrVector<int> >"));
  ::Reflex::Type type_2938 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::HLTGlobalStatus>"));
  ::Reflex::Type type_2521 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::EventAuxiliary>"));
  ::Reflex::Type type_3058 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_2279 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::ErrorSummaryEntry>"));
  ::Reflex::Type type_2018 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<bool> >"));
  ::Reflex::Type type_14216 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<int>::const_iterator"));
  ::Reflex::Type type_2022 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::PtrVector<int> >"));
  ::Reflex::Type type_2026 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::HLTGlobalStatus>"));
  ::Reflex::Type type_2926 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::MergeableCounter>"));
  ::Reflex::Type type_2930 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<float> >"));
  ::Reflex::Type type_2013 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::MergeableCounter>"));
  ::Reflex::Type type_2017 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<float> >"));
  ::Reflex::Type type_14148 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<bool>::const_iterator"));
  ::Reflex::Type type_2217 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,unsigned int>"));
  ::Reflex::Type type_3036 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<int> >"));
  ::Reflex::Type type_2929 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<double> >"));
  ::Reflex::Type type_2016 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<double> >"));
  ::Reflex::Type type_14114 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<float>::const_iterator"));
  ::Reflex::Type type_2291 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_2941 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::DataFrameContainer>"));
  ::Reflex::Type type_14080 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<double>::const_iterator"));
  ::Reflex::Type type_13239 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<int>"));
  ::Reflex::Type type_2029 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::DataFrameContainer>"));
  ::Reflex::Type type_14844 = ::Reflex::TypeBuilder(Reflex::Literal("edmNew::dstvdetails::DetSetVectorTrans"));
  ::Reflex::Type type_2924 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ConditionsInRunBlock>"));
  ::Reflex::Type type_2011 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ConditionsInRunBlock>"));
  ::Reflex::Type type_2925 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ConditionsInLumiBlock>"));
  ::Reflex::Type type_2935 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<int> >"));
  ::Reflex::Type type_2012 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ConditionsInLumiBlock>"));
  ::Reflex::Type type_13840 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<int> >"));
  ::Reflex::Type type_2023 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefToBaseVector<int> >"));
  ::Reflex::Type type_2961 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::HLTPathStatus>"));
  ::Reflex::Type type_2923 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ConditionsInEventBlock>"));
  ::Reflex::Type type_2010 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ConditionsInEventBlock>"));
  ::Reflex::Type type_13838 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<bool> >"));
  ::Reflex::Type type_2954 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<int> >"));
  ::Reflex::Type type_2958 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::TriggerResults>"));
  ::Reflex::Type type_13240 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::IndirectVectorHolder<int>"));
  ::Reflex::Type type_2932 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<unsigned int> >"));
  ::Reflex::Type type_13837 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<float> >"));
  ::Reflex::Type type_2952 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<bool> >"));
  ::Reflex::Type type_2019 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<unsigned int> >"));
  ::Reflex::Type type_2955 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::PtrVector<int> >"));
  ::Reflex::Type type_2959 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::HLTGlobalStatus>"));
  ::Reflex::Type type_5005 = ::Reflex::TypeBuilder(Reflex::Literal("edmNew::dstvdetails::DetSetVectorTrans::Item"));
  ::Reflex::Type type_2947 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::MergeableCounter>"));
  ::Reflex::Type type_13836 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<double> >"));
  ::Reflex::Type type_2951 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<float> >"));
  ::Reflex::Type type_14182 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<unsigned int>::const_iterator"));
  ::Reflex::Type type_2950 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<double> >"));
  ::Reflex::Type type_2962 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::DataFrameContainer>"));
  ::Reflex::Type type_2939 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::HLTPathStatus> >"));
  ::Reflex::Type type_2027 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<edm::HLTPathStatus> >"));
  ::Reflex::Type type_2928 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::EventAuxiliary> >"));
  ::Reflex::Type type_2945 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ConditionsInRunBlock>"));
  ::Reflex::Type type_2015 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<edm::EventAuxiliary> >"));
  ::Reflex::Type type_2946 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ConditionsInLumiBlock>"));
  ::Reflex::Type type_2956 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefToBaseVector<int> >"));
  ::Reflex::Type type_2944 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ConditionsInEventBlock>"));
  ::Reflex::Type type_13839 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<unsigned int> >"));
  ::Reflex::Type type_2021 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2927 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >"));
  ::Reflex::Type type_2014 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<edm::ErrorSummaryEntry> >"));
  ::Reflex::Type type_2953 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<unsigned int> >"));
  ::Reflex::Type type_2428 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_2281 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<edm::ProductID,unsigned int> >"));
  ::Reflex::Type type_13641 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase::const_iterator"));
  ::Reflex::Type type_3592 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<int*,std::vector<int> >"));
  ::Reflex::Type type_3093 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_13302 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<int>::const_iterator"));
  ::Reflex::Type type_12700 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<int>,int>"));
  ::Reflex::Type type_2960 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<edm::HLTPathStatus> >"));
  ::Reflex::Type type_2949 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<edm::EventAuxiliary> >"));
  ::Reflex::Type type_2287 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>"));
  ::Reflex::Type type_23111 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<int>::const_iterator_imp"));
  ::Reflex::Type type_2948 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<edm::ErrorSummaryEntry> >"));
  ::Reflex::Type type_2528 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item>"));
  ::Reflex::Type type_2968 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >"));
  ::Reflex::Type type_3588 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const float*,std::vector<float> >"));
  ::Reflex::Type type_3600 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_12698 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<int> >"));
  ::Reflex::Type type_3605 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >"));
  ::Reflex::Type type_2043 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::HLTPathStatus,std::allocator<edm::HLTPathStatus> >"));
  ::Reflex::Type type_3599 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >"));
  ::Reflex::Type type_2034 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::EventAuxiliary,std::allocator<edm::EventAuxiliary> >"));
  ::Reflex::Type type_13217 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::id_iterator"));
  ::Reflex::Type type_3595 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_3598 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >"));
  ::Reflex::Type type_3601 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >"));
  ::Reflex::Type type_3582 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >"));
  ::Reflex::Type type_3104 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >"));
  ::Reflex::Type type_3602 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >"));
  ::Reflex::Type type_3583 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >"));
  ::Reflex::Type type_2918 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >"));
  ::Reflex::Type type_2894 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >"));
  ::Reflex::Type type_2671 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> > >"));
  ::Reflex::Type type_2936 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >"));
  ::Reflex::Type type_2649 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> > >"));
  ::Reflex::Type type_2024 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >"));
  ::Reflex::Type type_2670 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> > >"));
  ::Reflex::Type type_2648 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> > >"));
  ::Reflex::Type type_2957 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >"));
  ::Reflex::Type type_2040 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edmNew::dstvdetails::DetSetVectorTrans::Item,std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item> >"));
  ::Reflex::Type type_13234 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >"));
  ::Reflex::Type type_3597 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >"));
  ::Reflex::Type type_2218 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const float*,std::vector<float> >,__gnu_cxx::__normal_iterator<const float*,std::vector<float> > >"));
  ::Reflex::Type type_12699 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >"));
  ::Reflex::Type type_3596 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >"));
  ::Reflex::Type type_2221 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >,__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> > >"));
  ::Reflex::Type type_2665 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> > >"));
  ::Reflex::Type type_2664 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> > >"));
  ::Reflex::Type type_4151 = ::Reflex::TypeBuilder(Reflex::Literal("boost::transform_iterator<edm::DataFrameContainer::IterHelp,boost::counting_iterator<int,boost::use_default,boost::use_default>,boost::use_default,boost::use_default>"));
  ::Reflex::Type type_2220 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >,__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> > >"));
  ::Reflex::Type type_8196 = ::Reflex::PointerBuilder(type_3063);
  ::Reflex::Type type_3063c = ::Reflex::ConstBuilder(type_3063);
  ::Reflex::Type type_8198 = ::Reflex::PointerBuilder(type_3063c);
  ::Reflex::Type type_8200 = ::Reflex::ReferenceBuilder(type_3063);
  ::Reflex::Type type_8202 = ::Reflex::ReferenceBuilder(type_3063c);
  ::Reflex::Type type_2504 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_228);
  ::Reflex::Type type_2401 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_11);
  ::Reflex::Type type_2521c = ::Reflex::ConstBuilder(type_2521);
  ::Reflex::Type type_22011 = ::Reflex::ReferenceBuilder(type_2521c);
  ::Reflex::Type type_2280c = ::Reflex::ConstBuilder(type_2280);
  ::Reflex::Type type_22446 = ::Reflex::ReferenceBuilder(type_2280c);
  ::Reflex::Type type_22447 = ::Reflex::ReferenceBuilder(type_2280);
  ::Reflex::Type type_31271 = ::Reflex::ReferenceBuilder(type_14844);
  ::Reflex::Type type_14844c = ::Reflex::ConstBuilder(type_14844);
  ::Reflex::Type type_31272 = ::Reflex::ReferenceBuilder(type_14844c);
  ::Reflex::Type type_5010 = ::Reflex::ReferenceBuilder(type_5005);
  ::Reflex::Type type_5005c = ::Reflex::ConstBuilder(type_5005);
  ::Reflex::Type type_5021 = ::Reflex::ReferenceBuilder(type_5005c);
  ::Reflex::Type type_5008 = ::Reflex::PointerBuilder(type_5005);
  ::Reflex::Type type_5019 = ::Reflex::PointerBuilder(type_5005c);
  ::Reflex::Type type_2528c = ::Reflex::ConstBuilder(type_2528);
  ::Reflex::Type type_22083 = ::Reflex::ReferenceBuilder(type_2528c);
  ::Reflex::Type type_2287c = ::Reflex::ConstBuilder(type_2287);
  ::Reflex::Type type_22461 = ::Reflex::ReferenceBuilder(type_2287c);
  ::Reflex::Type type_9896 = ::Reflex::ReferenceBuilder(type_2287);
  ::Reflex::Type type_1247 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint16_t"), type_161);
  ::Reflex::Type type_8767 = ::Reflex::ReferenceBuilder(type_3027);
  ::Reflex::Type type_3027c = ::Reflex::ConstBuilder(type_3027);
  ::Reflex::Type type_8769 = ::Reflex::ReferenceBuilder(type_3027c);
  ::Reflex::Type type_13296c = ::Reflex::ConstBuilder(type_13296);
  ::Reflex::Type type_235c = ::Reflex::ConstBuilder(type_235);
  ::Reflex::Type type_8763 = ::Reflex::PointerBuilder(type_3027);
  ::Reflex::Type type_8765 = ::Reflex::PointerBuilder(type_3027c);
  ::Reflex::Type type_2532c = ::Reflex::ConstBuilder(type_2532);
  ::Reflex::Type type_22119 = ::Reflex::ReferenceBuilder(type_2532c);
  ::Reflex::Type type_2289c = ::Reflex::ConstBuilder(type_2289);
  ::Reflex::Type type_22466 = ::Reflex::ReferenceBuilder(type_2289c);
  ::Reflex::Type type_22467 = ::Reflex::ReferenceBuilder(type_2289);
  ::Reflex::Type type_2776c = ::Reflex::ConstBuilder(type_2776);
  ::Reflex::Type type_2845 = ::Reflex::PointerBuilder(type_2776c);
  ::Reflex::Type type_22938 = ::Reflex::ReferenceBuilder(type_2897);
  ::Reflex::Type type_2897c = ::Reflex::ConstBuilder(type_2897);
  ::Reflex::Type type_22939 = ::Reflex::ReferenceBuilder(type_2897c);
  ::Reflex::Type type_161c = ::Reflex::ConstBuilder(type_161);
  ::Reflex::Type type_5041 = ::Reflex::PointerBuilder(type_161c);
  ::Reflex::Type type_2812 = ::Reflex::PointerBuilder(type_161);
  ::Reflex::Type type_17937 = ::Reflex::ReferenceBuilder(type_2902);
  ::Reflex::Type type_2902c = ::Reflex::ConstBuilder(type_2902);
  ::Reflex::Type type_22945 = ::Reflex::ReferenceBuilder(type_2902c);
  ::Reflex::Type type_3023c = ::Reflex::ConstBuilder(type_3023);
  ::Reflex::Type type_22946 = ::Reflex::ReferenceBuilder(type_3023c);
  ::Reflex::Type type_5074 = ::Reflex::ReferenceBuilder(type_161);
  ::Reflex::Type type_3052c = ::Reflex::ConstBuilder(type_3052);
  ::Reflex::Type type_12510 = ::Reflex::ReferenceBuilder(type_3052c);
  ::Reflex::Type type_2907c = ::Reflex::ConstBuilder(type_2907);
  ::Reflex::Type type_22993 = ::Reflex::ReferenceBuilder(type_2907c);
  ::Reflex::Type type_228c = ::Reflex::ConstBuilder(type_228);
  ::Reflex::Type type_3084c = ::Reflex::ConstBuilder(type_3084);
  ::Reflex::Type type_22994 = ::Reflex::ReferenceBuilder(type_3084c);
  ::Reflex::Type type_22995 = ::Reflex::ReferenceBuilder(type_2907);
  ::Reflex::Type type_22439 = ::Reflex::ReferenceBuilder(type_2277);
  ::Reflex::Type type_3104c = ::Reflex::ConstBuilder(type_3104);
  ::Reflex::Type type_2918c = ::Reflex::ConstBuilder(type_2918);
  ::Reflex::Type type_22998 = ::Reflex::ReferenceBuilder(type_2918c);
  ::Reflex::Type type_22999 = ::Reflex::ReferenceBuilder(type_3104c);
  ::Reflex::Type type_3070c = ::Reflex::ConstBuilder(type_3070);
  ::Reflex::Type type_23000 = ::Reflex::ReferenceBuilder(type_3070c);
  ::Reflex::Type type_3102c = ::Reflex::ConstBuilder(type_3102);
  ::Reflex::Type type_13915 = ::Reflex::PointerBuilder(type_3102c);
  ::Reflex::Type type_2286c = ::Reflex::ConstBuilder(type_2286);
  ::Reflex::Type type_23001 = ::Reflex::PointerBuilder(type_2286c);
  ::Reflex::Type type_2894c = ::Reflex::ConstBuilder(type_2894);
  ::Reflex::Type type_23002 = ::Reflex::ReferenceBuilder(type_2894c);
  ::Reflex::Type type_23003 = ::Reflex::ReferenceBuilder(type_2918);
  ::Reflex::Type type_3059 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_3058);
  ::Reflex::Type type_23004 = ::Reflex::ReferenceBuilder(type_3059);
  ::Reflex::Type type_1078 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_235);
  ::Reflex::Type type_23209 = ::Reflex::ReferenceBuilder(type_2976);
  ::Reflex::Type type_2976c = ::Reflex::ConstBuilder(type_2976);
  ::Reflex::Type type_23210 = ::Reflex::ReferenceBuilder(type_2976c);
  ::Reflex::Type type_23005 = ::Reflex::PointerBuilder(type_2976c);
  ::Reflex::Type type_1899c = ::Reflex::ConstBuilder(type_1899);
  ::Reflex::Type type_2892 = ::Reflex::ReferenceBuilder(type_1899c);
  ::Reflex::Type type_23006 = ::Reflex::PointerBuilder(type_2976);
  ::Reflex::Type type_2944c = ::Reflex::ConstBuilder(type_2944);
  ::Reflex::Type type_23007 = ::Reflex::PointerBuilder(type_2944c);
  ::Reflex::Type type_23008 = ::Reflex::ReferenceBuilder(type_3093);
  ::Reflex::Type type_5096 = ::Reflex::ReferenceBuilder(type_2845);
  ::Reflex::Type type_2278c = ::Reflex::ConstBuilder(type_2278);
  ::Reflex::Type type_22440 = ::Reflex::ReferenceBuilder(type_2278c);
  ::Reflex::Type type_23216 = ::Reflex::ReferenceBuilder(type_2994);
  ::Reflex::Type type_2994c = ::Reflex::ConstBuilder(type_2994);
  ::Reflex::Type type_23217 = ::Reflex::ReferenceBuilder(type_2994c);
  ::Reflex::Type type_23011 = ::Reflex::PointerBuilder(type_2994c);
  ::Reflex::Type type_23012 = ::Reflex::PointerBuilder(type_2994);
  ::Reflex::Type type_2945c = ::Reflex::ConstBuilder(type_2945);
  ::Reflex::Type type_23013 = ::Reflex::PointerBuilder(type_2945c);
  ::Reflex::Type type_23245 = ::Reflex::ReferenceBuilder(type_3026);
  ::Reflex::Type type_3026c = ::Reflex::ConstBuilder(type_3026);
  ::Reflex::Type type_23246 = ::Reflex::ReferenceBuilder(type_3026c);
  ::Reflex::Type type_23016 = ::Reflex::PointerBuilder(type_3026c);
  ::Reflex::Type type_23017 = ::Reflex::PointerBuilder(type_3026);
  ::Reflex::Type type_2946c = ::Reflex::ConstBuilder(type_2946);
  ::Reflex::Type type_23018 = ::Reflex::PointerBuilder(type_2946c);
  ::Reflex::Type type_23294 = ::Reflex::ReferenceBuilder(type_3062);
  ::Reflex::Type type_3062c = ::Reflex::ConstBuilder(type_3062);
  ::Reflex::Type type_23295 = ::Reflex::ReferenceBuilder(type_3062c);
  ::Reflex::Type type_23021 = ::Reflex::PointerBuilder(type_3062c);
  ::Reflex::Type type_23022 = ::Reflex::PointerBuilder(type_3062);
  ::Reflex::Type type_2947c = ::Reflex::ConstBuilder(type_2947);
  ::Reflex::Type type_23023 = ::Reflex::PointerBuilder(type_2947c);
  ::Reflex::Type type_2279c = ::Reflex::ConstBuilder(type_2279);
  ::Reflex::Type type_23026 = ::Reflex::PointerBuilder(type_2279c);
  ::Reflex::Type type_23027 = ::Reflex::PointerBuilder(type_2279);
  ::Reflex::Type type_2948c = ::Reflex::ConstBuilder(type_2948);
  ::Reflex::Type type_23028 = ::Reflex::PointerBuilder(type_2948c);
  ::Reflex::Type type_23031 = ::Reflex::PointerBuilder(type_2280c);
  ::Reflex::Type type_23032 = ::Reflex::PointerBuilder(type_2280);
  ::Reflex::Type type_2949c = ::Reflex::ConstBuilder(type_2949);
  ::Reflex::Type type_23033 = ::Reflex::PointerBuilder(type_2949c);
  ::Reflex::Type type_8327 = ::Reflex::ReferenceBuilder(type_1657);
  ::Reflex::Type type_1657c = ::Reflex::ConstBuilder(type_1657);
  ::Reflex::Type type_8329 = ::Reflex::ReferenceBuilder(type_1657c);
  ::Reflex::Type type_3124c = ::Reflex::ConstBuilder(type_3124);
  ::Reflex::Type type_23336 = ::Reflex::ReferenceBuilder(type_3124c);
  ::Reflex::Type type_23337 = ::Reflex::ReferenceBuilder(type_3124);
  ::Reflex::Type type_1489 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_228);
  ::Reflex::Type type_2281c = ::Reflex::ConstBuilder(type_2281);
  ::Reflex::Type type_22448 = ::Reflex::ReferenceBuilder(type_2281c);
  ::Reflex::Type type_23036 = ::Reflex::PointerBuilder(type_3124c);
  ::Reflex::Type type_23037 = ::Reflex::PointerBuilder(type_3124);
  ::Reflex::Type type_2950c = ::Reflex::ConstBuilder(type_2950);
  ::Reflex::Type type_23038 = ::Reflex::PointerBuilder(type_2950c);
  ::Reflex::Type type_8391 = ::Reflex::ReferenceBuilder(type_641);
  ::Reflex::Type type_641c = ::Reflex::ConstBuilder(type_641);
  ::Reflex::Type type_8393 = ::Reflex::ReferenceBuilder(type_641c);
  ::Reflex::Type type_3125c = ::Reflex::ConstBuilder(type_3125);
  ::Reflex::Type type_23338 = ::Reflex::ReferenceBuilder(type_3125c);
  ::Reflex::Type type_23339 = ::Reflex::ReferenceBuilder(type_3125);
  ::Reflex::Type type_23041 = ::Reflex::PointerBuilder(type_3125c);
  ::Reflex::Type type_23042 = ::Reflex::PointerBuilder(type_3125);
  ::Reflex::Type type_2951c = ::Reflex::ConstBuilder(type_2951);
  ::Reflex::Type type_23043 = ::Reflex::PointerBuilder(type_2951c);
  ::Reflex::Type type_3126c = ::Reflex::ConstBuilder(type_3126);
  ::Reflex::Type type_23340 = ::Reflex::ReferenceBuilder(type_3126c);
  ::Reflex::Type type_23341 = ::Reflex::ReferenceBuilder(type_3126);
  ::Reflex::Type type_23046 = ::Reflex::PointerBuilder(type_3126c);
  ::Reflex::Type type_23047 = ::Reflex::PointerBuilder(type_3126);
  ::Reflex::Type type_2952c = ::Reflex::ConstBuilder(type_2952);
  ::Reflex::Type type_23048 = ::Reflex::PointerBuilder(type_2952c);
  ::Reflex::Type type_5064 = ::Reflex::ReferenceBuilder(type_235);
  ::Reflex::Type type_5054 = ::Reflex::ReferenceBuilder(type_235c);
  ::Reflex::Type type_3127c = ::Reflex::ConstBuilder(type_3127);
  ::Reflex::Type type_23342 = ::Reflex::ReferenceBuilder(type_3127c);
  ::Reflex::Type type_23343 = ::Reflex::ReferenceBuilder(type_3127);
  ::Reflex::Type type_23051 = ::Reflex::PointerBuilder(type_3127c);
  ::Reflex::Type type_23052 = ::Reflex::PointerBuilder(type_3127);
  ::Reflex::Type type_2953c = ::Reflex::ConstBuilder(type_2953);
  ::Reflex::Type type_23053 = ::Reflex::PointerBuilder(type_2953c);
  ::Reflex::Type type_8577 = ::Reflex::ReferenceBuilder(type_61);
  ::Reflex::Type type_61c = ::Reflex::ConstBuilder(type_61);
  ::Reflex::Type type_5032 = ::Reflex::ReferenceBuilder(type_61c);
  ::Reflex::Type type_3128c = ::Reflex::ConstBuilder(type_3128);
  ::Reflex::Type type_23344 = ::Reflex::ReferenceBuilder(type_3128c);
  ::Reflex::Type type_23345 = ::Reflex::ReferenceBuilder(type_3128);
  ::Reflex::Type type_23056 = ::Reflex::PointerBuilder(type_3128c);
  ::Reflex::Type type_23057 = ::Reflex::PointerBuilder(type_3128);
  ::Reflex::Type type_2954c = ::Reflex::ConstBuilder(type_2954);
  ::Reflex::Type type_23058 = ::Reflex::PointerBuilder(type_2954c);
  ::Reflex::Type type_23061 = ::Reflex::PointerBuilder(type_2907c);
  ::Reflex::Type type_23062 = ::Reflex::PointerBuilder(type_2907);
  ::Reflex::Type type_2955c = ::Reflex::ConstBuilder(type_2955);
  ::Reflex::Type type_23063 = ::Reflex::PointerBuilder(type_2955c);
  ::Reflex::Type type_23211 = ::Reflex::PointerBuilder(type_13239);
  ::Reflex::Type type_2985c = ::Reflex::ConstBuilder(type_2985);
  ::Reflex::Type type_23212 = ::Reflex::ReferenceBuilder(type_2985c);
  ::Reflex::Type type_23213 = ::Reflex::ReferenceBuilder(type_2985);
  ::Reflex::Type type_3079c = ::Reflex::ConstBuilder(type_3079);
  ::Reflex::Type type_23214 = ::Reflex::ReferenceBuilder(type_3079c);
  ::Reflex::Type type_23066 = ::Reflex::PointerBuilder(type_2985c);
  ::Reflex::Type type_23067 = ::Reflex::PointerBuilder(type_2985);
  ::Reflex::Type type_2956c = ::Reflex::ConstBuilder(type_2956);
  ::Reflex::Type type_23068 = ::Reflex::PointerBuilder(type_2956c);
  ::Reflex::Type type_23071 = ::Reflex::PointerBuilder(type_2918c);
  ::Reflex::Type type_23072 = ::Reflex::PointerBuilder(type_2918);
  ::Reflex::Type type_2957c = ::Reflex::ConstBuilder(type_2957);
  ::Reflex::Type type_23073 = ::Reflex::PointerBuilder(type_2957c);
  ::Reflex::Type type_3073 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::ParameterSetID"), type_3072);
  ::Reflex::Type type_3099c = ::Reflex::ConstBuilder(type_3099);
  ::Reflex::Type type_23327 = ::Reflex::ReferenceBuilder(type_3099c);
  ::Reflex::Type type_2973c = ::Reflex::ConstBuilder(type_2973);
  ::Reflex::Type type_13411 = ::Reflex::ReferenceBuilder(type_2973c);
  ::Reflex::Type type_3073c = ::Reflex::ConstBuilder(type_3073);
  ::Reflex::Type type_22957 = ::Reflex::ReferenceBuilder(type_3073c);
  ::Reflex::Type type_2291c = ::Reflex::ConstBuilder(type_2291);
  ::Reflex::Type type_22470 = ::Reflex::ReferenceBuilder(type_2291c);
  ::Reflex::Type type_13561 = ::Reflex::ReferenceBuilder(type_3099);
  ::Reflex::Type type_1788 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_1787);
  ::Reflex::Type type_1788c = ::Reflex::ConstBuilder(type_1788);
  ::Reflex::Type type_10051 = ::Reflex::ReferenceBuilder(type_1788c);
  ::Reflex::Type type_23076 = ::Reflex::PointerBuilder(type_3099c);
  ::Reflex::Type type_23077 = ::Reflex::PointerBuilder(type_3099);
  ::Reflex::Type type_2958c = ::Reflex::ConstBuilder(type_2958);
  ::Reflex::Type type_23078 = ::Reflex::PointerBuilder(type_2958c);
  ::Reflex::Type type_9899 = ::Reflex::ReferenceBuilder(type_2973);
  ::Reflex::Type type_23081 = ::Reflex::PointerBuilder(type_2973c);
  ::Reflex::Type type_23082 = ::Reflex::PointerBuilder(type_2973);
  ::Reflex::Type type_2959c = ::Reflex::ConstBuilder(type_2959);
  ::Reflex::Type type_23083 = ::Reflex::PointerBuilder(type_2959c);
  ::Reflex::Type type_23086 = ::Reflex::PointerBuilder(type_2289c);
  ::Reflex::Type type_23087 = ::Reflex::PointerBuilder(type_2289);
  ::Reflex::Type type_2960c = ::Reflex::ConstBuilder(type_2960);
  ::Reflex::Type type_23088 = ::Reflex::PointerBuilder(type_2960c);
  ::Reflex::Type type_2961c = ::Reflex::ConstBuilder(type_2961);
  ::Reflex::Type type_23091 = ::Reflex::PointerBuilder(type_2961c);
  ::Reflex::Type type_9898 = ::Reflex::ReferenceBuilder(type_3023);
  ::Reflex::Type type_22459 = ::Reflex::ReferenceBuilder(type_2285);
  ::Reflex::Type type_22469 = ::Reflex::ReferenceBuilder(type_2290);
  ::Reflex::Type type_23094 = ::Reflex::PointerBuilder(type_3023c);
  ::Reflex::Type type_23095 = ::Reflex::PointerBuilder(type_3023);
  ::Reflex::Type type_2962c = ::Reflex::ConstBuilder(type_2962);
  ::Reflex::Type type_23096 = ::Reflex::PointerBuilder(type_2962c);
  ::Reflex::Type type_2862 = ::Reflex::PointerBuilder(type_641);
  ::Reflex::Type type_2968c = ::Reflex::ConstBuilder(type_2968);
  ::Reflex::Type type_23102 = ::Reflex::ReferenceBuilder(type_2968c);
  ::Reflex::Type type_23103 = ::Reflex::ReferenceBuilder(type_2968);
  ::Reflex::Type type_23220 = ::Reflex::ReferenceBuilder(type_2999);
  ::Reflex::Type type_2999c = ::Reflex::ConstBuilder(type_2999);
  ::Reflex::Type type_23221 = ::Reflex::ReferenceBuilder(type_2999c);
  ::Reflex::Type type_23242 = ::Reflex::ReferenceBuilder(type_3024);
  ::Reflex::Type type_3024c = ::Reflex::ConstBuilder(type_3024);
  ::Reflex::Type type_23243 = ::Reflex::ReferenceBuilder(type_3024c);
  ::Reflex::Type type_23244 = ::Reflex::PointerBuilder(type_3102);
  ::Reflex::Type type_23248 = ::Reflex::ReferenceBuilder(type_3031);
  ::Reflex::Type type_3031c = ::Reflex::ConstBuilder(type_3031);
  ::Reflex::Type type_23249 = ::Reflex::ReferenceBuilder(type_3031c);
  ::Reflex::Type type_2983 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::ProcessIndex"), type_161);
  ::Reflex::Type type_3105 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::ProductIndex"), type_161);
  ::Reflex::Type type_13563 = ::Reflex::ReferenceBuilder(type_3056);
  ::Reflex::Type type_3056c = ::Reflex::ConstBuilder(type_3056);
  ::Reflex::Type type_13359 = ::Reflex::ReferenceBuilder(type_3056c);
  ::Reflex::Type type_13940 = ::Reflex::ReferenceBuilder(type_3058);
  ::Reflex::Type type_3058c = ::Reflex::ConstBuilder(type_3058);
  ::Reflex::Type type_23292 = ::Reflex::ReferenceBuilder(type_3058c);
  ::Reflex::Type type_13938 = ::Reflex::PointerBuilder(type_3058);
  ::Reflex::Type type_6785c = ::Reflex::ConstBuilder(type_6785);
  ::Reflex::Type type_23293 = ::Reflex::PointerBuilder(type_6785c);
  ::Reflex::Type type_3069c = ::Reflex::ConstBuilder(type_3069);
  ::Reflex::Type type_23303 = ::Reflex::ReferenceBuilder(type_3069c);
  ::Reflex::Type type_5085 = ::Reflex::ReferenceBuilder(type_228c);
  ::Reflex::Type type_23304 = ::Reflex::ReferenceBuilder(type_3069);
  ::Reflex::Type type_2285c = ::Reflex::ConstBuilder(type_2285);
  ::Reflex::Type type_22458 = ::Reflex::ReferenceBuilder(type_2285c);
  ::Reflex::Type type_23305 = ::Reflex::ReferenceBuilder(type_3070);
  ::Reflex::Type type_3071c = ::Reflex::ConstBuilder(type_3071);
  ::Reflex::Type type_23306 = ::Reflex::ReferenceBuilder(type_3071c);
  ::Reflex::Type type_18063 = ::Reflex::ReferenceBuilder(type_2286c);
  ::Reflex::Type type_23307 = ::Reflex::ReferenceBuilder(type_3071);
  ::Reflex::Type type_23317 = ::Reflex::ReferenceBuilder(type_3084);
  ::Reflex::Type type_5030 = ::Reflex::PointerBuilder(type_61c);
  ::Reflex::Type type_23318 = ::Reflex::ReferenceBuilder(type_3085);
  ::Reflex::Type type_3085c = ::Reflex::ConstBuilder(type_3085);
  ::Reflex::Type type_23319 = ::Reflex::ReferenceBuilder(type_3085c);
  ::Reflex::Type type_23320 = ::Reflex::ReferenceBuilder(type_3086);
  ::Reflex::Type type_3086c = ::Reflex::ConstBuilder(type_3086);
  ::Reflex::Type type_23321 = ::Reflex::ReferenceBuilder(type_3086c);
  ::Reflex::Type type_23328 = ::Reflex::ReferenceBuilder(type_13915);
  ::Reflex::Type type_23329 = ::Reflex::ReferenceBuilder(type_3104);
  ::Reflex::Type type_3117c = ::Reflex::ConstBuilder(type_3117);
  ::Reflex::Type type_23330 = ::Reflex::ReferenceBuilder(type_3117c);
  ::Reflex::Type type_3036c = ::Reflex::ConstBuilder(type_3036);
  ::Reflex::Type type_23331 = ::Reflex::ReferenceBuilder(type_3036c);
  ::Reflex::Type type_3005c = ::Reflex::ConstBuilder(type_3005);
  ::Reflex::Type type_23332 = ::Reflex::ReferenceBuilder(type_3005c);
  ::Reflex::Type type_3025c = ::Reflex::ConstBuilder(type_3025);
  ::Reflex::Type type_23333 = ::Reflex::ReferenceBuilder(type_3025c);
  ::Reflex::Type type_13562 = ::Reflex::ReferenceBuilder(type_3116);
  ::Reflex::Type type_3116c = ::Reflex::ConstBuilder(type_3116);
  ::Reflex::Type type_23335 = ::Reflex::ReferenceBuilder(type_3116c);
  ::Reflex::Type type_13713 = ::Reflex::ReferenceBuilder(type_6785);
  ::Reflex::Type type_30747 = ::Reflex::ReferenceBuilder(type_6785c);
  ::Reflex::Type type_13711 = ::Reflex::PointerBuilder(type_6785);
  ::Reflex::Type type_19051 = ::Reflex::ReferenceBuilder(type_1788);
  ::Reflex::Type type_13234c = ::Reflex::ConstBuilder(type_13234);
  ::Reflex::Type type_31165 = ::Reflex::ReferenceBuilder(type_13234c);
  ::Reflex::Type type_31167 = ::Reflex::ReferenceBuilder(type_13234);
  ::Reflex::Type type_13235c = ::Reflex::ConstBuilder(type_13235);
  ::Reflex::Type type_31168 = ::Reflex::PointerBuilder(type_13235c);
  ::Reflex::Type type_31173 = ::Reflex::ReferenceBuilder(type_13239);
  ::Reflex::Type type_13239c = ::Reflex::ConstBuilder(type_13239);
  ::Reflex::Type type_31174 = ::Reflex::ReferenceBuilder(type_13239c);
  ::Reflex::Type type_13240c = ::Reflex::ConstBuilder(type_13240);
  ::Reflex::Type type_31175 = ::Reflex::ReferenceBuilder(type_13240c);
  ::Reflex::Type type_31176 = ::Reflex::ReferenceBuilder(type_13240);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __std__vector_edm__EventAuxiliary_
#undef __std__vector_edm__EventAuxiliary_
#endif
class __std__vector_edm__EventAuxiliary_ : protected ::std::_Vector_base<edm::EventAuxiliary,std::allocator<edm::EventAuxiliary> > {
  public:
  __std__vector_edm__EventAuxiliary_();
};
#ifdef __edmNew__dstvdetails__DetSetVectorTrans
#undef __edmNew__dstvdetails__DetSetVectorTrans
#endif
struct __edmNew__dstvdetails__DetSetVectorTrans {
  public:
  __edmNew__dstvdetails__DetSetVectorTrans();
  bool filling;
  ::boost::any getter;
};
#ifdef __edmNew__dstvdetails__DetSetVectorTrans__Item
#undef __edmNew__dstvdetails__DetSetVectorTrans__Item
#endif
struct __edmNew__dstvdetails__DetSetVectorTrans__Item {
  public:
  __edmNew__dstvdetails__DetSetVectorTrans__Item();
  unsigned int id;
  int offset;
  unsigned int size;
};
#ifdef __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item_
#undef __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item_
#endif
class __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item_ : protected ::std::_Vector_base<edmNew::dstvdetails::DetSetVectorTrans::Item,std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item> > {
  public:
  __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item_();
};
#ifdef __edm__HLTPathStatus
#undef __edm__HLTPathStatus
#endif
class __edm__HLTPathStatus {
  public:
  __edm__HLTPathStatus();
  ::uint16_t status_;
};
#ifdef __std__vector_edm__HLTPathStatus_
#undef __std__vector_edm__HLTPathStatus_
#endif
class __std__vector_edm__HLTPathStatus_ : protected ::std::_Vector_base<edm::HLTPathStatus,std::allocator<edm::HLTPathStatus> > {
  public:
  __std__vector_edm__HLTPathStatus_();
};
#ifdef __edm__ConstPtrCache
#undef __edm__ConstPtrCache
#endif
class __edm__ConstPtrCache {
  public:
  __edm__ConstPtrCache();
  void* ptr_;
};
#ifdef __edm__DataFrame
#undef __edm__DataFrame
#endif
class __edm__DataFrame {
  public:
  __edm__DataFrame();
  unsigned int m_id;
  void* m_data;
  unsigned int m_size;
};
#ifdef __edm__PtrVector_int_
#undef __edm__PtrVector_int_
#endif
class __edm__PtrVector_int_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_int_();
  virtual ~__edm__PtrVector_int_() throw();
};
#ifdef __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_
#undef __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_
#endif
class __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_ {
  public:
  __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__ConditionsInEventBlock
#undef __edm__ConditionsInEventBlock
#endif
class __edm__ConditionsInEventBlock {
  public:
  __edm__ConditionsInEventBlock();
  ::uint16_t bstMasterStatus;
  ::uint32_t turnCountNumber;
};
#ifdef __edm__Wrapper_edm__ConditionsInEventBlock_
#undef __edm__Wrapper_edm__ConditionsInEventBlock_
#endif
class __edm__Wrapper_edm__ConditionsInEventBlock_ {
  public:
  __edm__Wrapper_edm__ConditionsInEventBlock_();
  bool present;
  ::edm::ConditionsInEventBlock obj;
};
#ifdef __edm__ConditionsInRunBlock
#undef __edm__ConditionsInRunBlock
#endif
class __edm__ConditionsInRunBlock {
  public:
  __edm__ConditionsInRunBlock();
  ::uint16_t beamMode;
  ::uint16_t beamMomentum;
  ::uint32_t lhcFillNumber;
  float BStartCurrent;
  float BStopCurrent;
  float BAvgCurrent;
};
#ifdef __edm__Wrapper_edm__ConditionsInRunBlock_
#undef __edm__Wrapper_edm__ConditionsInRunBlock_
#endif
class __edm__Wrapper_edm__ConditionsInRunBlock_ {
  public:
  __edm__Wrapper_edm__ConditionsInRunBlock_();
  bool present;
  ::edm::ConditionsInRunBlock obj;
};
#ifdef __edm__ConditionsInLumiBlock
#undef __edm__ConditionsInLumiBlock
#endif
class __edm__ConditionsInLumiBlock {
  public:
  __edm__ConditionsInLumiBlock();
  ::uint32_t totalIntensityBeam1;
  ::uint32_t totalIntensityBeam2;
};
#ifdef __edm__Wrapper_edm__ConditionsInLumiBlock_
#undef __edm__Wrapper_edm__ConditionsInLumiBlock_
#endif
class __edm__Wrapper_edm__ConditionsInLumiBlock_ {
  public:
  __edm__Wrapper_edm__ConditionsInLumiBlock_();
  bool present;
  ::edm::ConditionsInLumiBlock obj;
};
#ifdef __edm__MergeableCounter
#undef __edm__MergeableCounter
#endif
struct __edm__MergeableCounter {
  public:
  __edm__MergeableCounter();
  int value;
};
#ifdef __edm__Wrapper_edm__MergeableCounter_
#undef __edm__Wrapper_edm__MergeableCounter_
#endif
class __edm__Wrapper_edm__MergeableCounter_ {
  public:
  __edm__Wrapper_edm__MergeableCounter_();
  bool present;
  ::edm::MergeableCounter obj;
};
#ifdef __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s_
#undef __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s_
#endif
class __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s_ {
  public:
  __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s_();
  bool present;
  ::std::vector<edm::ErrorSummaryEntry> obj;
};
#ifdef __edm__Wrapper_std__vector_edm__EventAuxiliary_s_
#undef __edm__Wrapper_std__vector_edm__EventAuxiliary_s_
#endif
class __edm__Wrapper_std__vector_edm__EventAuxiliary_s_ {
  public:
  __edm__Wrapper_std__vector_edm__EventAuxiliary_s_();
  bool present;
  ::std::vector<edm::EventAuxiliary> obj;
};
#ifdef __edm__ValueMap_double_
#undef __edm__ValueMap_double_
#endif
class __edm__ValueMap_double_ {
  public:
  __edm__ValueMap_double_();
#ifdef __edm__ValueMap_double___IDComparator
#undef __edm__ValueMap_double___IDComparator
#endif
  struct __edm__ValueMap_double___IDComparator {
    public:
    __edm__ValueMap_double___IDComparator();
  };
  ::std::vector<double> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_double_s_
#undef __edm__Wrapper_edm__ValueMap_double_s_
#endif
class __edm__Wrapper_edm__ValueMap_double_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_double_s_();
  bool present;
  ::edm::ValueMap<double> obj;
};
#ifdef __edm__ValueMap_float_
#undef __edm__ValueMap_float_
#endif
class __edm__ValueMap_float_ {
  public:
  __edm__ValueMap_float_();
#ifdef __edm__ValueMap_float___IDComparator
#undef __edm__ValueMap_float___IDComparator
#endif
  struct __edm__ValueMap_float___IDComparator {
    public:
    __edm__ValueMap_float___IDComparator();
  };
  ::std::vector<float> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_float_s_
#undef __edm__Wrapper_edm__ValueMap_float_s_
#endif
class __edm__Wrapper_edm__ValueMap_float_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_float_s_();
  bool present;
  ::edm::ValueMap<float> obj;
};
#ifdef __edm__ValueMap_bool_
#undef __edm__ValueMap_bool_
#endif
class __edm__ValueMap_bool_ {
  public:
  __edm__ValueMap_bool_();
#ifdef __edm__ValueMap_bool___IDComparator
#undef __edm__ValueMap_bool___IDComparator
#endif
  struct __edm__ValueMap_bool___IDComparator {
    public:
    __edm__ValueMap_bool___IDComparator();
  };
  ::std::vector<bool> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_bool_s_
#undef __edm__Wrapper_edm__ValueMap_bool_s_
#endif
class __edm__Wrapper_edm__ValueMap_bool_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_bool_s_();
  bool present;
  ::edm::ValueMap<bool> obj;
};
#ifdef __edm__ValueMap_unsignedsint_
#undef __edm__ValueMap_unsignedsint_
#endif
class __edm__ValueMap_unsignedsint_ {
  public:
  __edm__ValueMap_unsignedsint_();
#ifdef __edm__ValueMap_unsignedsint___IDComparator
#undef __edm__ValueMap_unsignedsint___IDComparator
#endif
  struct __edm__ValueMap_unsignedsint___IDComparator {
    public:
    __edm__ValueMap_unsignedsint___IDComparator();
  };
  ::std::vector<unsigned int> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_unsignedsint_s_
#undef __edm__Wrapper_edm__ValueMap_unsignedsint_s_
#endif
class __edm__Wrapper_edm__ValueMap_unsignedsint_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_unsignedsint_s_();
  bool present;
  ::edm::ValueMap<unsigned int> obj;
};
#ifdef __edm__ValueMap_int_
#undef __edm__ValueMap_int_
#endif
class __edm__ValueMap_int_ {
  public:
  __edm__ValueMap_int_();
#ifdef __edm__ValueMap_int___IDComparator
#undef __edm__ValueMap_int___IDComparator
#endif
  struct __edm__ValueMap_int___IDComparator {
    public:
    __edm__ValueMap_int___IDComparator();
  };
  ::std::vector<int> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_int_s_
#undef __edm__Wrapper_edm__ValueMap_int_s_
#endif
class __edm__Wrapper_edm__ValueMap_int_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_int_s_();
  bool present;
  ::edm::ValueMap<int> obj;
};
#ifdef __edm__Wrapper_edm__PtrVector_int_s_
#undef __edm__Wrapper_edm__PtrVector_int_s_
#endif
class __edm__Wrapper_edm__PtrVector_int_s_ {
  public:
  __edm__Wrapper_edm__PtrVector_int_s_();
  bool present;
  ::edm::PtrVector<int> obj;
};
#ifdef __edm__RefToBaseVector_int_
#undef __edm__RefToBaseVector_int_
#endif
class __edm__RefToBaseVector_int_ {
  public:
  __edm__RefToBaseVector_int_();
  void* holder_;
};
#ifdef __edm__Wrapper_edm__RefToBaseVector_int_s_
#undef __edm__Wrapper_edm__RefToBaseVector_int_s_
#endif
class __edm__Wrapper_edm__RefToBaseVector_int_s_ {
  public:
  __edm__Wrapper_edm__RefToBaseVector_int_s_();
  bool present;
  ::edm::RefToBaseVector<int> obj;
};
#ifdef __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_
#undef __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_
#endif
class __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_ {
  public:
  __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_();
  bool present;
  ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > obj;
};
#ifdef __edm__TriggerResults
#undef __edm__TriggerResults
#endif
class __edm__TriggerResults : public ::edm::HLTGlobalStatus, public ::edm::DoNotRecordParents {
  public:
  __edm__TriggerResults();
  ::edm::ParameterSetID psetid_;
  ::std::vector<std::basic_string<char> > names_;
};
#ifdef __edm__Wrapper_edm__TriggerResults_
#undef __edm__Wrapper_edm__TriggerResults_
#endif
class __edm__Wrapper_edm__TriggerResults_ {
  public:
  __edm__Wrapper_edm__TriggerResults_();
  bool present;
  ::edm::TriggerResults obj;
};
#ifdef __edm__HLTGlobalStatus
#undef __edm__HLTGlobalStatus
#endif
class __edm__HLTGlobalStatus {
  public:
  __edm__HLTGlobalStatus();
  ::std::vector<edm::HLTPathStatus> paths_;
};
#ifdef __edm__Wrapper_edm__HLTGlobalStatus_
#undef __edm__Wrapper_edm__HLTGlobalStatus_
#endif
class __edm__Wrapper_edm__HLTGlobalStatus_ {
  public:
  __edm__Wrapper_edm__HLTGlobalStatus_();
  bool present;
  ::edm::HLTGlobalStatus obj;
};
#ifdef __edm__Wrapper_std__vector_edm__HLTPathStatus_s_
#undef __edm__Wrapper_std__vector_edm__HLTPathStatus_s_
#endif
class __edm__Wrapper_std__vector_edm__HLTPathStatus_s_ {
  public:
  __edm__Wrapper_std__vector_edm__HLTPathStatus_s_();
  bool present;
  ::std::vector<edm::HLTPathStatus> obj;
};
#ifdef __edm__Wrapper_edm__HLTPathStatus_
#undef __edm__Wrapper_edm__HLTPathStatus_
#endif
class __edm__Wrapper_edm__HLTPathStatus_ {
  public:
  __edm__Wrapper_edm__HLTPathStatus_();
  bool present;
  ::edm::HLTPathStatus obj;
};
#ifdef __edm__DataFrameContainer
#undef __edm__DataFrameContainer
#endif
class __edm__DataFrameContainer {
  public:
  __edm__DataFrameContainer();
  int m_subdetId;
  unsigned int m_stride;
  ::std::vector<unsigned int> m_ids;
  ::std::vector<unsigned short> m_data;
};
#ifdef __edm__Wrapper_edm__DataFrameContainer_
#undef __edm__Wrapper_edm__DataFrameContainer_
#endif
class __edm__Wrapper_edm__DataFrameContainer_ {
  public:
  __edm__Wrapper_edm__DataFrameContainer_();
  bool present;
  ::edm::DataFrameContainer obj;
};
#ifdef __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s_
#undef __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s_
#endif
class __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s_ {
  public:
  __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s_();
  ::std::vector<float> collection_;
  ::std::map<int,std::pair<unsigned int,unsigned int> > map_;
};
#ifdef __edm__BoolCache
#undef __edm__BoolCache
#endif
class __edm__BoolCache {
  public:
  __edm__BoolCache();
  bool isCached_;
};
#ifdef __edm__PtrVectorBase
#undef __edm__PtrVectorBase
#endif
class __edm__PtrVectorBase {
  public:
  __edm__PtrVectorBase();
  virtual ~__edm__PtrVectorBase() throw();
  ::edm::RefCore core_;
  ::std::vector<unsigned long> indicies_;
  ::std::vector<const void*> cachedItems_;
};
#ifdef __edm__DoNotRecordParents
#undef __edm__DoNotRecordParents
#endif
struct __edm__DoNotRecordParents {
  public:
  __edm__DoNotRecordParents();
};
#ifdef __edm__RefCore
#undef __edm__RefCore
#endif
class __edm__RefCore {
  public:
  __edm__RefCore();
  void* cachePtr_;
  ::edm::ProcessIndex processIndex_;
  ::edm::ProductIndex productIndex_;
};
#ifdef __edm__reftobase__RefVectorHolderBase
#undef __edm__reftobase__RefVectorHolderBase
#endif
class __edm__reftobase__RefVectorHolderBase {
  public:
  __edm__reftobase__RefVectorHolderBase();
  virtual ~__edm__reftobase__RefVectorHolderBase() throw();
};
#ifdef __edm__RefVectorBase_unsignedslong_
#undef __edm__RefVectorBase_unsignedslong_
#endif
class __edm__RefVectorBase_unsignedslong_ {
  public:
  __edm__RefVectorBase_unsignedslong_();
  ::edm::RefCore product_;
  ::std::vector<unsigned long> keys_;
};
#ifdef __edm__RefVectorBase_unsignedsint_
#undef __edm__RefVectorBase_unsignedsint_
#endif
class __edm__RefVectorBase_unsignedsint_ {
  public:
  __edm__RefVectorBase_unsignedsint_();
  ::edm::RefCore product_;
  ::std::vector<unsigned int> keys_;
};
#ifdef __edm__RefVectorBase_int_
#undef __edm__RefVectorBase_int_
#endif
class __edm__RefVectorBase_int_ {
  public:
  __edm__RefVectorBase_int_();
  ::edm::RefCore product_;
  ::std::vector<int> keys_;
};
#ifdef __edm__Ptr_int_
#undef __edm__Ptr_int_
#endif
class __edm__Ptr_int_ {
  public:
  __edm__Ptr_int_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__DoNotSortUponInsertion
#undef __edm__DoNotSortUponInsertion
#endif
struct __edm__DoNotSortUponInsertion {
  public:
  __edm__DoNotSortUponInsertion();
};
#ifdef __edm__Other
#undef __edm__Other
#endif
struct __edm__Other {
  public:
  __edm__Other();
};
#ifdef __edm__EDProductGetter
#undef __edm__EDProductGetter
#endif
class __edm__EDProductGetter : private ::boost::noncopyable_::noncopyable {
  public:
  __edm__EDProductGetter();
  virtual ~__edm__EDProductGetter() throw();
};
#ifdef __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_
#undef __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_
#endif
class __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_ {
  public:
  __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefCoreWithIndex
#undef __edm__RefCoreWithIndex
#endif
class __edm__RefCoreWithIndex {
  public:
  __edm__RefCoreWithIndex();
  void* cachePtr_;
  ::edm::ProcessIndex processIndex_;
  ::edm::ProductIndex productIndex_;
  unsigned int elementIndex_;
};
#ifdef __edm__reftobase__RefHolderBase
#undef __edm__reftobase__RefHolderBase
#endif
class __edm__reftobase__RefHolderBase {
  public:
  __edm__reftobase__RefHolderBase();
  virtual ~__edm__reftobase__RefHolderBase() throw();
};
#ifdef __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_
#undef __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_
#endif
class __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_ : public ::edm::reftobase::BaseVectorHolder<int> {
  public:
  __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_();
  virtual ~__edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_() throw();
  ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > refVector_;
};
#ifdef __edm__reftobase__BaseVectorHolder_int_
#undef __edm__reftobase__BaseVectorHolder_int_
#endif
class __edm__reftobase__BaseVectorHolder_int_ {
  public:
  __edm__reftobase__BaseVectorHolder_int_();
  virtual ~__edm__reftobase__BaseVectorHolder_int_() throw();
};
#ifdef __edm__reftobase__IndirectVectorHolder_int_
#undef __edm__reftobase__IndirectVectorHolder_int_
#endif
class __edm__reftobase__IndirectVectorHolder_int_ : public ::edm::reftobase::BaseVectorHolder<int> {
  public:
  __edm__reftobase__IndirectVectorHolder_int_();
  virtual ~__edm__reftobase__IndirectVectorHolder_int_() throw();
  void* helper_;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class vector<edm::EventAuxiliary,std::allocator<edm::EventAuxiliary> > -------------------------------
static void constructor_8211( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::EventAuxiliary>();
  else ::new(mem) ::std::vector<edm::EventAuxiliary>();
}

static void constructor_8212( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::EventAuxiliary>(*(const ::std::allocator<edm::EventAuxiliary>*)arg[0]);
  else ::new(mem) ::std::vector<edm::EventAuxiliary>(*(const ::std::allocator<edm::EventAuxiliary>*)arg[0]);
}

static void constructor_8213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::EventAuxiliary>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::EventAuxiliary>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::EventAuxiliary>(*(::std::size_t*)arg[0],
      *(const ::edm::EventAuxiliary*)arg[1]);
  else ::new(mem) ::std::vector<edm::EventAuxiliary>(*(::std::size_t*)arg[0],
      *(const ::edm::EventAuxiliary*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::EventAuxiliary>(*(::std::size_t*)arg[0],
      *(const ::edm::EventAuxiliary*)arg[1],
      *(const ::std::allocator<edm::EventAuxiliary>*)arg[2]);
  else ::new(mem) ::std::vector<edm::EventAuxiliary>(*(::std::size_t*)arg[0],
      *(const ::edm::EventAuxiliary*)arg[1],
      *(const ::std::allocator<edm::EventAuxiliary>*)arg[2]);
  }
}

static void constructor_8214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::EventAuxiliary>(*(const ::std::vector<edm::EventAuxiliary>*)arg[0]);
  else ::new(mem) ::std::vector<edm::EventAuxiliary>(*(const ::std::vector<edm::EventAuxiliary>*)arg[0]);
}

static void destructor_8215(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::EventAuxiliary>*)o)->::std::vector<edm::EventAuxiliary>::~vector)();
}
static  void operator_8216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::EventAuxiliary>*)o)->operator=)(*(const ::std::vector<edm::EventAuxiliary>*)arg[0]);
  else   (((::std::vector<edm::EventAuxiliary>*)o)->operator=)(*(const ::std::vector<edm::EventAuxiliary>*)arg[0]);
}

static  void method_8217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::EventAuxiliary>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::EventAuxiliary*)arg[1]);
}

static  void method_8218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >)((((::std::vector<edm::EventAuxiliary>*)o)->begin)());
  else   (((::std::vector<edm::EventAuxiliary>*)o)->begin)();
}

static  void method_8219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >)((((const ::std::vector<edm::EventAuxiliary>*)o)->begin)());
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->begin)();
}

static  void method_8220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >)((((::std::vector<edm::EventAuxiliary>*)o)->end)());
  else   (((::std::vector<edm::EventAuxiliary>*)o)->end)();
}

static  void method_8221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >)((((const ::std::vector<edm::EventAuxiliary>*)o)->end)());
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->end)();
}

static  void method_8226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::EventAuxiliary>*)o)->size)());
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->size)();
}

static  void method_8227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::EventAuxiliary>*)o)->max_size)());
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->max_size)();
}

static  void method_8228( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::EventAuxiliary>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::EventAuxiliary>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::EventAuxiliary*)arg[1]);
  }
}

static  void method_8229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::EventAuxiliary>*)o)->capacity)());
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->capacity)();
}

static  void method_8230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::EventAuxiliary>*)o)->empty)());
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->empty)();
}

static  void method_8231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::EventAuxiliary>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::EventAuxiliary>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::EventAuxiliary>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::EventAuxiliary>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::EventAuxiliary>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::EventAuxiliary>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::EventAuxiliary>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::EventAuxiliary>*)o)->front)();
  else   (((::std::vector<edm::EventAuxiliary>*)o)->front)();
}

static  void method_8238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::EventAuxiliary>*)o)->front)();
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->front)();
}

static  void method_8239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::EventAuxiliary>*)o)->back)();
  else   (((::std::vector<edm::EventAuxiliary>*)o)->back)();
}

static  void method_8240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::EventAuxiliary>*)o)->back)();
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->back)();
}

static  void method_8241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::EventAuxiliary>*)o)->data)());
  else   (((::std::vector<edm::EventAuxiliary>*)o)->data)();
}

static  void method_8242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::EventAuxiliary>*)o)->data)());
  else   (((const ::std::vector<edm::EventAuxiliary>*)o)->data)();
}

static  void method_8243( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::EventAuxiliary>*)o)->push_back)(*(const ::edm::EventAuxiliary*)arg[0]);
}

static  void method_8244( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::EventAuxiliary>*)o)->pop_back)();
}

static  void method_8245( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >)((((::std::vector<edm::EventAuxiliary>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >*)arg[0],
    *(const ::edm::EventAuxiliary*)arg[1]));
  else   (((::std::vector<edm::EventAuxiliary>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >*)arg[0],
    *(const ::edm::EventAuxiliary*)arg[1]);
}

static  void method_8246( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::EventAuxiliary>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::EventAuxiliary*)arg[2]);
}

static  void method_8247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >)((((::std::vector<edm::EventAuxiliary>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >*)arg[0]));
  else   (((::std::vector<edm::EventAuxiliary>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >*)arg[0]);
}

static  void method_8248( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >)((((::std::vector<edm::EventAuxiliary>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >*)arg[1]));
  else   (((::std::vector<edm::EventAuxiliary>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::EventAuxiliary*,std::vector<edm::EventAuxiliary> >*)arg[1]);
}

static  void method_8249( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::EventAuxiliary>*)o)->swap)(*(::std::vector<edm::EventAuxiliary>*)arg[0]);
}

static  void method_8250( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::EventAuxiliary>*)o)->clear)();
}

static void method_newdel_2280( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::EventAuxiliary> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::EventAuxiliary> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::EventAuxiliary> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::EventAuxiliary> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::EventAuxiliary> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::EventAuxiliary,std::allocator<edm::EventAuxiliary> >")), ::Reflex::BaseOffset< ::std::vector<edm::EventAuxiliary>,::std::_Vector_base<edm::EventAuxiliary,std::allocator<edm::EventAuxiliary> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::EventAuxiliary> >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::EventAuxiliary> >::Generate();
}

//------Dictionary for class vector<edm::EventAuxiliary,std::allocator<edm::EventAuxiliary> > -------------------------------
void __std__vector_edm__EventAuxiliary__db_datamem(Reflex::Class*);
void __std__vector_edm__EventAuxiliary__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__EventAuxiliary__datamem_bld(&__std__vector_edm__EventAuxiliary__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__EventAuxiliary__funcmem_bld(&__std__vector_edm__EventAuxiliary__db_funcmem);
void __std__vector_edm__EventAuxiliary__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::EventAuxiliary>"), typeid(::std::vector<edm::EventAuxiliary>), sizeof(::std::vector<edm::EventAuxiliary>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2034, ::Reflex::BaseOffset< ::std::vector<edm::EventAuxiliary>, ::std::_Vector_base<edm::EventAuxiliary,std::allocator<edm::EventAuxiliary> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3063, Reflex::Literal("std::vector<edm::EventAuxiliary>::_Alloc_value_type"))
  .AddTypedef(type_2034, Reflex::Literal("std::vector<edm::EventAuxiliary>::_Base"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<edm::EventAuxiliary>::_Tp_alloc_type"))
  .AddTypedef(type_3063, Reflex::Literal("std::vector<edm::EventAuxiliary>::value_type"))
  .AddTypedef(type_8196, Reflex::Literal("std::vector<edm::EventAuxiliary>::pointer"))
  .AddTypedef(type_8198, Reflex::Literal("std::vector<edm::EventAuxiliary>::const_pointer"))
  .AddTypedef(type_8200, Reflex::Literal("std::vector<edm::EventAuxiliary>::reference"))
  .AddTypedef(type_8202, Reflex::Literal("std::vector<edm::EventAuxiliary>::const_reference"))
  .AddTypedef(type_3582, Reflex::Literal("std::vector<edm::EventAuxiliary>::iterator"))
  .AddTypedef(type_3583, Reflex::Literal("std::vector<edm::EventAuxiliary>::const_iterator"))
  .AddTypedef(type_2648, Reflex::Literal("std::vector<edm::EventAuxiliary>::const_reverse_iterator"))
  .AddTypedef(type_2649, Reflex::Literal("std::vector<edm::EventAuxiliary>::reverse_iterator"))
  .AddTypedef(type_2504, Reflex::Literal("std::vector<edm::EventAuxiliary>::size_type"))
  .AddTypedef(type_2401, Reflex::Literal("std::vector<edm::EventAuxiliary>::difference_type"))
  .AddTypedef(type_2521, Reflex::Literal("std::vector<edm::EventAuxiliary>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8211, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22011), Reflex::Literal("vector"), constructor_8212, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2504, type_8202, type_22011), Reflex::Literal("vector"), constructor_8213, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22446), Reflex::Literal("vector"), constructor_8214, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8215, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2280, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__EventAuxiliary__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::EventAuxiliary,std::allocator<edm::EventAuxiliary> > -------------------
void __std__vector_edm__EventAuxiliary__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::EventAuxiliary,std::allocator<edm::EventAuxiliary> > -------------------
void __std__vector_edm__EventAuxiliary__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22447, type_22446), Reflex::Literal("operator="), operator_8216, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504, type_8202), Reflex::Literal("assign"), method_8217, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3582), Reflex::Literal("begin"), method_8218, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3583), Reflex::Literal("begin"), method_8219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3582), Reflex::Literal("end"), method_8220, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3583), Reflex::Literal("end"), method_8221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("size"), method_8226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("max_size"), method_8227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504, type_3063), Reflex::Literal("resize"), method_8228, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("capacity"), method_8229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_8230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504), Reflex::Literal("reserve"), method_8231, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8200, type_2504), Reflex::Literal("operator[]"), operator_8232, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8202, type_2504), Reflex::Literal("operator[]"), operator_8233, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8200, type_2504), Reflex::Literal("at"), method_8235, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8202, type_2504), Reflex::Literal("at"), method_8236, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8200), Reflex::Literal("front"), method_8237, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8202), Reflex::Literal("front"), method_8238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8200), Reflex::Literal("back"), method_8239, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8202), Reflex::Literal("back"), method_8240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8196), Reflex::Literal("data"), method_8241, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8198), Reflex::Literal("data"), method_8242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_8202), Reflex::Literal("push_back"), method_8243, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("pop_back"), method_8244, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3582, type_3582, type_8202), Reflex::Literal("insert"), method_8245, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_3582, type_2504, type_8202), Reflex::Literal("insert"), method_8246, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3582, type_3582), Reflex::Literal("erase"), method_8247, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3582, type_3582, type_3582), Reflex::Literal("erase"), method_8248, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_22447), Reflex::Literal("swap"), method_8249, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_8250, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class DetSetVectorTrans -------------------------------
static void destructor_23506(void*, void * o, const std::vector<void*>&, void *) {
(((::edmNew::dstvdetails::DetSetVectorTrans*)o)->::edmNew::dstvdetails::DetSetVectorTrans::~DetSetVectorTrans)();
}
static  void operator_23507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edmNew::dstvdetails::DetSetVectorTrans*)o)->operator=)(*(const ::edmNew::dstvdetails::DetSetVectorTrans*)arg[0]);
  else   (((::edmNew::dstvdetails::DetSetVectorTrans*)o)->operator=)(*(const ::edmNew::dstvdetails::DetSetVectorTrans*)arg[0]);
}

static void constructor_23508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans(*(const ::edmNew::dstvdetails::DetSetVectorTrans*)arg[0]);
  else ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans(*(const ::edmNew::dstvdetails::DetSetVectorTrans*)arg[0]);
}

static void constructor_23509( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans();
  else ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans();
}

static void method_newdel_14844( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DetSetVectorTrans -------------------------------
void __edmNew__dstvdetails__DetSetVectorTrans_db_datamem(Reflex::Class*);
void __edmNew__dstvdetails__DetSetVectorTrans_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edmNew__dstvdetails__DetSetVectorTrans_datamem_bld(&__edmNew__dstvdetails__DetSetVectorTrans_db_datamem);
Reflex::GenreflexMemberBuilder __edmNew__dstvdetails__DetSetVectorTrans_funcmem_bld(&__edmNew__dstvdetails__DetSetVectorTrans_db_funcmem);
void __edmNew__dstvdetails__DetSetVectorTrans_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edmNew::dstvdetails::DetSetVectorTrans"), typeid(::edmNew::dstvdetails::DetSetVectorTrans), sizeof(::edmNew::dstvdetails::DetSetVectorTrans), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_235, Reflex::Literal("edmNew::dstvdetails::DetSetVectorTrans::size_type"))
  .AddTypedef(type_235, Reflex::Literal("edmNew::dstvdetails::DetSetVectorTrans::id_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DetSetVectorTrans"), destructor_23506, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31271, type_31272), Reflex::Literal("operator="), operator_23507, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31272), Reflex::Literal("DetSetVectorTrans"), constructor_23508, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DetSetVectorTrans"), constructor_23509, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_14844, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edmNew__dstvdetails__DetSetVectorTrans_datamem_bld);
}

//------Delayed data member builder for class DetSetVectorTrans -------------------
void __edmNew__dstvdetails__DetSetVectorTrans_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("filling"), OffsetOf(__shadow__::__edmNew__dstvdetails__DetSetVectorTrans, filling), ::Reflex::PUBLIC | ::Reflex::TRANSIENT)
  .AddDataMember(type_4533, Reflex::Literal("getter"), OffsetOf(__shadow__::__edmNew__dstvdetails__DetSetVectorTrans, getter), ::Reflex::PUBLIC | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class DetSetVectorTrans -------------------
void __edmNew__dstvdetails__DetSetVectorTrans_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Item -------------------------------
static void destructor_21657(void*, void * o, const std::vector<void*>&, void *) {
(((::edmNew::dstvdetails::DetSetVectorTrans::Item*)o)->::edmNew::dstvdetails::DetSetVectorTrans::Item::~Item)();
}
static  void operator_21658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edmNew::dstvdetails::DetSetVectorTrans::Item*)o)->operator=)(*(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[0]);
  else   (((::edmNew::dstvdetails::DetSetVectorTrans::Item*)o)->operator=)(*(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[0]);
}

static void constructor_21659( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item(*(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[0]);
  else ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item(*(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[0]);
}

static void constructor_21660( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item();
  else ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item(*(unsigned int*)arg[0]);
  else ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item(*(unsigned int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item(*(unsigned int*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item(*(unsigned int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item(*(unsigned int*)arg[0],
      *(int*)arg[1],
      *(unsigned int*)arg[2]);
  else ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item(*(unsigned int*)arg[0],
      *(int*)arg[1],
      *(unsigned int*)arg[2]);
  }
}

static  void operator_21661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)o)->operator<)(*(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[0]));
  else   (((const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)o)->operator<)(*(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[0]);
}

static  void converter_21662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)o)->operator unsigned int)());
  else   (((const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)o)->operator unsigned int)();
}

static void constructor_x4( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item();
  else ::new(mem) ::edmNew::dstvdetails::DetSetVectorTrans::Item();
}

static void method_newdel_5005( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans::Item >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans::Item >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans::Item >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans::Item >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edmNew::dstvdetails::DetSetVectorTrans::Item >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Item -------------------------------
void __edmNew__dstvdetails__DetSetVectorTrans__Item_db_datamem(Reflex::Class*);
void __edmNew__dstvdetails__DetSetVectorTrans__Item_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edmNew__dstvdetails__DetSetVectorTrans__Item_datamem_bld(&__edmNew__dstvdetails__DetSetVectorTrans__Item_db_datamem);
Reflex::GenreflexMemberBuilder __edmNew__dstvdetails__DetSetVectorTrans__Item_funcmem_bld(&__edmNew__dstvdetails__DetSetVectorTrans__Item_db_funcmem);
void __edmNew__dstvdetails__DetSetVectorTrans__Item_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edmNew::dstvdetails::DetSetVectorTrans::Item"), typeid(::edmNew::dstvdetails::DetSetVectorTrans::Item), sizeof(::edmNew::dstvdetails::DetSetVectorTrans::Item), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Item"), destructor_21657, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5010, type_5021), Reflex::Literal("operator="), operator_21658, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5021), Reflex::Literal("Item"), constructor_21659, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_235, type_61, type_235), Reflex::Literal("Item"), constructor_21660, 0, "i=0;io=-0x00000000000000001;is=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Item"), constructor_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5005, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edmNew__dstvdetails__DetSetVectorTrans__Item_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edmNew__dstvdetails__DetSetVectorTrans__Item_funcmem_bld);
}

//------Delayed data member builder for class Item -------------------
void __edmNew__dstvdetails__DetSetVectorTrans__Item_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_235, Reflex::Literal("id"), OffsetOf(__shadow__::__edmNew__dstvdetails__DetSetVectorTrans__Item, id), ::Reflex::PUBLIC)
  .AddDataMember(type_61, Reflex::Literal("offset"), OffsetOf(__shadow__::__edmNew__dstvdetails__DetSetVectorTrans__Item, offset), ::Reflex::PUBLIC)
  .AddDataMember(type_235, Reflex::Literal("size"), OffsetOf(__shadow__::__edmNew__dstvdetails__DetSetVectorTrans__Item, size), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Item -------------------
void __edmNew__dstvdetails__DetSetVectorTrans__Item_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_5021), Reflex::Literal("operator<"), operator_21661, 0, "rh", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("operator unsigned int"), converter_21662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST);
}
//------Stub functions for class vector<edmNew::dstvdetails::DetSetVectorTrans::Item,std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item> > -------------------------------
static void constructor_8648( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>();
  else ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>();
}

static void constructor_8649( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(const ::std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item>*)arg[0]);
  else ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(const ::std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item>*)arg[0]);
}

static void constructor_8650( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(::std::size_t*)arg[0],
      *(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[1]);
  else ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(::std::size_t*)arg[0],
      *(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(::std::size_t*)arg[0],
      *(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[1],
      *(const ::std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item>*)arg[2]);
  else ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(::std::size_t*)arg[0],
      *(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[1],
      *(const ::std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item>*)arg[2]);
  }
}

static void constructor_8651( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)arg[0]);
  else ::new(mem) ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>(*(const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)arg[0]);
}

static void destructor_8652(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::~vector)();
}
static  void operator_8653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->operator=)(*(const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)arg[0]);
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->operator=)(*(const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)arg[0]);
}

static  void method_8654( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[1]);
}

static  void method_8655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >)((((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->begin)());
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->begin)();
}

static  void method_8656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >)((((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->begin)());
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->begin)();
}

static  void method_8657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >)((((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->end)());
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->end)();
}

static  void method_8658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >)((((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->end)());
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->end)();
}

static  void method_8663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->size)());
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->size)();
}

static  void method_8664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->max_size)());
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->max_size)();
}

static  void method_8665( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[1]);
  }
}

static  void method_8666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->capacity)());
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->capacity)();
}

static  void method_8667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->empty)());
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->empty)();
}

static  void method_8668( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8670( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->front)();
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->front)();
}

static  void method_8675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->front)();
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->front)();
}

static  void method_8676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->back)();
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->back)();
}

static  void method_8677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->back)();
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->back)();
}

static  void method_8678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->data)());
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->data)();
}

static  void method_8679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->data)());
  else   (((const ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->data)();
}

static  void method_8680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->push_back)(*(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[0]);
}

static  void method_8681( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->pop_back)();
}

static  void method_8682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >)((((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >*)arg[0],
    *(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[1]));
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >*)arg[0],
    *(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[1]);
}

static  void method_8683( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edmNew::dstvdetails::DetSetVectorTrans::Item*)arg[2]);
}

static  void method_8684( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >)((((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >*)arg[0]));
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >*)arg[0]);
}

static  void method_8685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >)((((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >*)arg[1]));
  else   (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edmNew::dstvdetails::DetSetVectorTrans::Item*,std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >*)arg[1]);
}

static  void method_8686( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->swap)(*(::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)arg[0]);
}

static  void method_8687( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>*)o)->clear)();
}

static void method_newdel_2287( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edmNew::dstvdetails::DetSetVectorTrans::Item,std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item> >")), ::Reflex::BaseOffset< ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>,::std::_Vector_base<edmNew::dstvdetails::DetSetVectorTrans::Item,std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >::Generate();
  else ::Reflex::Proxy< ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> >::Generate();
}

//------Dictionary for class vector<edmNew::dstvdetails::DetSetVectorTrans::Item,std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item> > -------------------------------
void __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__db_datamem(Reflex::Class*);
void __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__datamem_bld(&__std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__funcmem_bld(&__std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__db_funcmem);
void __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>"), typeid(::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>), sizeof(::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2040, ::Reflex::BaseOffset< ::std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>, ::std::_Vector_base<edmNew::dstvdetails::DetSetVectorTrans::Item,std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5005, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::_Alloc_value_type"))
  .AddTypedef(type_2040, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::_Base"))
  .AddTypedef(type_2528, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::_Tp_alloc_type"))
  .AddTypedef(type_5005, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::value_type"))
  .AddTypedef(type_5008, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::pointer"))
  .AddTypedef(type_5019, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::const_pointer"))
  .AddTypedef(type_5010, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::reference"))
  .AddTypedef(type_5021, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::const_reference"))
  .AddTypedef(type_3597, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::iterator"))
  .AddTypedef(type_3596, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::const_iterator"))
  .AddTypedef(type_2664, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::const_reverse_iterator"))
  .AddTypedef(type_2665, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::reverse_iterator"))
  .AddTypedef(type_2504, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::size_type"))
  .AddTypedef(type_2401, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::difference_type"))
  .AddTypedef(type_2528, Reflex::Literal("std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8648, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22083), Reflex::Literal("vector"), constructor_8649, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2504, type_5021, type_22083), Reflex::Literal("vector"), constructor_8650, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22461), Reflex::Literal("vector"), constructor_8651, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8652, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2287, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__funcmem_bld);
}

//------Delayed data member builder for class vector<edmNew::dstvdetails::DetSetVectorTrans::Item,std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item> > -------------------
void __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edmNew::dstvdetails::DetSetVectorTrans::Item,std::allocator<edmNew::dstvdetails::DetSetVectorTrans::Item> > -------------------
void __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9896, type_22461), Reflex::Literal("operator="), operator_8653, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504, type_5021), Reflex::Literal("assign"), method_8654, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3597), Reflex::Literal("begin"), method_8655, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3596), Reflex::Literal("begin"), method_8656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3597), Reflex::Literal("end"), method_8657, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3596), Reflex::Literal("end"), method_8658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("size"), method_8663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("max_size"), method_8664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504, type_5005), Reflex::Literal("resize"), method_8665, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("capacity"), method_8666, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_8667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504), Reflex::Literal("reserve"), method_8668, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5010, type_2504), Reflex::Literal("operator[]"), operator_8669, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5021, type_2504), Reflex::Literal("operator[]"), operator_8670, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5010, type_2504), Reflex::Literal("at"), method_8672, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5021, type_2504), Reflex::Literal("at"), method_8673, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5010), Reflex::Literal("front"), method_8674, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5021), Reflex::Literal("front"), method_8675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5010), Reflex::Literal("back"), method_8676, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5021), Reflex::Literal("back"), method_8677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5008), Reflex::Literal("data"), method_8678, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5019), Reflex::Literal("data"), method_8679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_5021), Reflex::Literal("push_back"), method_8680, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("pop_back"), method_8681, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3597, type_3597, type_5021), Reflex::Literal("insert"), method_8682, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_3597, type_2504, type_5021), Reflex::Literal("insert"), method_8683, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3597, type_3597), Reflex::Literal("erase"), method_8684, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3597, type_3597, type_3597), Reflex::Literal("erase"), method_8685, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_9896), Reflex::Literal("swap"), method_8686, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_8687, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class HLTPathStatus -------------------------------
static void destructor_13506(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::HLTPathStatus*)o)->::edm::HLTPathStatus::~HLTPathStatus)();
}
static  void operator_13507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::HLTPathStatus*)o)->operator=)(*(const ::edm::HLTPathStatus*)arg[0]);
  else   (((::edm::HLTPathStatus*)o)->operator=)(*(const ::edm::HLTPathStatus*)arg[0]);
}

static void constructor_13508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HLTPathStatus(*(const ::edm::HLTPathStatus*)arg[0]);
  else ::new(mem) ::edm::HLTPathStatus(*(const ::edm::HLTPathStatus*)arg[0]);
}

static void constructor_13509( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HLTPathStatus();
  else ::new(mem) ::edm::HLTPathStatus();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HLTPathStatus(*(const ::edm::hlt::HLTState*)arg[0]);
  else ::new(mem) ::edm::HLTPathStatus(*(const ::edm::hlt::HLTState*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HLTPathStatus(*(const ::edm::hlt::HLTState*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::HLTPathStatus(*(const ::edm::hlt::HLTState*)arg[0],
      *(const unsigned int*)arg[1]);
  }
}

static  void method_13510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::edm::HLTPathStatus*)o)->state)());
  else   (((const ::edm::HLTPathStatus*)o)->state)();
}

static  void method_13511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::HLTPathStatus*)o)->index)());
  else   (((const ::edm::HLTPathStatus*)o)->index)();
}

static  void method_13512( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::HLTPathStatus*)o)->reset)();
}

static  void method_13513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HLTPathStatus*)o)->wasrun)());
  else   (((const ::edm::HLTPathStatus*)o)->wasrun)();
}

static  void method_13514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HLTPathStatus*)o)->accept)());
  else   (((const ::edm::HLTPathStatus*)o)->accept)();
}

static  void method_13515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HLTPathStatus*)o)->error)());
  else   (((const ::edm::HLTPathStatus*)o)->error)();
}

static void constructor_x9( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HLTPathStatus();
  else ::new(mem) ::edm::HLTPathStatus();
}

static void method_newdel_3027( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::HLTPathStatus >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::HLTPathStatus >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::HLTPathStatus >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::HLTPathStatus >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::HLTPathStatus >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HLTPathStatus -------------------------------
void __edm__HLTPathStatus_db_datamem(Reflex::Class*);
void __edm__HLTPathStatus_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__HLTPathStatus_datamem_bld(&__edm__HLTPathStatus_db_datamem);
Reflex::GenreflexMemberBuilder __edm__HLTPathStatus_funcmem_bld(&__edm__HLTPathStatus_db_funcmem);
void __edm__HLTPathStatus_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::HLTPathStatus"), typeid(::edm::HLTPathStatus), sizeof(::edm::HLTPathStatus), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HLTPathStatus"), destructor_13506, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8767, type_8769), Reflex::Literal("operator="), operator_13507, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8769), Reflex::Literal("HLTPathStatus"), constructor_13508, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13296c, type_235c), Reflex::Literal("HLTPathStatus"), constructor_13509, 0, "state=Ready;index=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HLTPathStatus"), constructor_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3027, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__HLTPathStatus_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__HLTPathStatus_funcmem_bld);
}

//------Delayed data member builder for class HLTPathStatus -------------------
void __edm__HLTPathStatus_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1247, Reflex::Literal("status_"), OffsetOf(__shadow__::__edm__HLTPathStatus, status_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HLTPathStatus -------------------
void __edm__HLTPathStatus_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13296), Reflex::Literal("state"), method_13510, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("index"), method_13511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("reset"), method_13512, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("wasrun"), method_13513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("accept"), method_13514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("error"), method_13515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<edm::HLTPathStatus,std::allocator<edm::HLTPathStatus> > -------------------------------
static void constructor_8778( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::HLTPathStatus>();
  else ::new(mem) ::std::vector<edm::HLTPathStatus>();
}

static void constructor_8779( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::HLTPathStatus>(*(const ::std::allocator<edm::HLTPathStatus>*)arg[0]);
  else ::new(mem) ::std::vector<edm::HLTPathStatus>(*(const ::std::allocator<edm::HLTPathStatus>*)arg[0]);
}

static void constructor_8780( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::HLTPathStatus>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::HLTPathStatus>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::HLTPathStatus>(*(::std::size_t*)arg[0],
      *(const ::edm::HLTPathStatus*)arg[1]);
  else ::new(mem) ::std::vector<edm::HLTPathStatus>(*(::std::size_t*)arg[0],
      *(const ::edm::HLTPathStatus*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::HLTPathStatus>(*(::std::size_t*)arg[0],
      *(const ::edm::HLTPathStatus*)arg[1],
      *(const ::std::allocator<edm::HLTPathStatus>*)arg[2]);
  else ::new(mem) ::std::vector<edm::HLTPathStatus>(*(::std::size_t*)arg[0],
      *(const ::edm::HLTPathStatus*)arg[1],
      *(const ::std::allocator<edm::HLTPathStatus>*)arg[2]);
  }
}

static void constructor_8781( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::HLTPathStatus>(*(const ::std::vector<edm::HLTPathStatus>*)arg[0]);
  else ::new(mem) ::std::vector<edm::HLTPathStatus>(*(const ::std::vector<edm::HLTPathStatus>*)arg[0]);
}

static void destructor_8782(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::HLTPathStatus>*)o)->::std::vector<edm::HLTPathStatus>::~vector)();
}
static  void operator_8783( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::HLTPathStatus>*)o)->operator=)(*(const ::std::vector<edm::HLTPathStatus>*)arg[0]);
  else   (((::std::vector<edm::HLTPathStatus>*)o)->operator=)(*(const ::std::vector<edm::HLTPathStatus>*)arg[0]);
}

static  void method_8784( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::HLTPathStatus>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::HLTPathStatus*)arg[1]);
}

static  void method_8785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >)((((::std::vector<edm::HLTPathStatus>*)o)->begin)());
  else   (((::std::vector<edm::HLTPathStatus>*)o)->begin)();
}

static  void method_8786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >)((((const ::std::vector<edm::HLTPathStatus>*)o)->begin)());
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->begin)();
}

static  void method_8787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >)((((::std::vector<edm::HLTPathStatus>*)o)->end)());
  else   (((::std::vector<edm::HLTPathStatus>*)o)->end)();
}

static  void method_8788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >)((((const ::std::vector<edm::HLTPathStatus>*)o)->end)());
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->end)();
}

static  void method_8793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::HLTPathStatus>*)o)->size)());
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->size)();
}

static  void method_8794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::HLTPathStatus>*)o)->max_size)());
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->max_size)();
}

static  void method_8795( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::HLTPathStatus>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::HLTPathStatus>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::HLTPathStatus*)arg[1]);
  }
}

static  void method_8796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::HLTPathStatus>*)o)->capacity)());
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->capacity)();
}

static  void method_8797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::HLTPathStatus>*)o)->empty)());
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->empty)();
}

static  void method_8798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::HLTPathStatus>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::HLTPathStatus>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::HLTPathStatus>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8800( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::HLTPathStatus>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::HLTPathStatus>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::HLTPathStatus>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::HLTPathStatus>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::HLTPathStatus>*)o)->front)();
  else   (((::std::vector<edm::HLTPathStatus>*)o)->front)();
}

static  void method_8805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::HLTPathStatus>*)o)->front)();
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->front)();
}

static  void method_8806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::HLTPathStatus>*)o)->back)();
  else   (((::std::vector<edm::HLTPathStatus>*)o)->back)();
}

static  void method_8807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::HLTPathStatus>*)o)->back)();
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->back)();
}

static  void method_8808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::HLTPathStatus>*)o)->data)());
  else   (((::std::vector<edm::HLTPathStatus>*)o)->data)();
}

static  void method_8809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::HLTPathStatus>*)o)->data)());
  else   (((const ::std::vector<edm::HLTPathStatus>*)o)->data)();
}

static  void method_8810( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::HLTPathStatus>*)o)->push_back)(*(const ::edm::HLTPathStatus*)arg[0]);
}

static  void method_8811( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::HLTPathStatus>*)o)->pop_back)();
}

static  void method_8812( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >)((((::std::vector<edm::HLTPathStatus>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >*)arg[0],
    *(const ::edm::HLTPathStatus*)arg[1]));
  else   (((::std::vector<edm::HLTPathStatus>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >*)arg[0],
    *(const ::edm::HLTPathStatus*)arg[1]);
}

static  void method_8813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::HLTPathStatus>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::HLTPathStatus*)arg[2]);
}

static  void method_8814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >)((((::std::vector<edm::HLTPathStatus>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >*)arg[0]));
  else   (((::std::vector<edm::HLTPathStatus>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >*)arg[0]);
}

static  void method_8815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >)((((::std::vector<edm::HLTPathStatus>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >*)arg[1]));
  else   (((::std::vector<edm::HLTPathStatus>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::HLTPathStatus*,std::vector<edm::HLTPathStatus> >*)arg[1]);
}

static  void method_8816( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::HLTPathStatus>*)o)->swap)(*(::std::vector<edm::HLTPathStatus>*)arg[0]);
}

static  void method_8817( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::HLTPathStatus>*)o)->clear)();
}

static void method_newdel_2289( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::HLTPathStatus> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::HLTPathStatus> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::HLTPathStatus> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::HLTPathStatus> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::HLTPathStatus> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::HLTPathStatus,std::allocator<edm::HLTPathStatus> >")), ::Reflex::BaseOffset< ::std::vector<edm::HLTPathStatus>,::std::_Vector_base<edm::HLTPathStatus,std::allocator<edm::HLTPathStatus> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::HLTPathStatus> >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::HLTPathStatus> >::Generate();
}

//------Dictionary for class vector<edm::HLTPathStatus,std::allocator<edm::HLTPathStatus> > -------------------------------
void __std__vector_edm__HLTPathStatus__db_datamem(Reflex::Class*);
void __std__vector_edm__HLTPathStatus__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__HLTPathStatus__datamem_bld(&__std__vector_edm__HLTPathStatus__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__HLTPathStatus__funcmem_bld(&__std__vector_edm__HLTPathStatus__db_funcmem);
void __std__vector_edm__HLTPathStatus__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::HLTPathStatus>"), typeid(::std::vector<edm::HLTPathStatus>), sizeof(::std::vector<edm::HLTPathStatus>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2043, ::Reflex::BaseOffset< ::std::vector<edm::HLTPathStatus>, ::std::_Vector_base<edm::HLTPathStatus,std::allocator<edm::HLTPathStatus> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3027, Reflex::Literal("std::vector<edm::HLTPathStatus>::_Alloc_value_type"))
  .AddTypedef(type_2043, Reflex::Literal("std::vector<edm::HLTPathStatus>::_Base"))
  .AddTypedef(type_2532, Reflex::Literal("std::vector<edm::HLTPathStatus>::_Tp_alloc_type"))
  .AddTypedef(type_3027, Reflex::Literal("std::vector<edm::HLTPathStatus>::value_type"))
  .AddTypedef(type_8763, Reflex::Literal("std::vector<edm::HLTPathStatus>::pointer"))
  .AddTypedef(type_8765, Reflex::Literal("std::vector<edm::HLTPathStatus>::const_pointer"))
  .AddTypedef(type_8767, Reflex::Literal("std::vector<edm::HLTPathStatus>::reference"))
  .AddTypedef(type_8769, Reflex::Literal("std::vector<edm::HLTPathStatus>::const_reference"))
  .AddTypedef(type_3601, Reflex::Literal("std::vector<edm::HLTPathStatus>::iterator"))
  .AddTypedef(type_3602, Reflex::Literal("std::vector<edm::HLTPathStatus>::const_iterator"))
  .AddTypedef(type_2670, Reflex::Literal("std::vector<edm::HLTPathStatus>::const_reverse_iterator"))
  .AddTypedef(type_2671, Reflex::Literal("std::vector<edm::HLTPathStatus>::reverse_iterator"))
  .AddTypedef(type_2504, Reflex::Literal("std::vector<edm::HLTPathStatus>::size_type"))
  .AddTypedef(type_2401, Reflex::Literal("std::vector<edm::HLTPathStatus>::difference_type"))
  .AddTypedef(type_2532, Reflex::Literal("std::vector<edm::HLTPathStatus>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8778, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22119), Reflex::Literal("vector"), constructor_8779, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2504, type_8769, type_22119), Reflex::Literal("vector"), constructor_8780, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22466), Reflex::Literal("vector"), constructor_8781, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8782, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2289, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__HLTPathStatus__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::HLTPathStatus,std::allocator<edm::HLTPathStatus> > -------------------
void __std__vector_edm__HLTPathStatus__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::HLTPathStatus,std::allocator<edm::HLTPathStatus> > -------------------
void __std__vector_edm__HLTPathStatus__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22467, type_22466), Reflex::Literal("operator="), operator_8783, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504, type_8769), Reflex::Literal("assign"), method_8784, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3601), Reflex::Literal("begin"), method_8785, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3602), Reflex::Literal("begin"), method_8786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3601), Reflex::Literal("end"), method_8787, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3602), Reflex::Literal("end"), method_8788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("size"), method_8793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("max_size"), method_8794, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504, type_3027), Reflex::Literal("resize"), method_8795, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("capacity"), method_8796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_8797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504), Reflex::Literal("reserve"), method_8798, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8767, type_2504), Reflex::Literal("operator[]"), operator_8799, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8769, type_2504), Reflex::Literal("operator[]"), operator_8800, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8767, type_2504), Reflex::Literal("at"), method_8802, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8769, type_2504), Reflex::Literal("at"), method_8803, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8767), Reflex::Literal("front"), method_8804, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8769), Reflex::Literal("front"), method_8805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8767), Reflex::Literal("back"), method_8806, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8769), Reflex::Literal("back"), method_8807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8763), Reflex::Literal("data"), method_8808, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8765), Reflex::Literal("data"), method_8809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_8769), Reflex::Literal("push_back"), method_8810, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("pop_back"), method_8811, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3601, type_3601, type_8769), Reflex::Literal("insert"), method_8812, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_3601, type_2504, type_8769), Reflex::Literal("insert"), method_8813, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3601, type_3601), Reflex::Literal("erase"), method_8814, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3601, type_3601, type_3601), Reflex::Literal("erase"), method_8815, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_22467), Reflex::Literal("swap"), method_8816, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_8817, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class ConstPtrCache -------------------------------
static void destructor_12595(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ConstPtrCache*)o)->::edm::ConstPtrCache::~ConstPtrCache)();
}
static  void operator_12596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ConstPtrCache*)o)->operator=)(*(const ::edm::ConstPtrCache*)arg[0]);
  else   (((::edm::ConstPtrCache*)o)->operator=)(*(const ::edm::ConstPtrCache*)arg[0]);
}

static void constructor_12597( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ConstPtrCache(*(const ::edm::ConstPtrCache*)arg[0]);
  else ::new(mem) ::edm::ConstPtrCache(*(const ::edm::ConstPtrCache*)arg[0]);
}

static void constructor_12598( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ConstPtrCache();
  else ::new(mem) ::edm::ConstPtrCache();
}

static void constructor_12599( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ConstPtrCache((const void*)arg[0]);
  else ::new(mem) ::edm::ConstPtrCache((const void*)arg[0]);
}

static void method_newdel_2897( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ConstPtrCache >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ConstPtrCache >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ConstPtrCache >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ConstPtrCache >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ConstPtrCache >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___edm__ConstPtrCache_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  const void* &ptr_ = *(const void**)(target + OffsetOf(__shadow__::__edm__ConstPtrCache, ptr_));

  //--- User's code ---
    ptr_=0;
    
 
}

//------Dictionary for class ConstPtrCache -------------------------------
void __edm__ConstPtrCache_db_datamem(Reflex::Class*);
void __edm__ConstPtrCache_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ConstPtrCache_datamem_bld(&__edm__ConstPtrCache_db_datamem);
Reflex::GenreflexMemberBuilder __edm__ConstPtrCache_funcmem_bld(&__edm__ConstPtrCache_db_funcmem);
void __edm__ConstPtrCache_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "edm::ConstPtrCache";
  rule->fTarget      = "ptr_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___edm__ConstPtrCache_0);
  rule->fCode        = "\n    ptr_=0;\n    \n ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("edm::ConstPtrCache"), typeid(::edm::ConstPtrCache), sizeof(::edm::ConstPtrCache), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddProperty("ioread", readrules )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ConstPtrCache"), destructor_12595, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22938, type_22939), Reflex::Literal("operator="), operator_12596, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22939), Reflex::Literal("ConstPtrCache"), constructor_12597, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ConstPtrCache"), constructor_12598, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2845), Reflex::Literal("ConstPtrCache"), constructor_12599, 0, "iPtr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2897, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ConstPtrCache_datamem_bld);
}

//------Delayed data member builder for class ConstPtrCache -------------------
void __edm__ConstPtrCache_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2845, Reflex::Literal("ptr_"), OffsetOf(__shadow__::__edm__ConstPtrCache, ptr_), ::Reflex::PUBLIC | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class ConstPtrCache -------------------
void __edm__ConstPtrCache_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class DataFrame -------------------------------
static void destructor_12634(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DataFrame*)o)->::edm::DataFrame::~DataFrame)();
}
static  void operator_12635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DataFrame*)o)->operator=)(*(const ::edm::DataFrame*)arg[0]);
  else   (((::edm::DataFrame*)o)->operator=)(*(const ::edm::DataFrame*)arg[0]);
}

static void constructor_12636( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DataFrame(*(const ::edm::DataFrame*)arg[0]);
  else ::new(mem) ::edm::DataFrame(*(const ::edm::DataFrame*)arg[0]);
}

static void constructor_12637( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DataFrame();
  else ::new(mem) ::edm::DataFrame();
}

static void constructor_12638( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DataFrame(*(unsigned int*)arg[0],
      (const unsigned short*)arg[1],
      *(unsigned int*)arg[2]);
  else ::new(mem) ::edm::DataFrame(*(unsigned int*)arg[0],
      (const unsigned short*)arg[1],
      *(unsigned int*)arg[2]);
}

static void constructor_12639( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DataFrame(*(const ::edm::DataFrameContainer*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::DataFrame(*(const ::edm::DataFrameContainer*)arg[0],
      *(unsigned int*)arg[1]);
}

static  void method_12640( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrame*)o)->set)(*(const ::edm::DataFrameContainer*)arg[0],
    *(unsigned int*)arg[1]);
}

static  void operator_12641( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DataFrame*)o)->operator[])(*(unsigned int*)arg[0]);
  else   (((::edm::DataFrame*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void operator_12642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::edm::DataFrame*)o)->operator[])(*(unsigned int*)arg[0]));
  else   (((const ::edm::DataFrame*)o)->operator[])(*(unsigned int*)arg[0]);
}

static  void method_12643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::DataFrame*)o)->begin)());
  else   (((::edm::DataFrame*)o)->begin)();
}

static  void method_12644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::DataFrame*)o)->end)());
  else   (((::edm::DataFrame*)o)->end)();
}

static  void method_12645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::DataFrame*)o)->begin)());
  else   (((const ::edm::DataFrame*)o)->begin)();
}

static  void method_12646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::DataFrame*)o)->end)());
  else   (((const ::edm::DataFrame*)o)->end)();
}

static  void method_12647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::DataFrame*)o)->id)());
  else   (((const ::edm::DataFrame*)o)->id)();
}

static  void method_12648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::DataFrame*)o)->size)());
  else   (((const ::edm::DataFrame*)o)->size)();
}

static void method_newdel_2902( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DataFrame >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DataFrame >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DataFrame >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DataFrame >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DataFrame >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DataFrame -------------------------------
void __edm__DataFrame_db_datamem(Reflex::Class*);
void __edm__DataFrame_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DataFrame_datamem_bld(&__edm__DataFrame_db_datamem);
Reflex::GenreflexMemberBuilder __edm__DataFrame_funcmem_bld(&__edm__DataFrame_db_funcmem);
void __edm__DataFrame_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DataFrame"), typeid(::edm::DataFrame), sizeof(::edm::DataFrame), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_235, Reflex::Literal("edm::DataFrame::size_type"))
  .AddTypedef(type_235, Reflex::Literal("edm::DataFrame::id_type"))
  .AddTypedef(type_161, Reflex::Literal("edm::DataFrame::data_type"))
  .AddTypedef(type_2812, Reflex::Literal("edm::DataFrame::iterator"))
  .AddTypedef(type_5041, Reflex::Literal("edm::DataFrame::const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DataFrame"), destructor_12634, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17937, type_22945), Reflex::Literal("operator="), operator_12635, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22945), Reflex::Literal("DataFrame"), constructor_12636, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DataFrame"), constructor_12637, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_235, type_5041, type_235), Reflex::Literal("DataFrame"), constructor_12638, 0, "i;idata;isize", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22946, type_235), Reflex::Literal("DataFrame"), constructor_12639, 0, "icont;i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2902, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DataFrame_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DataFrame_funcmem_bld);
}

//------Delayed data member builder for class DataFrame -------------------
void __edm__DataFrame_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_235, Reflex::Literal("m_id"), OffsetOf(__shadow__::__edm__DataFrame, m_id), ::Reflex::PRIVATE)
  .AddDataMember(type_5041, Reflex::Literal("m_data"), OffsetOf(__shadow__::__edm__DataFrame, m_data), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("m_size"), OffsetOf(__shadow__::__edm__DataFrame, m_size), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DataFrame -------------------
void __edm__DataFrame_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_22946, type_235), Reflex::Literal("set"), method_12640, 0, "icont;i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5074, type_235), Reflex::Literal("operator[]"), operator_12641, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_161, type_235), Reflex::Literal("operator[]"), operator_12642, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2812), Reflex::Literal("begin"), method_12643, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2812), Reflex::Literal("end"), method_12644, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5041), Reflex::Literal("begin"), method_12645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5041), Reflex::Literal("end"), method_12646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("id"), method_12647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("size"), method_12648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PtrVector<int> -------------------------------
static void constructor_12706( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<int>();
  else ::new(mem) ::edm::PtrVector<int>();
}

static void constructor_12707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<int>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<int>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_12708( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<int>(*(const ::edm::PtrVector<int>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<int>(*(const ::edm::PtrVector<int>*)arg[0]);
}

static  void operator_12709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<int>)((((const ::edm::PtrVector<int>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<int>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_12710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<int>)((((const ::edm::PtrVector<int>*)o)->begin)());
  else   (((const ::edm::PtrVector<int>*)o)->begin)();
}

static  void method_12711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<int>)((((const ::edm::PtrVector<int>*)o)->end)());
  else   (((const ::edm::PtrVector<int>*)o)->end)();
}

static  void method_12712( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<int>*)o)->push_back)(*(const ::edm::Ptr<int>*)arg[0]);
}

static  void method_12713( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<int>*)o)->swap)(*(::edm::PtrVector<int>*)arg[0]);
}

static  void operator_12714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<int>*)o)->operator=)(*(const ::edm::PtrVector<int>*)arg[0]);
  else   (((::edm::PtrVector<int>*)o)->operator=)(*(const ::edm::PtrVector<int>*)arg[0]);
}

static  void method_12715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<int>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_12716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<int>*)o)->Class_Version)());
  else   (((::edm::PtrVector<int>*)o)->Class_Version)();
}

static void destructor_12719(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<int>*)o)->::edm::PtrVector<int>::~PtrVector)();
}
static void method_newdel_2907( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<int>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<int> -------------------------------
void __edm__PtrVector_int__db_datamem(Reflex::Class*);
void __edm__PtrVector_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_int__datamem_bld(&__edm__PtrVector_int__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_int__funcmem_bld(&__edm__PtrVector_int__db_funcmem);
void __edm__PtrVector_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<int>"), typeid(::edm::PtrVector<int>), sizeof(::edm::PtrVector<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<int>::Class_Version())
  .AddBase(type_3024, ::Reflex::BaseOffset< ::edm::PtrVector<int>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2981, Reflex::Literal("edm::PtrVector<int>::const_iterator"))
  .AddTypedef(type_2981, Reflex::Literal("edm::PtrVector<int>::iterator"))
  .AddTypedef(type_3084, Reflex::Literal("edm::PtrVector<int>::value_type"))
  .AddTypedef(type_2776, Reflex::Literal("edm::PtrVector<int>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_12706, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510), Reflex::Literal("PtrVector"), constructor_12707, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22993), Reflex::Literal("PtrVector"), constructor_12708, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_12719, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2907, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_int__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<int> -------------------
void __edm__PtrVector_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<int> -------------------
void __edm__PtrVector_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3084, type_228c), Reflex::Literal("operator[]"), operator_12709, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2981), Reflex::Literal("begin"), method_12710, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2981), Reflex::Literal("end"), method_12711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_22994), Reflex::Literal("push_back"), method_12712, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_22995), Reflex::Literal("swap"), method_12713, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22995, type_22993), Reflex::Literal("operator="), operator_12714, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_22439), Reflex::Literal("fillView"), method_12715, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_12716, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<int, std::allocator<int> >,int,edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > -------------------------------
static void destructor_12754(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::~RefVector)();
}
static void constructor_12755( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >();
  else ::new(mem) ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >();
}

static void constructor_12756( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
}

static void constructor_12757( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_12758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->push_back)(*(const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
}

static  void operator_12759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12760( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->refVector)();
}

static  void method_12762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->empty)();
}

static  void method_12763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->size)();
}

static  void method_12764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->capacity)();
}

static  void method_12765( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_12766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->begin)();
}

static  void method_12767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->end)();
}

static  void method_12768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->id)();
}

static  void method_12769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->productGetter)();
}

static  void method_12770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isNull)();
}

static  void method_12771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isNonnull)();
}

static  void operator_12772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator!)();
}

static  void method_12773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->product)();
}

static  void method_12774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isAvailable)();
}

static  void method_12775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isTransient)();
}

static  void method_12776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >)((((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
}

static  void method_12777( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->clear)();
}

static  void method_12778( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->swap)(*(::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
}

static  void operator_12779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
}

static  void method_12780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->hasProductCache)();
}

static  void method_12781( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_12782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->Class_Version)();
}

static void method_newdel_2918( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<int, std::allocator<int> >,int,edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > -------------------------------
void __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__datamem_bld(&__edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__funcmem_bld(&__edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_funcmem);
void __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >"), typeid(::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >), sizeof(::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::Class_Version())
  .AddTypedef(type_2286, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::collection_type"))
  .AddTypedef(type_61, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::member_type"))
  .AddTypedef(type_12700, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::finder_type"))
  .AddTypedef(type_2894, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::iterator"))
  .AddTypedef(type_2894, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::const_iterator"))
  .AddTypedef(type_3104, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::value_type"))
  .AddTypedef(type_3104c, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::const_reference"))
  .AddTypedef(type_3104c, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::reference"))
  .AddTypedef(type_235, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::key_type"))
  .AddTypedef(type_2285, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::KeyVec"))
  .AddTypedef(type_2504, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::size_type"))
  .AddTypedef(type_3070, Reflex::Literal("edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_12754, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_12755, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22998), Reflex::Literal("RefVector"), constructor_12756, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510), Reflex::Literal("RefVector"), constructor_12757, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2918, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<int, std::allocator<int> >,int,edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > -------------------
void __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3070, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<int, std::allocator<int> >,int,edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > -------------------
void __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_22999), Reflex::Literal("push_back"), method_12758, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3104c, type_2504), Reflex::Literal("operator[]"), operator_12759, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3104c, type_2504), Reflex::Literal("at"), method_12760, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23000), Reflex::Literal("refVector"), method_12761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_12762, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("size"), method_12763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("capacity"), method_12764, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504), Reflex::Literal("reserve"), method_12765, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2894), Reflex::Literal("begin"), method_12766, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2894), Reflex::Literal("end"), method_12767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_12768, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_12769, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNull"), method_12770, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNonnull"), method_12771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("operator!"), operator_12772, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23001), Reflex::Literal("product"), method_12773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_12774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isTransient"), method_12775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2894, type_23002), Reflex::Literal("erase"), method_12776, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_12777, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23003), Reflex::Literal("swap"), method_12778, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23003, type_22998), Reflex::Literal("operator="), operator_12779, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("hasProductCache"), method_12780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23004), Reflex::Literal("fillView"), method_12781, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_12782, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class ConditionsInEventBlock -------------------------------
static void destructor_13286(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ConditionsInEventBlock*)o)->::edm::ConditionsInEventBlock::~ConditionsInEventBlock)();
}
static  void operator_13287( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ConditionsInEventBlock*)o)->operator=)(*(const ::edm::ConditionsInEventBlock*)arg[0]);
  else   (((::edm::ConditionsInEventBlock*)o)->operator=)(*(const ::edm::ConditionsInEventBlock*)arg[0]);
}

static void constructor_13288( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ConditionsInEventBlock(*(const ::edm::ConditionsInEventBlock*)arg[0]);
  else ::new(mem) ::edm::ConditionsInEventBlock(*(const ::edm::ConditionsInEventBlock*)arg[0]);
}

static void constructor_13289( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ConditionsInEventBlock();
  else ::new(mem) ::edm::ConditionsInEventBlock();
}

static void method_newdel_2976( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInEventBlock >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInEventBlock >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInEventBlock >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInEventBlock >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInEventBlock >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ConditionsInEventBlock -------------------------------
void __edm__ConditionsInEventBlock_db_datamem(Reflex::Class*);
void __edm__ConditionsInEventBlock_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ConditionsInEventBlock_datamem_bld(&__edm__ConditionsInEventBlock_db_datamem);
Reflex::GenreflexMemberBuilder __edm__ConditionsInEventBlock_funcmem_bld(&__edm__ConditionsInEventBlock_db_funcmem);
void __edm__ConditionsInEventBlock_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ConditionsInEventBlock"), typeid(::edm::ConditionsInEventBlock), sizeof(::edm::ConditionsInEventBlock), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ConditionsInEventBlock"), destructor_13286, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23209, type_23210), Reflex::Literal("operator="), operator_13287, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23210), Reflex::Literal("ConditionsInEventBlock"), constructor_13288, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ConditionsInEventBlock"), constructor_13289, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2976, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ConditionsInEventBlock_datamem_bld);
}

//------Delayed data member builder for class ConditionsInEventBlock -------------------
void __edm__ConditionsInEventBlock_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1247, Reflex::Literal("bstMasterStatus"), OffsetOf(__shadow__::__edm__ConditionsInEventBlock, bstMasterStatus), ::Reflex::PUBLIC)
  .AddDataMember(type_1078, Reflex::Literal("turnCountNumber"), OffsetOf(__shadow__::__edm__ConditionsInEventBlock, turnCountNumber), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class ConditionsInEventBlock -------------------
void __edm__ConditionsInEventBlock_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Wrapper<edm::ConditionsInEventBlock> -------------------------------
static void constructor_12787( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ConditionsInEventBlock>();
  else ::new(mem) ::edm::Wrapper<edm::ConditionsInEventBlock>();
}

static void constructor_12788( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ConditionsInEventBlock>(*(::std::auto_ptr<edm::ConditionsInEventBlock>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ConditionsInEventBlock>(*(::std::auto_ptr<edm::ConditionsInEventBlock>*)arg[0]);
}

static void destructor_12789(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->::edm::Wrapper<edm::ConditionsInEventBlock>::~Wrapper)();
}
static  void method_12790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->product)();
}

static  void operator_12791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->operator->)();
}

static  void method_12792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->productTypeInfo)();
}

static  void method_12793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->typeInfo)();
}

static void constructor_12794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ConditionsInEventBlock>((::edm::ConditionsInEventBlock*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ConditionsInEventBlock>((::edm::ConditionsInEventBlock*)arg[0]);
}

static  void method_12795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->getInterface)();
}

static  void method_12796( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->dynamicTypeInfo)();
}

static  void method_12800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->isPresent)();
}

static  void method_12801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ConditionsInEventBlock>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2923( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInEventBlock> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInEventBlock> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInEventBlock> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInEventBlock> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInEventBlock> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ConditionsInEventBlock> -------------------------------
void __edm__Wrapper_edm__ConditionsInEventBlock__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ConditionsInEventBlock__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ConditionsInEventBlock__datamem_bld(&__edm__Wrapper_edm__ConditionsInEventBlock__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ConditionsInEventBlock__funcmem_bld(&__edm__Wrapper_edm__ConditionsInEventBlock__db_funcmem);
void __edm__Wrapper_edm__ConditionsInEventBlock__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ConditionsInEventBlock>"), typeid(::edm::Wrapper<edm::ConditionsInEventBlock>), sizeof(::edm::Wrapper<edm::ConditionsInEventBlock>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2976, Reflex::Literal("edm::Wrapper<edm::ConditionsInEventBlock>::value_type"))
  .AddTypedef(type_2976, Reflex::Literal("edm::Wrapper<edm::ConditionsInEventBlock>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12787, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2010), Reflex::Literal("Wrapper"), constructor_12788, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12789, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23006), Reflex::Literal("Wrapper"), constructor_12794, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2923, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ConditionsInEventBlock__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ConditionsInEventBlock__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ConditionsInEventBlock> -------------------
void __edm__Wrapper_edm__ConditionsInEventBlock__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ConditionsInEventBlock_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2976, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ConditionsInEventBlock_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ConditionsInEventBlock> -------------------
void __edm__Wrapper_edm__ConditionsInEventBlock__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23005), Reflex::Literal("product"), method_12790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23005), Reflex::Literal("operator->"), operator_12791, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12792, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12793, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23007), Reflex::Literal("getInterface"), method_12795, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12796, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12797, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12798, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ConditionsInRunBlock -------------------------------
static void destructor_13354(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ConditionsInRunBlock*)o)->::edm::ConditionsInRunBlock::~ConditionsInRunBlock)();
}
static  void operator_13355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ConditionsInRunBlock*)o)->operator=)(*(const ::edm::ConditionsInRunBlock*)arg[0]);
  else   (((::edm::ConditionsInRunBlock*)o)->operator=)(*(const ::edm::ConditionsInRunBlock*)arg[0]);
}

static void constructor_13356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ConditionsInRunBlock(*(const ::edm::ConditionsInRunBlock*)arg[0]);
  else ::new(mem) ::edm::ConditionsInRunBlock(*(const ::edm::ConditionsInRunBlock*)arg[0]);
}

static void constructor_13357( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ConditionsInRunBlock();
  else ::new(mem) ::edm::ConditionsInRunBlock();
}

static  void method_13358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ConditionsInRunBlock*)o)->isProductEqual)(*(const ::edm::ConditionsInRunBlock*)arg[0]));
  else   (((const ::edm::ConditionsInRunBlock*)o)->isProductEqual)(*(const ::edm::ConditionsInRunBlock*)arg[0]);
}

static void method_newdel_2994( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInRunBlock >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInRunBlock >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInRunBlock >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInRunBlock >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInRunBlock >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ConditionsInRunBlock -------------------------------
void __edm__ConditionsInRunBlock_db_datamem(Reflex::Class*);
void __edm__ConditionsInRunBlock_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ConditionsInRunBlock_datamem_bld(&__edm__ConditionsInRunBlock_db_datamem);
Reflex::GenreflexMemberBuilder __edm__ConditionsInRunBlock_funcmem_bld(&__edm__ConditionsInRunBlock_db_funcmem);
void __edm__ConditionsInRunBlock_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ConditionsInRunBlock"), typeid(::edm::ConditionsInRunBlock), sizeof(::edm::ConditionsInRunBlock), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ConditionsInRunBlock"), destructor_13354, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23216, type_23217), Reflex::Literal("operator="), operator_13355, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23217), Reflex::Literal("ConditionsInRunBlock"), constructor_13356, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ConditionsInRunBlock"), constructor_13357, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2994, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ConditionsInRunBlock_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ConditionsInRunBlock_funcmem_bld);
}

//------Delayed data member builder for class ConditionsInRunBlock -------------------
void __edm__ConditionsInRunBlock_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1247, Reflex::Literal("beamMode"), OffsetOf(__shadow__::__edm__ConditionsInRunBlock, beamMode), ::Reflex::PUBLIC)
  .AddDataMember(type_1247, Reflex::Literal("beamMomentum"), OffsetOf(__shadow__::__edm__ConditionsInRunBlock, beamMomentum), ::Reflex::PUBLIC)
  .AddDataMember(type_1078, Reflex::Literal("lhcFillNumber"), OffsetOf(__shadow__::__edm__ConditionsInRunBlock, lhcFillNumber), ::Reflex::PUBLIC)
  .AddDataMember(type_641, Reflex::Literal("BStartCurrent"), OffsetOf(__shadow__::__edm__ConditionsInRunBlock, BStartCurrent), ::Reflex::PUBLIC)
  .AddDataMember(type_641, Reflex::Literal("BStopCurrent"), OffsetOf(__shadow__::__edm__ConditionsInRunBlock, BStopCurrent), ::Reflex::PUBLIC)
  .AddDataMember(type_641, Reflex::Literal("BAvgCurrent"), OffsetOf(__shadow__::__edm__ConditionsInRunBlock, BAvgCurrent), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class ConditionsInRunBlock -------------------
void __edm__ConditionsInRunBlock_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_23217), Reflex::Literal("isProductEqual"), method_13358, 0, "newThing", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::ConditionsInRunBlock> -------------------------------
static void constructor_12808( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ConditionsInRunBlock>();
  else ::new(mem) ::edm::Wrapper<edm::ConditionsInRunBlock>();
}

static void constructor_12809( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ConditionsInRunBlock>(*(::std::auto_ptr<edm::ConditionsInRunBlock>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ConditionsInRunBlock>(*(::std::auto_ptr<edm::ConditionsInRunBlock>*)arg[0]);
}

static void destructor_12810(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->::edm::Wrapper<edm::ConditionsInRunBlock>::~Wrapper)();
}
static  void method_12811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->product)();
}

static  void operator_12812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->operator->)();
}

static  void method_12813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->productTypeInfo)();
}

static  void method_12814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->typeInfo)();
}

static void constructor_12815( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ConditionsInRunBlock>((::edm::ConditionsInRunBlock*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ConditionsInRunBlock>((::edm::ConditionsInRunBlock*)arg[0]);
}

static  void method_12816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->getInterface)();
}

static  void method_12817( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12818( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->dynamicTypeInfo)();
}

static  void method_12821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->isPresent)();
}

static  void method_12822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ConditionsInRunBlock>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2924( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInRunBlock> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInRunBlock> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInRunBlock> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInRunBlock> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInRunBlock> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ConditionsInRunBlock> -------------------------------
void __edm__Wrapper_edm__ConditionsInRunBlock__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ConditionsInRunBlock__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ConditionsInRunBlock__datamem_bld(&__edm__Wrapper_edm__ConditionsInRunBlock__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ConditionsInRunBlock__funcmem_bld(&__edm__Wrapper_edm__ConditionsInRunBlock__db_funcmem);
void __edm__Wrapper_edm__ConditionsInRunBlock__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ConditionsInRunBlock>"), typeid(::edm::Wrapper<edm::ConditionsInRunBlock>), sizeof(::edm::Wrapper<edm::ConditionsInRunBlock>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2994, Reflex::Literal("edm::Wrapper<edm::ConditionsInRunBlock>::value_type"))
  .AddTypedef(type_2994, Reflex::Literal("edm::Wrapper<edm::ConditionsInRunBlock>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12808, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2011), Reflex::Literal("Wrapper"), constructor_12809, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12810, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23012), Reflex::Literal("Wrapper"), constructor_12815, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2924, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ConditionsInRunBlock__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ConditionsInRunBlock__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ConditionsInRunBlock> -------------------
void __edm__Wrapper_edm__ConditionsInRunBlock__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ConditionsInRunBlock_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2994, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ConditionsInRunBlock_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ConditionsInRunBlock> -------------------
void __edm__Wrapper_edm__ConditionsInRunBlock__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23011), Reflex::Literal("product"), method_12811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23011), Reflex::Literal("operator->"), operator_12812, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12813, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12814, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23013), Reflex::Literal("getInterface"), method_12816, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12817, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12818, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12819, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12820, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12821, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ConditionsInLumiBlock -------------------------------
static void destructor_13500(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ConditionsInLumiBlock*)o)->::edm::ConditionsInLumiBlock::~ConditionsInLumiBlock)();
}
static  void operator_13501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ConditionsInLumiBlock*)o)->operator=)(*(const ::edm::ConditionsInLumiBlock*)arg[0]);
  else   (((::edm::ConditionsInLumiBlock*)o)->operator=)(*(const ::edm::ConditionsInLumiBlock*)arg[0]);
}

static void constructor_13502( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ConditionsInLumiBlock(*(const ::edm::ConditionsInLumiBlock*)arg[0]);
  else ::new(mem) ::edm::ConditionsInLumiBlock(*(const ::edm::ConditionsInLumiBlock*)arg[0]);
}

static void constructor_13503( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ConditionsInLumiBlock();
  else ::new(mem) ::edm::ConditionsInLumiBlock();
}

static  void method_13504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ConditionsInLumiBlock*)o)->isProductEqual)(*(const ::edm::ConditionsInLumiBlock*)arg[0]));
  else   (((const ::edm::ConditionsInLumiBlock*)o)->isProductEqual)(*(const ::edm::ConditionsInLumiBlock*)arg[0]);
}

static void method_newdel_3026( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInLumiBlock >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInLumiBlock >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInLumiBlock >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInLumiBlock >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ConditionsInLumiBlock >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ConditionsInLumiBlock -------------------------------
void __edm__ConditionsInLumiBlock_db_datamem(Reflex::Class*);
void __edm__ConditionsInLumiBlock_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ConditionsInLumiBlock_datamem_bld(&__edm__ConditionsInLumiBlock_db_datamem);
Reflex::GenreflexMemberBuilder __edm__ConditionsInLumiBlock_funcmem_bld(&__edm__ConditionsInLumiBlock_db_funcmem);
void __edm__ConditionsInLumiBlock_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ConditionsInLumiBlock"), typeid(::edm::ConditionsInLumiBlock), sizeof(::edm::ConditionsInLumiBlock), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ConditionsInLumiBlock"), destructor_13500, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23245, type_23246), Reflex::Literal("operator="), operator_13501, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23246), Reflex::Literal("ConditionsInLumiBlock"), constructor_13502, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ConditionsInLumiBlock"), constructor_13503, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3026, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ConditionsInLumiBlock_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ConditionsInLumiBlock_funcmem_bld);
}

//------Delayed data member builder for class ConditionsInLumiBlock -------------------
void __edm__ConditionsInLumiBlock_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1078, Reflex::Literal("totalIntensityBeam1"), OffsetOf(__shadow__::__edm__ConditionsInLumiBlock, totalIntensityBeam1), ::Reflex::PUBLIC)
  .AddDataMember(type_1078, Reflex::Literal("totalIntensityBeam2"), OffsetOf(__shadow__::__edm__ConditionsInLumiBlock, totalIntensityBeam2), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class ConditionsInLumiBlock -------------------
void __edm__ConditionsInLumiBlock_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_23246), Reflex::Literal("isProductEqual"), method_13504, 0, "newThing", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::ConditionsInLumiBlock> -------------------------------
static void constructor_12829( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ConditionsInLumiBlock>();
  else ::new(mem) ::edm::Wrapper<edm::ConditionsInLumiBlock>();
}

static void constructor_12830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ConditionsInLumiBlock>(*(::std::auto_ptr<edm::ConditionsInLumiBlock>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ConditionsInLumiBlock>(*(::std::auto_ptr<edm::ConditionsInLumiBlock>*)arg[0]);
}

static void destructor_12831(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->::edm::Wrapper<edm::ConditionsInLumiBlock>::~Wrapper)();
}
static  void method_12832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->product)();
}

static  void operator_12833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->operator->)();
}

static  void method_12834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->productTypeInfo)();
}

static  void method_12835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->typeInfo)();
}

static void constructor_12836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ConditionsInLumiBlock>((::edm::ConditionsInLumiBlock*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ConditionsInLumiBlock>((::edm::ConditionsInLumiBlock*)arg[0]);
}

static  void method_12837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->getInterface)();
}

static  void method_12838( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12839( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->dynamicTypeInfo)();
}

static  void method_12842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->isPresent)();
}

static  void method_12843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ConditionsInLumiBlock>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2925( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInLumiBlock> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInLumiBlock> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInLumiBlock> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInLumiBlock> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ConditionsInLumiBlock> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ConditionsInLumiBlock> -------------------------------
void __edm__Wrapper_edm__ConditionsInLumiBlock__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ConditionsInLumiBlock__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ConditionsInLumiBlock__datamem_bld(&__edm__Wrapper_edm__ConditionsInLumiBlock__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ConditionsInLumiBlock__funcmem_bld(&__edm__Wrapper_edm__ConditionsInLumiBlock__db_funcmem);
void __edm__Wrapper_edm__ConditionsInLumiBlock__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ConditionsInLumiBlock>"), typeid(::edm::Wrapper<edm::ConditionsInLumiBlock>), sizeof(::edm::Wrapper<edm::ConditionsInLumiBlock>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3026, Reflex::Literal("edm::Wrapper<edm::ConditionsInLumiBlock>::value_type"))
  .AddTypedef(type_3026, Reflex::Literal("edm::Wrapper<edm::ConditionsInLumiBlock>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12829, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2012), Reflex::Literal("Wrapper"), constructor_12830, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12831, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23017), Reflex::Literal("Wrapper"), constructor_12836, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2925, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ConditionsInLumiBlock__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ConditionsInLumiBlock__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ConditionsInLumiBlock> -------------------
void __edm__Wrapper_edm__ConditionsInLumiBlock__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ConditionsInLumiBlock_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3026, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ConditionsInLumiBlock_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ConditionsInLumiBlock> -------------------
void __edm__Wrapper_edm__ConditionsInLumiBlock__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23016), Reflex::Literal("product"), method_12832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23016), Reflex::Literal("operator->"), operator_12833, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12834, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12835, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23018), Reflex::Literal("getInterface"), method_12837, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12838, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12839, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12840, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class MergeableCounter -------------------------------
static  void operator_13665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::MergeableCounter*)o)->operator=)(*(const ::edm::MergeableCounter*)arg[0]);
  else   (((::edm::MergeableCounter*)o)->operator=)(*(const ::edm::MergeableCounter*)arg[0]);
}

static void constructor_13666( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::MergeableCounter(*(const ::edm::MergeableCounter*)arg[0]);
  else ::new(mem) ::edm::MergeableCounter(*(const ::edm::MergeableCounter*)arg[0]);
}

static void constructor_13667( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::MergeableCounter();
  else ::new(mem) ::edm::MergeableCounter();
}

static void destructor_13668(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::MergeableCounter*)o)->::edm::MergeableCounter::~MergeableCounter)();
}
static  void method_13669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::edm::MergeableCounter*)o)->mergeProduct)(*(const ::edm::MergeableCounter*)arg[0]));
  else   (((::edm::MergeableCounter*)o)->mergeProduct)(*(const ::edm::MergeableCounter*)arg[0]);
}

static void method_newdel_3062( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::MergeableCounter >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::MergeableCounter >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::MergeableCounter >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::MergeableCounter >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::MergeableCounter >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class MergeableCounter -------------------------------
void __edm__MergeableCounter_db_datamem(Reflex::Class*);
void __edm__MergeableCounter_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__MergeableCounter_datamem_bld(&__edm__MergeableCounter_db_datamem);
Reflex::GenreflexMemberBuilder __edm__MergeableCounter_funcmem_bld(&__edm__MergeableCounter_db_funcmem);
void __edm__MergeableCounter_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::MergeableCounter"), typeid(::edm::MergeableCounter), sizeof(::edm::MergeableCounter), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23294, type_23295), Reflex::Literal("operator="), operator_13665, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23295), Reflex::Literal("MergeableCounter"), constructor_13666, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MergeableCounter"), constructor_13667, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MergeableCounter"), destructor_13668, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3062, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__MergeableCounter_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__MergeableCounter_funcmem_bld);
}

//------Delayed data member builder for class MergeableCounter -------------------
void __edm__MergeableCounter_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_61, Reflex::Literal("value"), OffsetOf(__shadow__::__edm__MergeableCounter, value), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class MergeableCounter -------------------
void __edm__MergeableCounter_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_23295), Reflex::Literal("mergeProduct"), method_13669, 0, "newThing", ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<edm::MergeableCounter> -------------------------------
static void constructor_12850( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::MergeableCounter>();
  else ::new(mem) ::edm::Wrapper<edm::MergeableCounter>();
}

static void constructor_12851( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::MergeableCounter>(*(::std::auto_ptr<edm::MergeableCounter>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::MergeableCounter>(*(::std::auto_ptr<edm::MergeableCounter>*)arg[0]);
}

static void destructor_12852(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::MergeableCounter>*)o)->::edm::Wrapper<edm::MergeableCounter>::~Wrapper)();
}
static  void method_12853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::MergeableCounter>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::MergeableCounter>*)o)->product)();
}

static  void operator_12854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::MergeableCounter>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::MergeableCounter>*)o)->operator->)();
}

static  void method_12855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::MergeableCounter>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::MergeableCounter>*)o)->productTypeInfo)();
}

static  void method_12856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::MergeableCounter>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::MergeableCounter>*)o)->typeInfo)();
}

static void constructor_12857( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::MergeableCounter>((::edm::MergeableCounter*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::MergeableCounter>((::edm::MergeableCounter*)arg[0]);
}

static  void method_12858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::MergeableCounter>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::MergeableCounter>*)o)->getInterface)();
}

static  void method_12859( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::MergeableCounter>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12860( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::MergeableCounter>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12861( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::MergeableCounter>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::MergeableCounter>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::MergeableCounter>*)o)->dynamicTypeInfo)();
}

static  void method_12863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::MergeableCounter>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::MergeableCounter>*)o)->isPresent)();
}

static  void method_12864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::MergeableCounter>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::MergeableCounter>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2926( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::MergeableCounter> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::MergeableCounter> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::MergeableCounter> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::MergeableCounter> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::MergeableCounter> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::MergeableCounter> -------------------------------
void __edm__Wrapper_edm__MergeableCounter__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__MergeableCounter__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__MergeableCounter__datamem_bld(&__edm__Wrapper_edm__MergeableCounter__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__MergeableCounter__funcmem_bld(&__edm__Wrapper_edm__MergeableCounter__db_funcmem);
void __edm__Wrapper_edm__MergeableCounter__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::MergeableCounter>"), typeid(::edm::Wrapper<edm::MergeableCounter>), sizeof(::edm::Wrapper<edm::MergeableCounter>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3062, Reflex::Literal("edm::Wrapper<edm::MergeableCounter>::value_type"))
  .AddTypedef(type_3062, Reflex::Literal("edm::Wrapper<edm::MergeableCounter>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12850, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2013), Reflex::Literal("Wrapper"), constructor_12851, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12852, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23022), Reflex::Literal("Wrapper"), constructor_12857, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2926, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__MergeableCounter__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__MergeableCounter__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::MergeableCounter> -------------------
void __edm__Wrapper_edm__MergeableCounter__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__MergeableCounter_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3062, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__MergeableCounter_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::MergeableCounter> -------------------
void __edm__Wrapper_edm__MergeableCounter__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23021), Reflex::Literal("product"), method_12853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23021), Reflex::Literal("operator->"), operator_12854, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12855, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12856, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23023), Reflex::Literal("getInterface"), method_12858, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12859, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12860, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12861, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<edm::ErrorSummaryEntry, std::allocator<edm::ErrorSummaryEntry> > > -------------------------------
static void constructor_12871( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >();
  else ::new(mem) ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >();
}

static void constructor_12872( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >(*(::std::auto_ptr<std::vector<edm::ErrorSummaryEntry> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >(*(::std::auto_ptr<std::vector<edm::ErrorSummaryEntry> >*)arg[0]);
}

static void destructor_12873(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >::~Wrapper)();
}
static  void method_12874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->product)();
}

static  void operator_12875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->operator->)();
}

static  void method_12876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->productTypeInfo)();
}

static  void method_12877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->typeInfo)();
}

static void constructor_12878( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >((::std::vector<edm::ErrorSummaryEntry>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >((::std::vector<edm::ErrorSummaryEntry>*)arg[0]);
}

static  void method_12879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->getInterface)();
}

static  void method_12880( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12881( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->dynamicTypeInfo)();
}

static  void method_12884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->isPresent)();
}

static  void method_12885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2927( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<edm::ErrorSummaryEntry, std::allocator<edm::ErrorSummaryEntry> > > -------------------------------
void __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__datamem_bld(&__edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__funcmem_bld(&__edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__db_funcmem);
void __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >"), typeid(::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >), sizeof(::edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2279, Reflex::Literal("edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >::value_type"))
  .AddTypedef(type_2279, Reflex::Literal("edm::Wrapper<std::vector<edm::ErrorSummaryEntry> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12871, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2014), Reflex::Literal("Wrapper"), constructor_12872, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12873, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23027), Reflex::Literal("Wrapper"), constructor_12878, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2927, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<edm::ErrorSummaryEntry, std::allocator<edm::ErrorSummaryEntry> > > -------------------
void __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2279, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<edm::ErrorSummaryEntry, std::allocator<edm::ErrorSummaryEntry> > > -------------------
void __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23026), Reflex::Literal("product"), method_12874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23026), Reflex::Literal("operator->"), operator_12875, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12876, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12877, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23028), Reflex::Literal("getInterface"), method_12879, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12880, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12881, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12882, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<edm::EventAuxiliary, std::allocator<edm::EventAuxiliary> > > -------------------------------
static void constructor_12892( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::EventAuxiliary> >();
  else ::new(mem) ::edm::Wrapper<std::vector<edm::EventAuxiliary> >();
}

static void constructor_12893( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::EventAuxiliary> >(*(::std::auto_ptr<std::vector<edm::EventAuxiliary> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::EventAuxiliary> >(*(::std::auto_ptr<std::vector<edm::EventAuxiliary> >*)arg[0]);
}

static void destructor_12894(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->::edm::Wrapper<std::vector<edm::EventAuxiliary> >::~Wrapper)();
}
static  void method_12895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->product)();
}

static  void operator_12896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->operator->)();
}

static  void method_12897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->productTypeInfo)();
}

static  void method_12898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->typeInfo)();
}

static void constructor_12899( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::EventAuxiliary> >((::std::vector<edm::EventAuxiliary>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::EventAuxiliary> >((::std::vector<edm::EventAuxiliary>*)arg[0]);
}

static  void method_12900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->getInterface)();
}

static  void method_12901( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->dynamicTypeInfo)();
}

static  void method_12905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->isPresent)();
}

static  void method_12906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<edm::EventAuxiliary> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2928( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::EventAuxiliary> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::EventAuxiliary> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::EventAuxiliary> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::EventAuxiliary> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::EventAuxiliary> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<edm::EventAuxiliary, std::allocator<edm::EventAuxiliary> > > -------------------------------
void __edm__Wrapper_std__vector_edm__EventAuxiliary_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_edm__EventAuxiliary_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__EventAuxiliary_s__datamem_bld(&__edm__Wrapper_std__vector_edm__EventAuxiliary_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__EventAuxiliary_s__funcmem_bld(&__edm__Wrapper_std__vector_edm__EventAuxiliary_s__db_funcmem);
void __edm__Wrapper_std__vector_edm__EventAuxiliary_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::EventAuxiliary> >"), typeid(::edm::Wrapper<std::vector<edm::EventAuxiliary> >), sizeof(::edm::Wrapper<std::vector<edm::EventAuxiliary> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2280, Reflex::Literal("edm::Wrapper<std::vector<edm::EventAuxiliary> >::value_type"))
  .AddTypedef(type_2280, Reflex::Literal("edm::Wrapper<std::vector<edm::EventAuxiliary> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12892, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2015), Reflex::Literal("Wrapper"), constructor_12893, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12894, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23032), Reflex::Literal("Wrapper"), constructor_12899, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2928, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_edm__EventAuxiliary_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_edm__EventAuxiliary_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<edm::EventAuxiliary, std::allocator<edm::EventAuxiliary> > > -------------------
void __edm__Wrapper_std__vector_edm__EventAuxiliary_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__EventAuxiliary_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2280, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__EventAuxiliary_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<edm::EventAuxiliary, std::allocator<edm::EventAuxiliary> > > -------------------
void __edm__Wrapper_std__vector_edm__EventAuxiliary_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23031), Reflex::Literal("product"), method_12895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23031), Reflex::Literal("operator->"), operator_12896, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12897, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12898, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23033), Reflex::Literal("getInterface"), method_12900, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12901, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12902, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12903, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<double> -------------------------------
static void destructor_14082(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<double>*)o)->::edm::ValueMap<double>::~ValueMap)();
}
static void constructor_14083( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<double>(*(const ::edm::ValueMap<double>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<double>(*(const ::edm::ValueMap<double>*)arg[0]);
}

static void constructor_14084( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<double>();
  else ::new(mem) ::edm::ValueMap<double>();
}

static  void method_14085( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<double>*)o)->swap)(*(::edm::ValueMap<double>*)arg[0]);
}

static  void operator_14086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<double>*)o)->operator=)(*(const ::edm::ValueMap<double>*)arg[0]);
  else   (((::edm::ValueMap<double>*)o)->operator=)(*(const ::edm::ValueMap<double>*)arg[0]);
}

static  void method_14087( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<double>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<double>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<double>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<double>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<double>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<double>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_14090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<double>*)o)->operator+=)(*(const ::edm::ValueMap<double>*)arg[0]);
  else   (((::edm::ValueMap<double>*)o)->operator+=)(*(const ::edm::ValueMap<double>*)arg[0]);
}

static  void method_14091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<double>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<double>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_14092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<double>*)o)->size)());
  else   (((const ::edm::ValueMap<double>*)o)->size)();
}

static  void method_14093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<double>*)o)->idSize)());
  else   (((const ::edm::ValueMap<double>*)o)->idSize)();
}

static  void method_14094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<double>*)o)->empty)());
  else   (((const ::edm::ValueMap<double>*)o)->empty)();
}

static  void method_14095( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<double>*)o)->clear)();
}

static  void method_14096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<double>::const_iterator)((((const ::edm::ValueMap<double>*)o)->begin)());
  else   (((const ::edm::ValueMap<double>*)o)->begin)();
}

static  void method_14097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<double>::const_iterator)((((const ::edm::ValueMap<double>*)o)->end)());
  else   (((const ::edm::ValueMap<double>*)o)->end)();
}

static  void method_14098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<double>*)o)->ids)();
  else   (((const ::edm::ValueMap<double>*)o)->ids)();
}

static  void method_14099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<double>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<double>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_14100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<double>*)o)->Class_Version)());
  else   (((::edm::ValueMap<double>*)o)->Class_Version)();
}

static void method_newdel_3124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<double> -------------------------------
void __edm__ValueMap_double__db_datamem(Reflex::Class*);
void __edm__ValueMap_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_double__datamem_bld(&__edm__ValueMap_double__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_double__funcmem_bld(&__edm__ValueMap_double__db_funcmem);
void __edm__ValueMap_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<double>"), typeid(::edm::ValueMap<double>), sizeof(::edm::ValueMap<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<double>::Class_Version())
  .AddTypedef(type_1657, Reflex::Literal("edm::ValueMap<double>::value_type"))
  .AddTypedef(type_2282, Reflex::Literal("edm::ValueMap<double>::container"))
  .AddTypedef(type_235, Reflex::Literal("edm::ValueMap<double>::offset"))
  .AddTypedef(type_2281, Reflex::Literal("edm::ValueMap<double>::id_offset_vector"))
  .AddTypedef(type_8327, Reflex::Literal("edm::ValueMap<double>::reference_type"))
  .AddTypedef(type_8329, Reflex::Literal("edm::ValueMap<double>::const_reference_type"))
  .AddTypedef(type_13836, Reflex::Literal("edm::ValueMap<double>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_14082, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23336), Reflex::Literal("ValueMap"), constructor_14083, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_14084, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_double__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<double> -------------------
void __edm__ValueMap_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2282, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_double_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2281, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_double_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<double> -------------------
void __edm__ValueMap_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23337), Reflex::Literal("swap"), method_14085, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23337, type_23336), Reflex::Literal("operator="), operator_14086, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489, type_3052, type_1489), Reflex::Literal("rawIndexOf"), method_14087, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8329, type_3052, type_1489), Reflex::Literal("get"), method_14088, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8327, type_3052, type_1489), Reflex::Literal("get"), method_14089, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23337, type_23336), Reflex::Literal("operator+="), operator_14090, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_3052), Reflex::Literal("contains"), method_14091, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_14092, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("idSize"), method_14093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_14094, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_14095, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14080), Reflex::Literal("begin"), method_14096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14080), Reflex::Literal("end"), method_14097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22448), Reflex::Literal("ids"), method_14098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8329, type_1489), Reflex::Literal("get"), method_14099, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_14100, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<double> > -------------------------------
static void constructor_12913( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<double> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<double> >();
}

static void constructor_12914( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<double> >(*(::std::auto_ptr<edm::ValueMap<double> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<double> >(*(::std::auto_ptr<edm::ValueMap<double> >*)arg[0]);
}

static void destructor_12915(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<double> >*)o)->::edm::Wrapper<edm::ValueMap<double> >::~Wrapper)();
}
static  void method_12916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->product)();
}

static  void operator_12917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->operator->)();
}

static  void method_12918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<double> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<double> >*)o)->productTypeInfo)();
}

static  void method_12919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<double> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<double> >*)o)->typeInfo)();
}

static void constructor_12920( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<double> >((::edm::ValueMap<double>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<double> >((::edm::ValueMap<double>*)arg[0]);
}

static  void method_12921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<double> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<double> >*)o)->getInterface)();
}

static  void method_12922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12923( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->dynamicTypeInfo)();
}

static  void method_12926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->isPresent)();
}

static  void method_12927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<double> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2929( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<double> > -------------------------------
void __edm__Wrapper_edm__ValueMap_double_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_double_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_double_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_double_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<double> >"), typeid(::edm::Wrapper<edm::ValueMap<double> >), sizeof(::edm::Wrapper<edm::ValueMap<double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3124, Reflex::Literal("edm::Wrapper<edm::ValueMap<double> >::value_type"))
  .AddTypedef(type_3124, Reflex::Literal("edm::Wrapper<edm::ValueMap<double> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12913, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2016), Reflex::Literal("Wrapper"), constructor_12914, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12915, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23037), Reflex::Literal("Wrapper"), constructor_12920, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2929, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_double_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_double_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<double> > -------------------
void __edm__Wrapper_edm__ValueMap_double_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_double_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3124, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_double_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<double> > -------------------
void __edm__Wrapper_edm__ValueMap_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23036), Reflex::Literal("product"), method_12916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23036), Reflex::Literal("operator->"), operator_12917, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12918, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12919, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23038), Reflex::Literal("getInterface"), method_12921, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12922, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12923, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12924, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<float> -------------------------------
static void destructor_14116(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<float>*)o)->::edm::ValueMap<float>::~ValueMap)();
}
static void constructor_14117( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<float>(*(const ::edm::ValueMap<float>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<float>(*(const ::edm::ValueMap<float>*)arg[0]);
}

static void constructor_14118( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<float>();
  else ::new(mem) ::edm::ValueMap<float>();
}

static  void method_14119( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<float>*)o)->swap)(*(::edm::ValueMap<float>*)arg[0]);
}

static  void operator_14120( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<float>*)o)->operator=)(*(const ::edm::ValueMap<float>*)arg[0]);
  else   (((::edm::ValueMap<float>*)o)->operator=)(*(const ::edm::ValueMap<float>*)arg[0]);
}

static  void method_14121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<float>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<float>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<float>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<float>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<float>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<float>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_14124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<float>*)o)->operator+=)(*(const ::edm::ValueMap<float>*)arg[0]);
  else   (((::edm::ValueMap<float>*)o)->operator+=)(*(const ::edm::ValueMap<float>*)arg[0]);
}

static  void method_14125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<float>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<float>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_14126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<float>*)o)->size)());
  else   (((const ::edm::ValueMap<float>*)o)->size)();
}

static  void method_14127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<float>*)o)->idSize)());
  else   (((const ::edm::ValueMap<float>*)o)->idSize)();
}

static  void method_14128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<float>*)o)->empty)());
  else   (((const ::edm::ValueMap<float>*)o)->empty)();
}

static  void method_14129( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<float>*)o)->clear)();
}

static  void method_14130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<float>::const_iterator)((((const ::edm::ValueMap<float>*)o)->begin)());
  else   (((const ::edm::ValueMap<float>*)o)->begin)();
}

static  void method_14131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<float>::const_iterator)((((const ::edm::ValueMap<float>*)o)->end)());
  else   (((const ::edm::ValueMap<float>*)o)->end)();
}

static  void method_14132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<float>*)o)->ids)();
  else   (((const ::edm::ValueMap<float>*)o)->ids)();
}

static  void method_14133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<float>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<float>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_14134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<float>*)o)->Class_Version)());
  else   (((::edm::ValueMap<float>*)o)->Class_Version)();
}

static void method_newdel_3125( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<float> -------------------------------
void __edm__ValueMap_float__db_datamem(Reflex::Class*);
void __edm__ValueMap_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_float__datamem_bld(&__edm__ValueMap_float__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_float__funcmem_bld(&__edm__ValueMap_float__db_funcmem);
void __edm__ValueMap_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<float>"), typeid(::edm::ValueMap<float>), sizeof(::edm::ValueMap<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<float>::Class_Version())
  .AddTypedef(type_641, Reflex::Literal("edm::ValueMap<float>::value_type"))
  .AddTypedef(type_2283, Reflex::Literal("edm::ValueMap<float>::container"))
  .AddTypedef(type_235, Reflex::Literal("edm::ValueMap<float>::offset"))
  .AddTypedef(type_2281, Reflex::Literal("edm::ValueMap<float>::id_offset_vector"))
  .AddTypedef(type_8391, Reflex::Literal("edm::ValueMap<float>::reference_type"))
  .AddTypedef(type_8393, Reflex::Literal("edm::ValueMap<float>::const_reference_type"))
  .AddTypedef(type_13837, Reflex::Literal("edm::ValueMap<float>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_14116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23338), Reflex::Literal("ValueMap"), constructor_14117, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_14118, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_float__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<float> -------------------
void __edm__ValueMap_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2283, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_float_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2281, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_float_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<float> -------------------
void __edm__ValueMap_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23339), Reflex::Literal("swap"), method_14119, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23339, type_23338), Reflex::Literal("operator="), operator_14120, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489, type_3052, type_1489), Reflex::Literal("rawIndexOf"), method_14121, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8393, type_3052, type_1489), Reflex::Literal("get"), method_14122, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391, type_3052, type_1489), Reflex::Literal("get"), method_14123, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23339, type_23338), Reflex::Literal("operator+="), operator_14124, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_3052), Reflex::Literal("contains"), method_14125, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_14126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("idSize"), method_14127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_14128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_14129, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14114), Reflex::Literal("begin"), method_14130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14114), Reflex::Literal("end"), method_14131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22448), Reflex::Literal("ids"), method_14132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8393, type_1489), Reflex::Literal("get"), method_14133, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_14134, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<float> > -------------------------------
static void constructor_12934( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<float> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<float> >();
}

static void constructor_12935( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<float> >(*(::std::auto_ptr<edm::ValueMap<float> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<float> >(*(::std::auto_ptr<edm::ValueMap<float> >*)arg[0]);
}

static void destructor_12936(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<float> >*)o)->::edm::Wrapper<edm::ValueMap<float> >::~Wrapper)();
}
static  void method_12937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->product)();
}

static  void operator_12938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->operator->)();
}

static  void method_12939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<float> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<float> >*)o)->productTypeInfo)();
}

static  void method_12940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<float> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<float> >*)o)->typeInfo)();
}

static void constructor_12941( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<float> >((::edm::ValueMap<float>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<float> >((::edm::ValueMap<float>*)arg[0]);
}

static  void method_12942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<float> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<float> >*)o)->getInterface)();
}

static  void method_12943( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12944( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12945( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->dynamicTypeInfo)();
}

static  void method_12947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->isPresent)();
}

static  void method_12948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<float> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2930( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<float> > -------------------------------
void __edm__Wrapper_edm__ValueMap_float_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_float_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_float_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_float_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_float_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<float> >"), typeid(::edm::Wrapper<edm::ValueMap<float> >), sizeof(::edm::Wrapper<edm::ValueMap<float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3125, Reflex::Literal("edm::Wrapper<edm::ValueMap<float> >::value_type"))
  .AddTypedef(type_3125, Reflex::Literal("edm::Wrapper<edm::ValueMap<float> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12934, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2017), Reflex::Literal("Wrapper"), constructor_12935, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12936, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23042), Reflex::Literal("Wrapper"), constructor_12941, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2930, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_float_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_float_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<float> > -------------------
void __edm__Wrapper_edm__ValueMap_float_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_float_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3125, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_float_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<float> > -------------------
void __edm__Wrapper_edm__ValueMap_float_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23041), Reflex::Literal("product"), method_12937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23041), Reflex::Literal("operator->"), operator_12938, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12939, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12940, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23043), Reflex::Literal("getInterface"), method_12942, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12943, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12944, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12945, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<bool> -------------------------------
static void destructor_14150(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<bool>*)o)->::edm::ValueMap<bool>::~ValueMap)();
}
static void constructor_14151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<bool>(*(const ::edm::ValueMap<bool>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<bool>(*(const ::edm::ValueMap<bool>*)arg[0]);
}

static void constructor_14152( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<bool>();
  else ::new(mem) ::edm::ValueMap<bool>();
}

static  void method_14153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<bool>*)o)->swap)(*(::edm::ValueMap<bool>*)arg[0]);
}

static  void operator_14154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<bool>*)o)->operator=)(*(const ::edm::ValueMap<bool>*)arg[0]);
  else   (((::edm::ValueMap<bool>*)o)->operator=)(*(const ::edm::ValueMap<bool>*)arg[0]);
}

static  void method_14155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<bool>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<bool>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<bool>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<bool>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::edm::ValueMap<bool>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((::edm::ValueMap<bool>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_14158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<bool>*)o)->operator+=)(*(const ::edm::ValueMap<bool>*)arg[0]);
  else   (((::edm::ValueMap<bool>*)o)->operator+=)(*(const ::edm::ValueMap<bool>*)arg[0]);
}

static  void method_14159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<bool>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<bool>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_14160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<bool>*)o)->size)());
  else   (((const ::edm::ValueMap<bool>*)o)->size)();
}

static  void method_14161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<bool>*)o)->idSize)());
  else   (((const ::edm::ValueMap<bool>*)o)->idSize)();
}

static  void method_14162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<bool>*)o)->empty)());
  else   (((const ::edm::ValueMap<bool>*)o)->empty)();
}

static  void method_14163( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<bool>*)o)->clear)();
}

static  void method_14164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<bool>::const_iterator)((((const ::edm::ValueMap<bool>*)o)->begin)());
  else   (((const ::edm::ValueMap<bool>*)o)->begin)();
}

static  void method_14165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<bool>::const_iterator)((((const ::edm::ValueMap<bool>*)o)->end)());
  else   (((const ::edm::ValueMap<bool>*)o)->end)();
}

static  void method_14166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<bool>*)o)->ids)();
  else   (((const ::edm::ValueMap<bool>*)o)->ids)();
}

static  void method_14167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<bool>*)o)->get)(*(::size_t*)arg[0]));
  else   (((const ::edm::ValueMap<bool>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_14168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<bool>*)o)->Class_Version)());
  else   (((::edm::ValueMap<bool>*)o)->Class_Version)();
}

static void method_newdel_3126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<bool> -------------------------------
void __edm__ValueMap_bool__db_datamem(Reflex::Class*);
void __edm__ValueMap_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_bool__datamem_bld(&__edm__ValueMap_bool__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_bool__funcmem_bld(&__edm__ValueMap_bool__db_funcmem);
void __edm__ValueMap_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<bool>"), typeid(::edm::ValueMap<bool>), sizeof(::edm::ValueMap<bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<bool>::Class_Version())
  .AddTypedef(type_2811, Reflex::Literal("edm::ValueMap<bool>::value_type"))
  .AddTypedef(type_2284, Reflex::Literal("edm::ValueMap<bool>::container"))
  .AddTypedef(type_235, Reflex::Literal("edm::ValueMap<bool>::offset"))
  .AddTypedef(type_2281, Reflex::Literal("edm::ValueMap<bool>::id_offset_vector"))
  .AddTypedef(type_2374, Reflex::Literal("edm::ValueMap<bool>::reference_type"))
  .AddTypedef(type_2811, Reflex::Literal("edm::ValueMap<bool>::const_reference_type"))
  .AddTypedef(type_13838, Reflex::Literal("edm::ValueMap<bool>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_14150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23340), Reflex::Literal("ValueMap"), constructor_14151, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_14152, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_bool__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_bool__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<bool> -------------------
void __edm__ValueMap_bool__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2284, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_bool_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2281, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_bool_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<bool> -------------------
void __edm__ValueMap_bool__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23341), Reflex::Literal("swap"), method_14153, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23341, type_23340), Reflex::Literal("operator="), operator_14154, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489, type_3052, type_1489), Reflex::Literal("rawIndexOf"), method_14155, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_3052, type_1489), Reflex::Literal("get"), method_14156, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2374, type_3052, type_1489), Reflex::Literal("get"), method_14157, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23341, type_23340), Reflex::Literal("operator+="), operator_14158, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_3052), Reflex::Literal("contains"), method_14159, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_14160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("idSize"), method_14161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_14162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_14163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14148), Reflex::Literal("begin"), method_14164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14148), Reflex::Literal("end"), method_14165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22448), Reflex::Literal("ids"), method_14166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_1489), Reflex::Literal("get"), method_14167, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_14168, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<bool> > -------------------------------
static void constructor_12955( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<bool> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<bool> >();
}

static void constructor_12956( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<bool> >(*(::std::auto_ptr<edm::ValueMap<bool> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<bool> >(*(::std::auto_ptr<edm::ValueMap<bool> >*)arg[0]);
}

static void destructor_12957(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<bool> >*)o)->::edm::Wrapper<edm::ValueMap<bool> >::~Wrapper)();
}
static  void method_12958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->product)();
}

static  void operator_12959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->operator->)();
}

static  void method_12960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<bool> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<bool> >*)o)->productTypeInfo)();
}

static  void method_12961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<bool> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<bool> >*)o)->typeInfo)();
}

static void constructor_12962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<bool> >((::edm::ValueMap<bool>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<bool> >((::edm::ValueMap<bool>*)arg[0]);
}

static  void method_12963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<bool> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<bool> >*)o)->getInterface)();
}

static  void method_12964( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12965( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->dynamicTypeInfo)();
}

static  void method_12968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->isPresent)();
}

static  void method_12969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<bool> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2931( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<bool> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<bool> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<bool> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<bool> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<bool> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<bool> > -------------------------------
void __edm__Wrapper_edm__ValueMap_bool_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_bool_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_bool_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_bool_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_bool_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_bool_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_bool_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<bool> >"), typeid(::edm::Wrapper<edm::ValueMap<bool> >), sizeof(::edm::Wrapper<edm::ValueMap<bool> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3126, Reflex::Literal("edm::Wrapper<edm::ValueMap<bool> >::value_type"))
  .AddTypedef(type_3126, Reflex::Literal("edm::Wrapper<edm::ValueMap<bool> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12955, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2018), Reflex::Literal("Wrapper"), constructor_12956, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12957, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23047), Reflex::Literal("Wrapper"), constructor_12962, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2931, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_bool_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_bool_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<bool> > -------------------
void __edm__Wrapper_edm__ValueMap_bool_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_bool_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3126, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_bool_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<bool> > -------------------
void __edm__Wrapper_edm__ValueMap_bool_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23046), Reflex::Literal("product"), method_12958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23046), Reflex::Literal("operator->"), operator_12959, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12960, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12961, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23048), Reflex::Literal("getInterface"), method_12963, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12964, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12965, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12966, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<unsigned int> -------------------------------
static void destructor_14184(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<unsigned int>*)o)->::edm::ValueMap<unsigned int>::~ValueMap)();
}
static void constructor_14185( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<unsigned int>(*(const ::edm::ValueMap<unsigned int>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<unsigned int>(*(const ::edm::ValueMap<unsigned int>*)arg[0]);
}

static void constructor_14186( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<unsigned int>();
  else ::new(mem) ::edm::ValueMap<unsigned int>();
}

static  void method_14187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<unsigned int>*)o)->swap)(*(::edm::ValueMap<unsigned int>*)arg[0]);
}

static  void operator_14188( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<unsigned int>*)o)->operator=)(*(const ::edm::ValueMap<unsigned int>*)arg[0]);
  else   (((::edm::ValueMap<unsigned int>*)o)->operator=)(*(const ::edm::ValueMap<unsigned int>*)arg[0]);
}

static  void method_14189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<unsigned int>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<unsigned int>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<unsigned int>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<unsigned int>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<unsigned int>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<unsigned int>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_14192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<unsigned int>*)o)->operator+=)(*(const ::edm::ValueMap<unsigned int>*)arg[0]);
  else   (((::edm::ValueMap<unsigned int>*)o)->operator+=)(*(const ::edm::ValueMap<unsigned int>*)arg[0]);
}

static  void method_14193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<unsigned int>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<unsigned int>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_14194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<unsigned int>*)o)->size)());
  else   (((const ::edm::ValueMap<unsigned int>*)o)->size)();
}

static  void method_14195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<unsigned int>*)o)->idSize)());
  else   (((const ::edm::ValueMap<unsigned int>*)o)->idSize)();
}

static  void method_14196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<unsigned int>*)o)->empty)());
  else   (((const ::edm::ValueMap<unsigned int>*)o)->empty)();
}

static  void method_14197( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<unsigned int>*)o)->clear)();
}

static  void method_14198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<unsigned int>::const_iterator)((((const ::edm::ValueMap<unsigned int>*)o)->begin)());
  else   (((const ::edm::ValueMap<unsigned int>*)o)->begin)();
}

static  void method_14199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<unsigned int>::const_iterator)((((const ::edm::ValueMap<unsigned int>*)o)->end)());
  else   (((const ::edm::ValueMap<unsigned int>*)o)->end)();
}

static  void method_14200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<unsigned int>*)o)->ids)();
  else   (((const ::edm::ValueMap<unsigned int>*)o)->ids)();
}

static  void method_14201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<unsigned int>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<unsigned int>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_14202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<unsigned int>*)o)->Class_Version)());
  else   (((::edm::ValueMap<unsigned int>*)o)->Class_Version)();
}

static void method_newdel_3127( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<unsigned int> -------------------------------
void __edm__ValueMap_unsignedsint__db_datamem(Reflex::Class*);
void __edm__ValueMap_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_unsignedsint__datamem_bld(&__edm__ValueMap_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_unsignedsint__funcmem_bld(&__edm__ValueMap_unsignedsint__db_funcmem);
void __edm__ValueMap_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<unsigned int>"), typeid(::edm::ValueMap<unsigned int>), sizeof(::edm::ValueMap<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<unsigned int>::Class_Version())
  .AddTypedef(type_235, Reflex::Literal("edm::ValueMap<unsigned int>::value_type"))
  .AddTypedef(type_2285, Reflex::Literal("edm::ValueMap<unsigned int>::container"))
  .AddTypedef(type_235, Reflex::Literal("edm::ValueMap<unsigned int>::offset"))
  .AddTypedef(type_2281, Reflex::Literal("edm::ValueMap<unsigned int>::id_offset_vector"))
  .AddTypedef(type_5064, Reflex::Literal("edm::ValueMap<unsigned int>::reference_type"))
  .AddTypedef(type_5054, Reflex::Literal("edm::ValueMap<unsigned int>::const_reference_type"))
  .AddTypedef(type_13839, Reflex::Literal("edm::ValueMap<unsigned int>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_14184, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23342), Reflex::Literal("ValueMap"), constructor_14185, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_14186, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3127, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<unsigned int> -------------------
void __edm__ValueMap_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2285, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_unsignedsint_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2281, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_unsignedsint_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<unsigned int> -------------------
void __edm__ValueMap_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23343), Reflex::Literal("swap"), method_14187, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23343, type_23342), Reflex::Literal("operator="), operator_14188, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489, type_3052, type_1489), Reflex::Literal("rawIndexOf"), method_14189, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5054, type_3052, type_1489), Reflex::Literal("get"), method_14190, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5064, type_3052, type_1489), Reflex::Literal("get"), method_14191, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23343, type_23342), Reflex::Literal("operator+="), operator_14192, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_3052), Reflex::Literal("contains"), method_14193, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_14194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("idSize"), method_14195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_14196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_14197, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14182), Reflex::Literal("begin"), method_14198, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14182), Reflex::Literal("end"), method_14199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22448), Reflex::Literal("ids"), method_14200, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5054, type_1489), Reflex::Literal("get"), method_14201, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_14202, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<unsigned int> > -------------------------------
static void constructor_12976( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<unsigned int> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<unsigned int> >();
}

static void constructor_12977( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<unsigned int> >(*(::std::auto_ptr<edm::ValueMap<unsigned int> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<unsigned int> >(*(::std::auto_ptr<edm::ValueMap<unsigned int> >*)arg[0]);
}

static void destructor_12978(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->::edm::Wrapper<edm::ValueMap<unsigned int> >::~Wrapper)();
}
static  void method_12979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->product)();
}

static  void operator_12980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->operator->)();
}

static  void method_12981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->productTypeInfo)();
}

static  void method_12982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->typeInfo)();
}

static void constructor_12983( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<unsigned int> >((::edm::ValueMap<unsigned int>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<unsigned int> >((::edm::ValueMap<unsigned int>*)arg[0]);
}

static  void method_12984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->getInterface)();
}

static  void method_12985( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_12986( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_12987( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_12988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->dynamicTypeInfo)();
}

static  void method_12989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->isPresent)();
}

static  void method_12990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<unsigned int> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2932( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<unsigned int> > -------------------------------
void __edm__Wrapper_edm__ValueMap_unsignedsint_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_unsignedsint_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_unsignedsint_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_unsignedsint_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<unsigned int> >"), typeid(::edm::Wrapper<edm::ValueMap<unsigned int> >), sizeof(::edm::Wrapper<edm::ValueMap<unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3127, Reflex::Literal("edm::Wrapper<edm::ValueMap<unsigned int> >::value_type"))
  .AddTypedef(type_3127, Reflex::Literal("edm::Wrapper<edm::ValueMap<unsigned int> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12976, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2019), Reflex::Literal("Wrapper"), constructor_12977, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12978, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23052), Reflex::Literal("Wrapper"), constructor_12983, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2932, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<unsigned int> > -------------------
void __edm__Wrapper_edm__ValueMap_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_unsignedsint_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3127, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_unsignedsint_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<unsigned int> > -------------------
void __edm__Wrapper_edm__ValueMap_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23051), Reflex::Literal("product"), method_12979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23051), Reflex::Literal("operator->"), operator_12980, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_12981, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_12982, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23053), Reflex::Literal("getInterface"), method_12984, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_12985, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_12986, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_12987, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_12988, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_12989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_12990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<int> -------------------------------
static void destructor_14218(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<int>*)o)->::edm::ValueMap<int>::~ValueMap)();
}
static void constructor_14219( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<int>(*(const ::edm::ValueMap<int>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<int>(*(const ::edm::ValueMap<int>*)arg[0]);
}

static void constructor_14220( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<int>();
  else ::new(mem) ::edm::ValueMap<int>();
}

static  void method_14221( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<int>*)o)->swap)(*(::edm::ValueMap<int>*)arg[0]);
}

static  void operator_14222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<int>*)o)->operator=)(*(const ::edm::ValueMap<int>*)arg[0]);
  else   (((::edm::ValueMap<int>*)o)->operator=)(*(const ::edm::ValueMap<int>*)arg[0]);
}

static  void method_14223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<int>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<int>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14224( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<int>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<int>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<int>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<int>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_14226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<int>*)o)->operator+=)(*(const ::edm::ValueMap<int>*)arg[0]);
  else   (((::edm::ValueMap<int>*)o)->operator+=)(*(const ::edm::ValueMap<int>*)arg[0]);
}

static  void method_14227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<int>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<int>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_14228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<int>*)o)->size)());
  else   (((const ::edm::ValueMap<int>*)o)->size)();
}

static  void method_14229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<int>*)o)->idSize)());
  else   (((const ::edm::ValueMap<int>*)o)->idSize)();
}

static  void method_14230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<int>*)o)->empty)());
  else   (((const ::edm::ValueMap<int>*)o)->empty)();
}

static  void method_14231( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<int>*)o)->clear)();
}

static  void method_14232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<int>::const_iterator)((((const ::edm::ValueMap<int>*)o)->begin)());
  else   (((const ::edm::ValueMap<int>*)o)->begin)();
}

static  void method_14233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<int>::const_iterator)((((const ::edm::ValueMap<int>*)o)->end)());
  else   (((const ::edm::ValueMap<int>*)o)->end)();
}

static  void method_14234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<int>*)o)->ids)();
  else   (((const ::edm::ValueMap<int>*)o)->ids)();
}

static  void method_14235( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<int>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<int>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_14236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<int>*)o)->Class_Version)());
  else   (((::edm::ValueMap<int>*)o)->Class_Version)();
}

static void method_newdel_3128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<int> -------------------------------
void __edm__ValueMap_int__db_datamem(Reflex::Class*);
void __edm__ValueMap_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_int__datamem_bld(&__edm__ValueMap_int__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_int__funcmem_bld(&__edm__ValueMap_int__db_funcmem);
void __edm__ValueMap_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<int>"), typeid(::edm::ValueMap<int>), sizeof(::edm::ValueMap<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<int>::Class_Version())
  .AddTypedef(type_61, Reflex::Literal("edm::ValueMap<int>::value_type"))
  .AddTypedef(type_2286, Reflex::Literal("edm::ValueMap<int>::container"))
  .AddTypedef(type_235, Reflex::Literal("edm::ValueMap<int>::offset"))
  .AddTypedef(type_2281, Reflex::Literal("edm::ValueMap<int>::id_offset_vector"))
  .AddTypedef(type_8577, Reflex::Literal("edm::ValueMap<int>::reference_type"))
  .AddTypedef(type_5032, Reflex::Literal("edm::ValueMap<int>::const_reference_type"))
  .AddTypedef(type_13840, Reflex::Literal("edm::ValueMap<int>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_14218, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23344), Reflex::Literal("ValueMap"), constructor_14219, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_14220, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_int__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<int> -------------------
void __edm__ValueMap_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2286, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_int_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2281, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_int_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<int> -------------------
void __edm__ValueMap_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23345), Reflex::Literal("swap"), method_14221, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23345, type_23344), Reflex::Literal("operator="), operator_14222, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489, type_3052, type_1489), Reflex::Literal("rawIndexOf"), method_14223, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5032, type_3052, type_1489), Reflex::Literal("get"), method_14224, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8577, type_3052, type_1489), Reflex::Literal("get"), method_14225, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23345, type_23344), Reflex::Literal("operator+="), operator_14226, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_3052), Reflex::Literal("contains"), method_14227, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_14228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("idSize"), method_14229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_14230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_14231, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14216), Reflex::Literal("begin"), method_14232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14216), Reflex::Literal("end"), method_14233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22448), Reflex::Literal("ids"), method_14234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5032, type_1489), Reflex::Literal("get"), method_14235, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_14236, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<int> > -------------------------------
static void constructor_12997( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<int> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<int> >();
}

static void constructor_12998( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<int> >(*(::std::auto_ptr<edm::ValueMap<int> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<int> >(*(::std::auto_ptr<edm::ValueMap<int> >*)arg[0]);
}

static void destructor_12999(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<int> >*)o)->::edm::Wrapper<edm::ValueMap<int> >::~Wrapper)();
}
static  void method_13000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->product)();
}

static  void operator_13001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->operator->)();
}

static  void method_13002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<int> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<int> >*)o)->productTypeInfo)();
}

static  void method_13003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<int> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<int> >*)o)->typeInfo)();
}

static void constructor_13004( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<int> >((::edm::ValueMap<int>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<int> >((::edm::ValueMap<int>*)arg[0]);
}

static  void method_13005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<int> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<int> >*)o)->getInterface)();
}

static  void method_13006( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13007( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13008( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->dynamicTypeInfo)();
}

static  void method_13010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->isPresent)();
}

static  void method_13011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<int> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2933( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<int> > -------------------------------
void __edm__Wrapper_edm__ValueMap_int_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_int_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_int_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_int_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<int> >"), typeid(::edm::Wrapper<edm::ValueMap<int> >), sizeof(::edm::Wrapper<edm::ValueMap<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3128, Reflex::Literal("edm::Wrapper<edm::ValueMap<int> >::value_type"))
  .AddTypedef(type_3128, Reflex::Literal("edm::Wrapper<edm::ValueMap<int> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_12997, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2020), Reflex::Literal("Wrapper"), constructor_12998, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_12999, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23057), Reflex::Literal("Wrapper"), constructor_13004, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2933, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_int_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<int> > -------------------
void __edm__Wrapper_edm__ValueMap_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_int_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3128, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_int_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<int> > -------------------
void __edm__Wrapper_edm__ValueMap_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23056), Reflex::Literal("product"), method_13000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23056), Reflex::Literal("operator->"), operator_13001, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_13002, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_13003, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23058), Reflex::Literal("getInterface"), method_13005, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_13006, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_13007, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_13008, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_13009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_13010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_13011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::PtrVector<int> > -------------------------------
static void constructor_13018( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::PtrVector<int> >();
  else ::new(mem) ::edm::Wrapper<edm::PtrVector<int> >();
}

static void constructor_13019( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::PtrVector<int> >(*(::std::auto_ptr<edm::PtrVector<int> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::PtrVector<int> >(*(::std::auto_ptr<edm::PtrVector<int> >*)arg[0]);
}

static void destructor_13020(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::PtrVector<int> >*)o)->::edm::Wrapper<edm::PtrVector<int> >::~Wrapper)();
}
static  void method_13021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->product)();
}

static  void operator_13022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->operator->)();
}

static  void method_13023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::PtrVector<int> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::PtrVector<int> >*)o)->productTypeInfo)();
}

static  void method_13024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::PtrVector<int> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::PtrVector<int> >*)o)->typeInfo)();
}

static void constructor_13025( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::PtrVector<int> >((::edm::PtrVector<int>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::PtrVector<int> >((::edm::PtrVector<int>*)arg[0]);
}

static  void method_13026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::PtrVector<int> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::PtrVector<int> >*)o)->getInterface)();
}

static  void method_13027( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13028( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->dynamicTypeInfo)();
}

static  void method_13031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->isPresent)();
}

static  void method_13032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::PtrVector<int> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2934( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::PtrVector<int> > -------------------------------
void __edm__Wrapper_edm__PtrVector_int_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__PtrVector_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__PtrVector_int_s__datamem_bld(&__edm__Wrapper_edm__PtrVector_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__PtrVector_int_s__funcmem_bld(&__edm__Wrapper_edm__PtrVector_int_s__db_funcmem);
void __edm__Wrapper_edm__PtrVector_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::PtrVector<int> >"), typeid(::edm::Wrapper<edm::PtrVector<int> >), sizeof(::edm::Wrapper<edm::PtrVector<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_2907, Reflex::Literal("edm::Wrapper<edm::PtrVector<int> >::value_type"))
  .AddTypedef(type_2907, Reflex::Literal("edm::Wrapper<edm::PtrVector<int> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13018, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2022), Reflex::Literal("Wrapper"), constructor_13019, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13020, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23062), Reflex::Literal("Wrapper"), constructor_13025, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2934, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__PtrVector_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__PtrVector_int_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::PtrVector<int> > -------------------
void __edm__Wrapper_edm__PtrVector_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__PtrVector_int_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2907, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__PtrVector_int_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::PtrVector<int> > -------------------
void __edm__Wrapper_edm__PtrVector_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23061), Reflex::Literal("product"), method_13021, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23061), Reflex::Literal("operator->"), operator_13022, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_13023, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_13024, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23063), Reflex::Literal("getInterface"), method_13026, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_13027, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_13028, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_13029, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_13030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_13031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_13032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefToBaseVector<int> -------------------------------
static void constructor_13304( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBaseVector<int>();
  else ::new(mem) ::edm::RefToBaseVector<int>();
}

static void constructor_13305( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBaseVector<int>(*(const ::edm::RefToBaseVector<int>*)arg[0]);
  else ::new(mem) ::edm::RefToBaseVector<int>(*(const ::edm::RefToBaseVector<int>*)arg[0]);
}

static void constructor_13306( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBaseVector<int>(*(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[0]);
  else ::new(mem) ::edm::RefToBaseVector<int>(*(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[0]);
}

static  void operator_13307( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefToBaseVector<int>*)o)->operator=)(*(const ::edm::RefToBaseVector<int>*)arg[0]);
  else   (((::edm::RefToBaseVector<int>*)o)->operator=)(*(const ::edm::RefToBaseVector<int>*)arg[0]);
}

static  void method_13308( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefToBaseVector<int>*)o)->swap)(*(::edm::RefToBaseVector<int>*)arg[0]);
}

static void destructor_13309(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefToBaseVector<int>*)o)->::edm::RefToBaseVector<int>::~RefToBaseVector)();
}
static  void method_13310( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefToBaseVector<int>*)o)->clear)();
}

static  void method_13311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<int>)((((const ::edm::RefToBaseVector<int>*)o)->at)(*(::size_t*)arg[0]));
  else   (((const ::edm::RefToBaseVector<int>*)o)->at)(*(::size_t*)arg[0]);
}

static  void operator_13312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<int>)((((const ::edm::RefToBaseVector<int>*)o)->operator[])(*(::size_t*)arg[0]));
  else   (((const ::edm::RefToBaseVector<int>*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_13313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<int>*)o)->isValid)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->isValid)();
}

static  void method_13314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<int>*)o)->isInvalid)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->isInvalid)();
}

static  void method_13315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<int>*)o)->empty)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->empty)();
}

static  void method_13316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::RefToBaseVector<int>*)o)->size)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->size)();
}

static  void method_13317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefToBaseVector<int>*)o)->id)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->id)();
}

static  void method_13318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBaseVector<int>*)o)->productGetter)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->productGetter)();
}

static  void method_13319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<int>::const_iterator)((((const ::edm::RefToBaseVector<int>*)o)->begin)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->begin)();
}

static  void method_13320( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<int>::const_iterator)((((const ::edm::RefToBaseVector<int>*)o)->end)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->end)();
}

static  void method_13321( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefToBaseVector<int>*)o)->push_back)(*(const ::edm::RefToBase<int>*)arg[0]);
}

static  void method_13322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefToBaseVector<int>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_13323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::RefToBaseVector<int>*)o)->vectorHolder)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->vectorHolder)();
}

static  void method_13324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBaseVector<int>*)o)->product)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->product)();
}

static  void method_13325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBaseVector<int>*)o)->isAvailable)());
  else   (((const ::edm::RefToBaseVector<int>*)o)->isAvailable)();
}

static  void method_13326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefToBaseVector<int>*)o)->Class_Version)());
  else   (((::edm::RefToBaseVector<int>*)o)->Class_Version)();
}

static void method_newdel_2985( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefToBaseVector<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefToBaseVector<int> -------------------------------
void __edm__RefToBaseVector_int__db_datamem(Reflex::Class*);
void __edm__RefToBaseVector_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefToBaseVector_int__datamem_bld(&__edm__RefToBaseVector_int__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefToBaseVector_int__funcmem_bld(&__edm__RefToBaseVector_int__db_funcmem);
void __edm__RefToBaseVector_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefToBaseVector<int>"), typeid(::edm::RefToBaseVector<int>), sizeof(::edm::RefToBaseVector<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefToBaseVector<int>::Class_Version())
  .AddTypedef(type_3079, Reflex::Literal("edm::RefToBaseVector<int>::value_type"))
  .AddTypedef(type_61, Reflex::Literal("edm::RefToBaseVector<int>::member_type"))
  .AddTypedef(type_13239, Reflex::Literal("edm::RefToBaseVector<int>::holder_type"))
  .AddTypedef(type_1489, Reflex::Literal("edm::RefToBaseVector<int>::size_type"))
  .AddTypedef(type_13302, Reflex::Literal("edm::RefToBaseVector<int>::const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefToBaseVector"), constructor_13304, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23212), Reflex::Literal("RefToBaseVector"), constructor_13305, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3093), Reflex::Literal("RefToBaseVector"), constructor_13306, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefToBaseVector"), destructor_13309, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2985, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefToBaseVector_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefToBaseVector_int__funcmem_bld);
}

//------Delayed data member builder for class RefToBaseVector<int> -------------------
void __edm__RefToBaseVector_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_23211, Reflex::Literal("holder_"), OffsetOf(__shadow__::__edm__RefToBaseVector_int_, holder_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefToBaseVector<int> -------------------
void __edm__RefToBaseVector_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23213, type_23212), Reflex::Literal("operator="), operator_13307, 0, "iRHS", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23213), Reflex::Literal("swap"), method_13308, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_13310, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3079, type_1489), Reflex::Literal("at"), method_13311, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3079, type_1489), Reflex::Literal("operator[]"), operator_13312, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isValid"), method_13313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isInvalid"), method_13314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_13315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_13316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_13317, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_13318, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13302), Reflex::Literal("begin"), method_13319, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13302), Reflex::Literal("end"), method_13320, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23214), Reflex::Literal("push_back"), method_13321, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_22439), Reflex::Literal("fillView"), method_13322, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("vectorHolder"), method_13323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("product"), method_13324, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_13325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_13326, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::RefToBaseVector<int> > -------------------------------
static void constructor_13039( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<int> >();
  else ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<int> >();
}

static void constructor_13040( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<int> >(*(::std::auto_ptr<edm::RefToBaseVector<int> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<int> >(*(::std::auto_ptr<edm::RefToBaseVector<int> >*)arg[0]);
}

static void destructor_13041(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->::edm::Wrapper<edm::RefToBaseVector<int> >::~Wrapper)();
}
static  void method_13042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->product)();
}

static  void operator_13043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->operator->)();
}

static  void method_13044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->productTypeInfo)();
}

static  void method_13045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->typeInfo)();
}

static void constructor_13046( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<int> >((::edm::RefToBaseVector<int>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefToBaseVector<int> >((::edm::RefToBaseVector<int>*)arg[0]);
}

static  void method_13047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->getInterface)();
}

static  void method_13048( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13049( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->dynamicTypeInfo)();
}

static  void method_13052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->isPresent)();
}

static  void method_13053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefToBaseVector<int> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2935( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefToBaseVector<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefToBaseVector<int> > -------------------------------
void __edm__Wrapper_edm__RefToBaseVector_int_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefToBaseVector_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefToBaseVector_int_s__datamem_bld(&__edm__Wrapper_edm__RefToBaseVector_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefToBaseVector_int_s__funcmem_bld(&__edm__Wrapper_edm__RefToBaseVector_int_s__db_funcmem);
void __edm__Wrapper_edm__RefToBaseVector_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<int> >"), typeid(::edm::Wrapper<edm::RefToBaseVector<int> >), sizeof(::edm::Wrapper<edm::RefToBaseVector<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_2985, Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<int> >::value_type"))
  .AddTypedef(type_2985, Reflex::Literal("edm::Wrapper<edm::RefToBaseVector<int> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13039, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2023), Reflex::Literal("Wrapper"), constructor_13040, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13041, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23067), Reflex::Literal("Wrapper"), constructor_13046, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2935, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefToBaseVector_int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefToBaseVector_int_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefToBaseVector<int> > -------------------
void __edm__Wrapper_edm__RefToBaseVector_int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefToBaseVector_int_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2985, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefToBaseVector_int_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefToBaseVector<int> > -------------------
void __edm__Wrapper_edm__RefToBaseVector_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23066), Reflex::Literal("product"), method_13042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23066), Reflex::Literal("operator->"), operator_13043, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_13044, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_13045, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23068), Reflex::Literal("getInterface"), method_13047, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_13048, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_13049, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_13050, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_13051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_13052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_13053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::RefVector<std::vector<int, std::allocator<int> >, int, edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > > -------------------------------
static void constructor_13060( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >();
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >();
}

static void constructor_13061( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >(*(::std::auto_ptr<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >(*(::std::auto_ptr<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)arg[0]);
}

static void destructor_13062(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::~Wrapper)();
}
static  void method_13063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->product)();
}

static  void operator_13064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->operator->)();
}

static  void method_13065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->productTypeInfo)();
}

static  void method_13066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->typeInfo)();
}

static void constructor_13067( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >((::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
}

static  void method_13068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->getInterface)();
}

static  void method_13069( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13070( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13071( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->dynamicTypeInfo)();
}

static  void method_13073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->isPresent)();
}

static  void method_13074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2936( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::RefVector<std::vector<int, std::allocator<int> >, int, edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > > -------------------------------
void __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__datamem_bld(&__edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__funcmem_bld(&__edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_funcmem);
void __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >"), typeid(::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >), sizeof(::edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_2918, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::value_type"))
  .AddTypedef(type_2918, Reflex::Literal("edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13060, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2024), Reflex::Literal("Wrapper"), constructor_13061, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13062, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23072), Reflex::Literal("Wrapper"), constructor_13067, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2936, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::RefVector<std::vector<int, std::allocator<int> >, int, edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2918, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::RefVector<std::vector<int, std::allocator<int> >, int, edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > > -------------------
void __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23071), Reflex::Literal("product"), method_13063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23071), Reflex::Literal("operator->"), operator_13064, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_13065, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_13066, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23073), Reflex::Literal("getInterface"), method_13068, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_13069, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_13070, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_13071, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_13072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_13073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_13074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TriggerResults -------------------------------
static void destructor_13961(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::TriggerResults*)o)->::edm::TriggerResults::~TriggerResults)();
}
static void constructor_13962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::TriggerResults(*(const ::edm::TriggerResults*)arg[0]);
  else ::new(mem) ::edm::TriggerResults(*(const ::edm::TriggerResults*)arg[0]);
}

static void constructor_13963( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::TriggerResults();
  else ::new(mem) ::edm::TriggerResults();
}

static void constructor_13964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::TriggerResults(*(const ::edm::HLTGlobalStatus*)arg[0],
      *(const ::edm::ParameterSetID*)arg[1]);
  else ::new(mem) ::edm::TriggerResults(*(const ::edm::HLTGlobalStatus*)arg[0],
      *(const ::edm::ParameterSetID*)arg[1]);
}

static void constructor_13965( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::TriggerResults(*(const ::edm::HLTGlobalStatus*)arg[0],
      *(const ::std::vector<std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::edm::TriggerResults(*(const ::edm::HLTGlobalStatus*)arg[0],
      *(const ::std::vector<std::basic_string<char> >*)arg[1]);
}

static  void method_13966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::TriggerResults*)o)->parameterSetID)();
  else   (((const ::edm::TriggerResults*)o)->parameterSetID)();
}

static  void method_13967( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::TriggerResults*)o)->swap)(*(::edm::TriggerResults*)arg[0]);
}

static  void operator_13968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::TriggerResults*)o)->operator=)(*(const ::edm::TriggerResults*)arg[0]);
  else   (((::edm::TriggerResults*)o)->operator=)(*(const ::edm::TriggerResults*)arg[0]);
}

static  void method_13969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::TriggerResults*)o)->getTriggerNames)();
  else   (((const ::edm::TriggerResults*)o)->getTriggerNames)();
}

static  void method_13970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::TriggerResults*)o)->name)(*(unsigned int*)arg[0]);
  else   (((const ::edm::TriggerResults*)o)->name)(*(unsigned int*)arg[0]);
}

static  void method_13971( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::TriggerResults*)o)->find)(*(const ::std::string*)arg[0]));
  else   (((const ::edm::TriggerResults*)o)->find)(*(const ::std::string*)arg[0]);
}

static void method_newdel_3099( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::TriggerResults >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::TriggerResults >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::TriggerResults >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::TriggerResults >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::TriggerResults >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::HLTGlobalStatus")), ::Reflex::BaseOffset< ::edm::TriggerResults,::edm::HLTGlobalStatus >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::DoNotRecordParents")), ::Reflex::BaseOffset< ::edm::TriggerResults,::edm::DoNotRecordParents >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TriggerResults -------------------------------
void __edm__TriggerResults_db_datamem(Reflex::Class*);
void __edm__TriggerResults_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__TriggerResults_datamem_bld(&__edm__TriggerResults_db_datamem);
Reflex::GenreflexMemberBuilder __edm__TriggerResults_funcmem_bld(&__edm__TriggerResults_db_funcmem);
void __edm__TriggerResults_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::TriggerResults"), typeid(::edm::TriggerResults), sizeof(::edm::TriggerResults), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2973, ::Reflex::BaseOffset< ::edm::TriggerResults, ::edm::HLTGlobalStatus >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_3031, ::Reflex::BaseOffset< ::edm::TriggerResults, ::edm::DoNotRecordParents >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_2291, Reflex::Literal("edm::TriggerResults::Strings"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerResults"), destructor_13961, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23327), Reflex::Literal("TriggerResults"), constructor_13962, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerResults"), constructor_13963, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13411, type_22957), Reflex::Literal("TriggerResults"), constructor_13964, 0, "hlt;psetid", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13411, type_22470), Reflex::Literal("TriggerResults"), constructor_13965, 0, "hlt;names", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3099, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__TriggerResults_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__TriggerResults_funcmem_bld);
}

//------Delayed data member builder for class TriggerResults -------------------
void __edm__TriggerResults_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3073, Reflex::Literal("psetid_"), OffsetOf(__shadow__::__edm__TriggerResults, psetid_), ::Reflex::PRIVATE)
  .AddDataMember(type_2291, Reflex::Literal("names_"), OffsetOf(__shadow__::__edm__TriggerResults, names_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerResults -------------------
void __edm__TriggerResults_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22957), Reflex::Literal("parameterSetID"), method_13966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13561), Reflex::Literal("swap"), method_13967, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13561, type_23327), Reflex::Literal("operator="), operator_13968, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22470), Reflex::Literal("getTriggerNames"), method_13969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10051, type_235), Reflex::Literal("name"), method_13970, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235, type_10051), Reflex::Literal("find"), method_13971, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::TriggerResults> -------------------------------
static void constructor_13081( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::TriggerResults>();
  else ::new(mem) ::edm::Wrapper<edm::TriggerResults>();
}

static void constructor_13082( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::TriggerResults>(*(::std::auto_ptr<edm::TriggerResults>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::TriggerResults>(*(::std::auto_ptr<edm::TriggerResults>*)arg[0]);
}

static void destructor_13083(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::TriggerResults>*)o)->::edm::Wrapper<edm::TriggerResults>::~Wrapper)();
}
static  void method_13084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::TriggerResults>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::TriggerResults>*)o)->product)();
}

static  void operator_13085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::TriggerResults>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::TriggerResults>*)o)->operator->)();
}

static  void method_13086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::TriggerResults>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::TriggerResults>*)o)->productTypeInfo)();
}

static  void method_13087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::TriggerResults>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::TriggerResults>*)o)->typeInfo)();
}

static void constructor_13088( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::TriggerResults>((::edm::TriggerResults*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::TriggerResults>((::edm::TriggerResults*)arg[0]);
}

static  void method_13089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::TriggerResults>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::TriggerResults>*)o)->getInterface)();
}

static  void method_13090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::TriggerResults>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13091( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::TriggerResults>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13092( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::TriggerResults>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::TriggerResults>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::TriggerResults>*)o)->dynamicTypeInfo)();
}

static  void method_13094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::TriggerResults>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::TriggerResults>*)o)->isPresent)();
}

static  void method_13095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::TriggerResults>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::TriggerResults>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2937( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::TriggerResults> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::TriggerResults> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::TriggerResults> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::TriggerResults> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::TriggerResults> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::TriggerResults> -------------------------------
void __edm__Wrapper_edm__TriggerResults__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__TriggerResults__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__TriggerResults__datamem_bld(&__edm__Wrapper_edm__TriggerResults__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__TriggerResults__funcmem_bld(&__edm__Wrapper_edm__TriggerResults__db_funcmem);
void __edm__Wrapper_edm__TriggerResults__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::TriggerResults>"), typeid(::edm::Wrapper<edm::TriggerResults>), sizeof(::edm::Wrapper<edm::TriggerResults>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3099, Reflex::Literal("edm::Wrapper<edm::TriggerResults>::value_type"))
  .AddTypedef(type_3099, Reflex::Literal("edm::Wrapper<edm::TriggerResults>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13081, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2025), Reflex::Literal("Wrapper"), constructor_13082, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13083, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23077), Reflex::Literal("Wrapper"), constructor_13088, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2937, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__TriggerResults__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__TriggerResults__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::TriggerResults> -------------------
void __edm__Wrapper_edm__TriggerResults__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__TriggerResults_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3099, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__TriggerResults_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::TriggerResults> -------------------
void __edm__Wrapper_edm__TriggerResults__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23076), Reflex::Literal("product"), method_13084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23076), Reflex::Literal("operator->"), operator_13085, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_13086, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_13087, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23078), Reflex::Literal("getInterface"), method_13089, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_13090, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_13091, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_13092, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_13093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_13094, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_13095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HLTGlobalStatus -------------------------------
static void destructor_13251(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::HLTGlobalStatus*)o)->::edm::HLTGlobalStatus::~HLTGlobalStatus)();
}
static void constructor_13252( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HLTGlobalStatus(*(const ::edm::HLTGlobalStatus*)arg[0]);
  else ::new(mem) ::edm::HLTGlobalStatus(*(const ::edm::HLTGlobalStatus*)arg[0]);
}

static void constructor_13253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HLTGlobalStatus();
  else ::new(mem) ::edm::HLTGlobalStatus();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HLTGlobalStatus(*(const unsigned int*)arg[0]);
  else ::new(mem) ::edm::HLTGlobalStatus(*(const unsigned int*)arg[0]);
  }
}

static  void method_13254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::HLTGlobalStatus*)o)->size)());
  else   (((const ::edm::HLTGlobalStatus*)o)->size)();
}

static  void method_13255( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::HLTGlobalStatus*)o)->reset)();
}

static  void method_13256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HLTGlobalStatus*)o)->wasrun)());
  else   (((const ::edm::HLTGlobalStatus*)o)->wasrun)();
}

static  void method_13257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HLTGlobalStatus*)o)->accept)());
  else   (((const ::edm::HLTGlobalStatus*)o)->accept)();
}

static  void method_13258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HLTGlobalStatus*)o)->error)());
  else   (((const ::edm::HLTGlobalStatus*)o)->error)();
}

static  void method_13259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::HLTGlobalStatus*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::edm::HLTGlobalStatus*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_13260( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::HLTGlobalStatus*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::edm::HLTGlobalStatus*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void operator_13261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::HLTGlobalStatus*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((const ::edm::HLTGlobalStatus*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void operator_13262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::HLTGlobalStatus*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::edm::HLTGlobalStatus*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_13263( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HLTGlobalStatus*)o)->wasrun)(*(const unsigned int*)arg[0]));
  else   (((const ::edm::HLTGlobalStatus*)o)->wasrun)(*(const unsigned int*)arg[0]);
}

static  void method_13264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HLTGlobalStatus*)o)->accept)(*(const unsigned int*)arg[0]));
  else   (((const ::edm::HLTGlobalStatus*)o)->accept)(*(const unsigned int*)arg[0]);
}

static  void method_13265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::HLTGlobalStatus*)o)->error)(*(const unsigned int*)arg[0]));
  else   (((const ::edm::HLTGlobalStatus*)o)->error)(*(const unsigned int*)arg[0]);
}

static  void method_13266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::edm::HLTGlobalStatus*)o)->state)(*(const unsigned int*)arg[0]));
  else   (((const ::edm::HLTGlobalStatus*)o)->state)(*(const unsigned int*)arg[0]);
}

static  void method_13267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::HLTGlobalStatus*)o)->index)(*(const unsigned int*)arg[0]));
  else   (((const ::edm::HLTGlobalStatus*)o)->index)(*(const unsigned int*)arg[0]);
}

static  void method_13268( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::HLTGlobalStatus*)o)->reset)(*(const unsigned int*)arg[0]);
}

static  void method_13269( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::HLTGlobalStatus*)o)->swap)(*(::edm::HLTGlobalStatus*)arg[0]);
}

static  void operator_13270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::HLTGlobalStatus*)o)->operator=)(*(const ::edm::HLTGlobalStatus*)arg[0]);
  else   (((::edm::HLTGlobalStatus*)o)->operator=)(*(const ::edm::HLTGlobalStatus*)arg[0]);
}

static void constructor_x46( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::HLTGlobalStatus();
  else ::new(mem) ::edm::HLTGlobalStatus();
}

static void method_newdel_2973( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::HLTGlobalStatus >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::HLTGlobalStatus >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::HLTGlobalStatus >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::HLTGlobalStatus >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::HLTGlobalStatus >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HLTGlobalStatus -------------------------------
void __edm__HLTGlobalStatus_db_datamem(Reflex::Class*);
void __edm__HLTGlobalStatus_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__HLTGlobalStatus_datamem_bld(&__edm__HLTGlobalStatus_db_datamem);
Reflex::GenreflexMemberBuilder __edm__HLTGlobalStatus_funcmem_bld(&__edm__HLTGlobalStatus_db_funcmem);
void __edm__HLTGlobalStatus_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::HLTGlobalStatus"), typeid(::edm::HLTGlobalStatus), sizeof(::edm::HLTGlobalStatus), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HLTGlobalStatus"), destructor_13251, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13411), Reflex::Literal("HLTGlobalStatus"), constructor_13252, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_235c), Reflex::Literal("HLTGlobalStatus"), constructor_13253, 0, "n=0", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HLTGlobalStatus"), constructor_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2973, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__HLTGlobalStatus_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__HLTGlobalStatus_funcmem_bld);
}

//------Delayed data member builder for class HLTGlobalStatus -------------------
void __edm__HLTGlobalStatus_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2289, Reflex::Literal("paths_"), OffsetOf(__shadow__::__edm__HLTGlobalStatus, paths_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HLTGlobalStatus -------------------
void __edm__HLTGlobalStatus_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("size"), method_13254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("reset"), method_13255, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("wasrun"), method_13256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("accept"), method_13257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("error"), method_13258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8769, type_235c), Reflex::Literal("at"), method_13259, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8767, type_235c), Reflex::Literal("at"), method_13260, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8769, type_235c), Reflex::Literal("operator[]"), operator_13261, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8767, type_235c), Reflex::Literal("operator[]"), operator_13262, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_235c), Reflex::Literal("wasrun"), method_13263, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_235c), Reflex::Literal("accept"), method_13264, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_235c), Reflex::Literal("error"), method_13265, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13296, type_235c), Reflex::Literal("state"), method_13266, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235, type_235c), Reflex::Literal("index"), method_13267, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_235c), Reflex::Literal("reset"), method_13268, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_9899), Reflex::Literal("swap"), method_13269, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9899, type_13411), Reflex::Literal("operator="), operator_13270, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class Wrapper<edm::HLTGlobalStatus> -------------------------------
static void constructor_13102( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::HLTGlobalStatus>();
  else ::new(mem) ::edm::Wrapper<edm::HLTGlobalStatus>();
}

static void constructor_13103( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::HLTGlobalStatus>(*(::std::auto_ptr<edm::HLTGlobalStatus>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::HLTGlobalStatus>(*(::std::auto_ptr<edm::HLTGlobalStatus>*)arg[0]);
}

static void destructor_13104(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::HLTGlobalStatus>*)o)->::edm::Wrapper<edm::HLTGlobalStatus>::~Wrapper)();
}
static  void method_13105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->product)();
}

static  void operator_13106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->operator->)();
}

static  void method_13107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::HLTGlobalStatus>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::HLTGlobalStatus>*)o)->productTypeInfo)();
}

static  void method_13108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::HLTGlobalStatus>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::HLTGlobalStatus>*)o)->typeInfo)();
}

static void constructor_13109( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::HLTGlobalStatus>((::edm::HLTGlobalStatus*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::HLTGlobalStatus>((::edm::HLTGlobalStatus*)arg[0]);
}

static  void method_13110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::HLTGlobalStatus>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::HLTGlobalStatus>*)o)->getInterface)();
}

static  void method_13111( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->dynamicTypeInfo)();
}

static  void method_13115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->isPresent)();
}

static  void method_13116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::HLTGlobalStatus>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2938( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTGlobalStatus> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTGlobalStatus> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTGlobalStatus> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTGlobalStatus> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTGlobalStatus> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::HLTGlobalStatus> -------------------------------
void __edm__Wrapper_edm__HLTGlobalStatus__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__HLTGlobalStatus__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__HLTGlobalStatus__datamem_bld(&__edm__Wrapper_edm__HLTGlobalStatus__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__HLTGlobalStatus__funcmem_bld(&__edm__Wrapper_edm__HLTGlobalStatus__db_funcmem);
void __edm__Wrapper_edm__HLTGlobalStatus__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::HLTGlobalStatus>"), typeid(::edm::Wrapper<edm::HLTGlobalStatus>), sizeof(::edm::Wrapper<edm::HLTGlobalStatus>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_2973, Reflex::Literal("edm::Wrapper<edm::HLTGlobalStatus>::value_type"))
  .AddTypedef(type_2973, Reflex::Literal("edm::Wrapper<edm::HLTGlobalStatus>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13102, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2026), Reflex::Literal("Wrapper"), constructor_13103, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13104, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23082), Reflex::Literal("Wrapper"), constructor_13109, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2938, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__HLTGlobalStatus__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__HLTGlobalStatus__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::HLTGlobalStatus> -------------------
void __edm__Wrapper_edm__HLTGlobalStatus__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__HLTGlobalStatus_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2973, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__HLTGlobalStatus_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::HLTGlobalStatus> -------------------
void __edm__Wrapper_edm__HLTGlobalStatus__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23081), Reflex::Literal("product"), method_13105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23081), Reflex::Literal("operator->"), operator_13106, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_13107, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_13108, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23083), Reflex::Literal("getInterface"), method_13110, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_13111, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_13112, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_13113, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_13114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_13115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_13116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<edm::HLTPathStatus, std::allocator<edm::HLTPathStatus> > > -------------------------------
static void constructor_13123( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::HLTPathStatus> >();
  else ::new(mem) ::edm::Wrapper<std::vector<edm::HLTPathStatus> >();
}

static void constructor_13124( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::HLTPathStatus> >(*(::std::auto_ptr<std::vector<edm::HLTPathStatus> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::HLTPathStatus> >(*(::std::auto_ptr<std::vector<edm::HLTPathStatus> >*)arg[0]);
}

static void destructor_13125(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->::edm::Wrapper<std::vector<edm::HLTPathStatus> >::~Wrapper)();
}
static  void method_13126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->product)();
}

static  void operator_13127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->operator->)();
}

static  void method_13128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->productTypeInfo)();
}

static  void method_13129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->typeInfo)();
}

static void constructor_13130( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<edm::HLTPathStatus> >((::std::vector<edm::HLTPathStatus>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<edm::HLTPathStatus> >((::std::vector<edm::HLTPathStatus>*)arg[0]);
}

static  void method_13131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->getInterface)();
}

static  void method_13132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13133( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13134( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->dynamicTypeInfo)();
}

static  void method_13136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->isPresent)();
}

static  void method_13137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<edm::HLTPathStatus> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2939( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::HLTPathStatus> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::HLTPathStatus> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::HLTPathStatus> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::HLTPathStatus> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<edm::HLTPathStatus> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<edm::HLTPathStatus, std::allocator<edm::HLTPathStatus> > > -------------------------------
void __edm__Wrapper_std__vector_edm__HLTPathStatus_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_edm__HLTPathStatus_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__HLTPathStatus_s__datamem_bld(&__edm__Wrapper_std__vector_edm__HLTPathStatus_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_edm__HLTPathStatus_s__funcmem_bld(&__edm__Wrapper_std__vector_edm__HLTPathStatus_s__db_funcmem);
void __edm__Wrapper_std__vector_edm__HLTPathStatus_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<edm::HLTPathStatus> >"), typeid(::edm::Wrapper<std::vector<edm::HLTPathStatus> >), sizeof(::edm::Wrapper<std::vector<edm::HLTPathStatus> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_2289, Reflex::Literal("edm::Wrapper<std::vector<edm::HLTPathStatus> >::value_type"))
  .AddTypedef(type_2289, Reflex::Literal("edm::Wrapper<std::vector<edm::HLTPathStatus> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13123, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2027), Reflex::Literal("Wrapper"), constructor_13124, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13125, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23087), Reflex::Literal("Wrapper"), constructor_13130, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2939, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_edm__HLTPathStatus_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_edm__HLTPathStatus_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<edm::HLTPathStatus, std::allocator<edm::HLTPathStatus> > > -------------------
void __edm__Wrapper_std__vector_edm__HLTPathStatus_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__HLTPathStatus_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2289, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_edm__HLTPathStatus_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<edm::HLTPathStatus, std::allocator<edm::HLTPathStatus> > > -------------------
void __edm__Wrapper_std__vector_edm__HLTPathStatus_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23086), Reflex::Literal("product"), method_13126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23086), Reflex::Literal("operator->"), operator_13127, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_13128, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_13129, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23088), Reflex::Literal("getInterface"), method_13131, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_13132, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_13133, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_13134, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_13135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_13136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_13137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::HLTPathStatus> -------------------------------
static void constructor_13144( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::HLTPathStatus>();
  else ::new(mem) ::edm::Wrapper<edm::HLTPathStatus>();
}

static void constructor_13145( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::HLTPathStatus>(*(::std::auto_ptr<edm::HLTPathStatus>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::HLTPathStatus>(*(::std::auto_ptr<edm::HLTPathStatus>*)arg[0]);
}

static void destructor_13146(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::HLTPathStatus>*)o)->::edm::Wrapper<edm::HLTPathStatus>::~Wrapper)();
}
static  void method_13147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->product)();
}

static  void operator_13148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->operator->)();
}

static  void method_13149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::HLTPathStatus>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::HLTPathStatus>*)o)->productTypeInfo)();
}

static  void method_13150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::HLTPathStatus>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::HLTPathStatus>*)o)->typeInfo)();
}

static void constructor_13151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::HLTPathStatus>((::edm::HLTPathStatus*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::HLTPathStatus>((::edm::HLTPathStatus*)arg[0]);
}

static  void method_13152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::HLTPathStatus>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::HLTPathStatus>*)o)->getInterface)();
}

static  void method_13153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13154( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13155( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->dynamicTypeInfo)();
}

static  void method_13157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->isPresent)();
}

static  void method_13158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::HLTPathStatus>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2940( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTPathStatus> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTPathStatus> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTPathStatus> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTPathStatus> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::HLTPathStatus> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::HLTPathStatus> -------------------------------
void __edm__Wrapper_edm__HLTPathStatus__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__HLTPathStatus__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__HLTPathStatus__datamem_bld(&__edm__Wrapper_edm__HLTPathStatus__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__HLTPathStatus__funcmem_bld(&__edm__Wrapper_edm__HLTPathStatus__db_funcmem);
void __edm__Wrapper_edm__HLTPathStatus__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::HLTPathStatus>"), typeid(::edm::Wrapper<edm::HLTPathStatus>), sizeof(::edm::Wrapper<edm::HLTPathStatus>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3027, Reflex::Literal("edm::Wrapper<edm::HLTPathStatus>::value_type"))
  .AddTypedef(type_3027, Reflex::Literal("edm::Wrapper<edm::HLTPathStatus>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13144, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2028), Reflex::Literal("Wrapper"), constructor_13145, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13146, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8763), Reflex::Literal("Wrapper"), constructor_13151, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2940, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__HLTPathStatus__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__HLTPathStatus__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::HLTPathStatus> -------------------
void __edm__Wrapper_edm__HLTPathStatus__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__HLTPathStatus_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3027, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__HLTPathStatus_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::HLTPathStatus> -------------------
void __edm__Wrapper_edm__HLTPathStatus__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8765), Reflex::Literal("product"), method_13147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8765), Reflex::Literal("operator->"), operator_13148, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_13149, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_13150, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23091), Reflex::Literal("getInterface"), method_13152, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_13153, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_13154, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_13155, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_13156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_13157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_13158, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class DataFrameContainer -------------------------------
static void destructor_13434(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DataFrameContainer*)o)->::edm::DataFrameContainer::~DataFrameContainer)();
}
static void constructor_13435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DataFrameContainer(*(const ::edm::DataFrameContainer*)arg[0]);
  else ::new(mem) ::edm::DataFrameContainer(*(const ::edm::DataFrameContainer*)arg[0]);
}

static void constructor_13436( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DataFrameContainer();
  else ::new(mem) ::edm::DataFrameContainer();
}

static void constructor_13437( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DataFrameContainer(*(::size_t*)arg[0]);
  else ::new(mem) ::edm::DataFrameContainer(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DataFrameContainer(*(::size_t*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::edm::DataFrameContainer(*(::size_t*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DataFrameContainer(*(::size_t*)arg[0],
      *(int*)arg[1],
      *(::size_t*)arg[2]);
  else ::new(mem) ::edm::DataFrameContainer(*(::size_t*)arg[0],
      *(int*)arg[1],
      *(::size_t*)arg[2]);
  }
}

static  void method_13438( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrameContainer*)o)->swap)(*(::edm::DataFrameContainer*)arg[0]);
}

static  void operator_13439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DataFrameContainer*)o)->operator=)(*(const ::edm::DataFrameContainer*)arg[0]);
  else   (((::edm::DataFrameContainer*)o)->operator=)(*(const ::edm::DataFrameContainer*)arg[0]);
}

static  void method_13440( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrameContainer*)o)->swap)(*(::std::vector<unsigned int>*)arg[0],
    *(::std::vector<unsigned short>*)arg[1]);
}

static  void method_13441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrameContainer*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_13442( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrameContainer*)o)->resize)(*(::size_t*)arg[0]);
}

static  void method_13443( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DataFrameContainer*)o)->sort)();
}

static  void method_13444( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrameContainer*)o)->push_back)(*(unsigned int*)arg[0],
    (const unsigned short*)arg[1]);
}

static  void method_13445( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrameContainer*)o)->push_back)(*(unsigned int*)arg[0]);
}

static  void method_13446( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrameContainer*)o)->set_back)(*(unsigned int*)arg[0],
    (const unsigned short*)arg[1]);
}

static  void method_13447( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrameContainer*)o)->set_back)(*(unsigned int*)arg[0]);
}

static  void method_13448( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::DataFrameContainer*)o)->set_back)((const unsigned short*)arg[0]);
}

static  void method_13449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::DataFrame)((((::edm::DataFrameContainer*)o)->back)());
  else   (((::edm::DataFrameContainer*)o)->back)();
}

static  void method_13450( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::DataFrameContainer*)o)->pop_back)();
}

static  void method_13451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >,__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> > >)((((::edm::DataFrameContainer*)o)->pair)(*(::size_t*)arg[0]));
  else   (((::edm::DataFrameContainer*)o)->pair)(*(::size_t*)arg[0]);
}

static  void method_13452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >,__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> > >)((((const ::edm::DataFrameContainer*)o)->pair)(*(::size_t*)arg[0]));
  else   (((const ::edm::DataFrameContainer*)o)->pair)(*(::size_t*)arg[0]);
}

static  void operator_13453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::DataFrame)((((::edm::DataFrameContainer*)o)->operator[])(*(::size_t*)arg[0]));
  else   (((::edm::DataFrameContainer*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void operator_13454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::DataFrame)((((const ::edm::DataFrameContainer*)o)->operator[])(*(::size_t*)arg[0]));
  else   (((const ::edm::DataFrameContainer*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_13455( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (boost::transform_iterator<edm::DataFrameContainer::IterHelp,boost::counting_iterator<int,boost::use_default,boost::use_default>,boost::use_default,boost::use_default>)((((const ::edm::DataFrameContainer*)o)->find)(*(unsigned int*)arg[0]));
  else   (((const ::edm::DataFrameContainer*)o)->find)(*(unsigned int*)arg[0]);
}

static  void method_13456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (boost::transform_iterator<edm::DataFrameContainer::IterHelp,boost::counting_iterator<int,boost::use_default,boost::use_default>,boost::use_default,boost::use_default>)((((const ::edm::DataFrameContainer*)o)->begin)());
  else   (((const ::edm::DataFrameContainer*)o)->begin)();
}

static  void method_13457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (boost::transform_iterator<edm::DataFrameContainer::IterHelp,boost::counting_iterator<int,boost::use_default,boost::use_default>,boost::use_default,boost::use_default>)((((const ::edm::DataFrameContainer*)o)->end)());
  else   (((const ::edm::DataFrameContainer*)o)->end)();
}

static  void method_13458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::edm::DataFrameContainer*)o)->subdetId)());
  else   (((const ::edm::DataFrameContainer*)o)->subdetId)();
}

static  void method_13459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::DataFrameContainer*)o)->stride)());
  else   (((const ::edm::DataFrameContainer*)o)->stride)();
}

static  void method_13460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::DataFrameContainer*)o)->empty)());
  else   (((const ::edm::DataFrameContainer*)o)->empty)();
}

static  void method_13461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::DataFrameContainer*)o)->size)());
  else   (((const ::edm::DataFrameContainer*)o)->size)();
}

static  void operator_13462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned short)((((const ::edm::DataFrameContainer*)o)->operator())(*(::size_t*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::DataFrameContainer*)o)->operator())(*(::size_t*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_13463( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::DataFrameContainer*)o)->frame)(*(::size_t*)arg[0]));
  else   (((const ::edm::DataFrameContainer*)o)->frame)(*(::size_t*)arg[0]);
}

static  void method_13464( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::DataFrameContainer*)o)->id)(*(::size_t*)arg[0]));
  else   (((const ::edm::DataFrameContainer*)o)->id)(*(::size_t*)arg[0]);
}

static void method_newdel_3023( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DataFrameContainer >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DataFrameContainer >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DataFrameContainer >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DataFrameContainer >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DataFrameContainer >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DataFrameContainer -------------------------------
void __edm__DataFrameContainer_db_datamem(Reflex::Class*);
void __edm__DataFrameContainer_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DataFrameContainer_datamem_bld(&__edm__DataFrameContainer_db_datamem);
Reflex::GenreflexMemberBuilder __edm__DataFrameContainer_funcmem_bld(&__edm__DataFrameContainer_db_funcmem);
void __edm__DataFrameContainer_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DataFrameContainer"), typeid(::edm::DataFrameContainer), sizeof(::edm::DataFrameContainer), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_235, Reflex::Literal("edm::DataFrameContainer::size_type"))
  .AddTypedef(type_235, Reflex::Literal("edm::DataFrameContainer::id_type"))
  .AddTypedef(type_161, Reflex::Literal("edm::DataFrameContainer::data_type"))
  .AddTypedef(type_2285, Reflex::Literal("edm::DataFrameContainer::IdContainer"))
  .AddTypedef(type_2290, Reflex::Literal("edm::DataFrameContainer::DataContainer"))
  .AddTypedef(type_3600, Reflex::Literal("edm::DataFrameContainer::IdIter"))
  .AddTypedef(type_3599, Reflex::Literal("edm::DataFrameContainer::DataIter"))
  .AddTypedef(type_2221, Reflex::Literal("edm::DataFrameContainer::IterPair"))
  .AddTypedef(type_3595, Reflex::Literal("edm::DataFrameContainer::const_IdIter"))
  .AddTypedef(type_3598, Reflex::Literal("edm::DataFrameContainer::const_DataIter"))
  .AddTypedef(type_2220, Reflex::Literal("edm::DataFrameContainer::const_IterPair"))
  .AddTypedef(type_4151, Reflex::Literal("edm::DataFrameContainer::const_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DataFrameContainer"), destructor_13434, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22946), Reflex::Literal("DataFrameContainer"), constructor_13435, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DataFrameContainer"), constructor_13436, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1489, type_61, type_1489), Reflex::Literal("DataFrameContainer"), constructor_13437, 0, "istride;isubdet=0;isize=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3023, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__DataFrameContainer_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__DataFrameContainer_funcmem_bld);
}

//------Delayed data member builder for class DataFrameContainer -------------------
void __edm__DataFrameContainer_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_61, Reflex::Literal("m_subdetId"), OffsetOf(__shadow__::__edm__DataFrameContainer, m_subdetId), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("m_stride"), OffsetOf(__shadow__::__edm__DataFrameContainer, m_stride), ::Reflex::PRIVATE)
  .AddDataMember(type_2285, Reflex::Literal("m_ids"), OffsetOf(__shadow__::__edm__DataFrameContainer, m_ids), ::Reflex::PRIVATE)
  .AddDataMember(type_2290, Reflex::Literal("m_data"), OffsetOf(__shadow__::__edm__DataFrameContainer, m_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class DataFrameContainer -------------------
void __edm__DataFrameContainer_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_9898), Reflex::Literal("swap"), method_13438, 0, "rh", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9898, type_22946), Reflex::Literal("operator="), operator_13439, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_22459, type_22469), Reflex::Literal("swap"), method_13440, 0, "iic;idc", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_1489), Reflex::Literal("reserve"), method_13441, 0, "isize", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_1489), Reflex::Literal("resize"), method_13442, 0, "isize", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("sort"), method_13443, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_235, type_5041), Reflex::Literal("push_back"), method_13444, 0, "iid;idata", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_235), Reflex::Literal("push_back"), method_13445, 0, "iid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_235, type_5041), Reflex::Literal("set_back"), method_13446, 0, "iid;idata", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_235), Reflex::Literal("set_back"), method_13447, 0, "iid", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_5041), Reflex::Literal("set_back"), method_13448, 0, "idata", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2902), Reflex::Literal("back"), method_13449, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("pop_back"), method_13450, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2221, type_1489), Reflex::Literal("pair"), method_13451, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2220, type_1489), Reflex::Literal("pair"), method_13452, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2902, type_1489), Reflex::Literal("operator[]"), operator_13453, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2902, type_1489), Reflex::Literal("operator[]"), operator_13454, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4151, type_235), Reflex::Literal("find"), method_13455, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4151), Reflex::Literal("begin"), method_13456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4151), Reflex::Literal("end"), method_13457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_61), Reflex::Literal("subdetId"), method_13458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("stride"), method_13459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_13460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("size"), method_13461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_161, type_1489, type_1489), Reflex::Literal("operator()"), operator_13462, 0, "cell;frame", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5041, type_1489), Reflex::Literal("frame"), method_13463, 0, "cell", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235, type_1489), Reflex::Literal("id"), method_13464, 0, "cell", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::DataFrameContainer> -------------------------------
static void constructor_13165( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DataFrameContainer>();
  else ::new(mem) ::edm::Wrapper<edm::DataFrameContainer>();
}

static void constructor_13166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DataFrameContainer>(*(::std::auto_ptr<edm::DataFrameContainer>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DataFrameContainer>(*(::std::auto_ptr<edm::DataFrameContainer>*)arg[0]);
}

static void destructor_13167(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::DataFrameContainer>*)o)->::edm::Wrapper<edm::DataFrameContainer>::~Wrapper)();
}
static  void method_13168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->product)();
}

static  void operator_13169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->operator->)();
}

static  void method_13170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DataFrameContainer>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::DataFrameContainer>*)o)->productTypeInfo)();
}

static  void method_13171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::DataFrameContainer>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::DataFrameContainer>*)o)->typeInfo)();
}

static void constructor_13172( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::DataFrameContainer>((::edm::DataFrameContainer*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::DataFrameContainer>((::edm::DataFrameContainer*)arg[0]);
}

static  void method_13173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::DataFrameContainer>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::DataFrameContainer>*)o)->getInterface)();
}

static  void method_13174( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_13175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_13176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->dynamicTypeInfo)();
}

static  void method_13178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->isPresent)();
}

static  void method_13179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::DataFrameContainer>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_2941( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DataFrameContainer> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DataFrameContainer> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DataFrameContainer> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DataFrameContainer> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::DataFrameContainer> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::DataFrameContainer> -------------------------------
void __edm__Wrapper_edm__DataFrameContainer__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__DataFrameContainer__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DataFrameContainer__datamem_bld(&__edm__Wrapper_edm__DataFrameContainer__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__DataFrameContainer__funcmem_bld(&__edm__Wrapper_edm__DataFrameContainer__db_funcmem);
void __edm__Wrapper_edm__DataFrameContainer__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::DataFrameContainer>"), typeid(::edm::Wrapper<edm::DataFrameContainer>), sizeof(::edm::Wrapper<edm::DataFrameContainer>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3023, Reflex::Literal("edm::Wrapper<edm::DataFrameContainer>::value_type"))
  .AddTypedef(type_3023, Reflex::Literal("edm::Wrapper<edm::DataFrameContainer>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_13165, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2029), Reflex::Literal("Wrapper"), constructor_13166, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_13167, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23095), Reflex::Literal("Wrapper"), constructor_13172, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2941, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__DataFrameContainer__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__DataFrameContainer__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::DataFrameContainer> -------------------
void __edm__Wrapper_edm__DataFrameContainer__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__DataFrameContainer_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3023, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__DataFrameContainer_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::DataFrameContainer> -------------------
void __edm__Wrapper_edm__DataFrameContainer__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23094), Reflex::Literal("product"), method_13168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23094), Reflex::Literal("operator->"), operator_13169, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("productTypeInfo"), method_13170, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("typeInfo"), method_13171, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23096), Reflex::Literal("getInterface"), method_13173, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_12510, type_22439, type_23008), Reflex::Literal("fillView"), method_13174, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_228, type_5096), Reflex::Literal("setPtr"), method_13175, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_22440, type_22439), Reflex::Literal("fillPtrVector"), method_13176, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo"), method_13177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isPresent"), method_13178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("dynamicTypeInfo_"), method_13179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RangeMap<int,std::vector<float, std::allocator<float> >,edm::CopyPolicy<float> > -------------------------------
static void destructor_13218(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::~RangeMap)();
}
static void constructor_13219( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >(*(const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)arg[0]);
  else ::new(mem) ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >(*(const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)arg[0]);
}

static void constructor_13220( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >();
  else ::new(mem) ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >();
}

static  void method_13221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<__gnu_cxx::__normal_iterator<const float*,std::vector<float> >,__gnu_cxx::__normal_iterator<const float*,std::vector<float> > >)((((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->get)(*(int*)arg[0]));
  else   (((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->get)(*(int*)arg[0]);
}

static  void method_13222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->size)());
  else   (((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->size)();
}

static  void method_13223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const float*,std::vector<float> >)((((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->begin)());
  else   (((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->begin)();
}

static  void method_13224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const float*,std::vector<float> >)((((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->end)());
  else   (((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->end)();
}

static  void method_13225( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->post_insert)();
}

static  void method_13226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::id_iterator)((((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->id_begin)());
  else   (((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->id_begin)();
}

static  void method_13227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::id_iterator)((((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->id_end)());
  else   (((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->id_end)();
}

static  void method_13228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->id_size)());
  else   (((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->id_size)();
}

static  void method_13229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->ids)());
  else   (((const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->ids)();
}

static  void operator_13230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->swap)(*(::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)arg[0]);
}

static  void operator_13232( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->operator=)(*(const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)arg[0]);
  else   (((::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->operator=)(*(const ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)arg[0]);
}

static  void method_13233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->Class_Version)());
  else   (((::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >*)o)->Class_Version)();
}

static void method_newdel_2968( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RangeMap<int,std::vector<float, std::allocator<float> >,edm::CopyPolicy<float> > -------------------------------
void __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__db_datamem(Reflex::Class*);
void __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__datamem_bld(&__edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__funcmem_bld(&__edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__db_funcmem);
void __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >"), typeid(::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >), sizeof(::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::Class_Version())
  .AddTypedef(type_641, Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::value_type"))
  .AddTypedef(type_2504, Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::size_type"))
  .AddTypedef(type_8391, Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::reference"))
  .AddTypedef(type_2862, Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::pointer"))
  .AddTypedef(type_3588, Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::const_iterator"))
  .AddTypedef(type_2217, Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::pairType"))
  .AddTypedef(type_2428, Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::mapType"))
  .AddTypedef(type_2218, Reflex::Literal("edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> >::range"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RangeMap"), destructor_13218, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23102), Reflex::Literal("RangeMap"), constructor_13219, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RangeMap"), constructor_13220, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2968, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__funcmem_bld);
}

//------Delayed data member builder for class RangeMap<int,std::vector<float, std::allocator<float> >,edm::CopyPolicy<float> > -------------------
void __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2283, Reflex::Literal("collection_"), OffsetOf(__shadow__::__edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s_, collection_), ::Reflex::PRIVATE)
  .AddDataMember(type_2428, Reflex::Literal("map_"), OffsetOf(__shadow__::__edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s_, map_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RangeMap<int,std::vector<float, std::allocator<float> >,edm::CopyPolicy<float> > -------------------
void __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2218, type_61), Reflex::Literal("get"), method_13221, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_13222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3588), Reflex::Literal("begin"), method_13223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3588), Reflex::Literal("end"), method_13224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("post_insert"), method_13225, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13217), Reflex::Literal("id_begin"), method_13226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13217), Reflex::Literal("id_end"), method_13227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("id_size"), method_13228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2286), Reflex::Literal("ids"), method_13229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8391, type_2504), Reflex::Literal("operator[]"), operator_13230, 0, "i", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23103), Reflex::Literal("swap"), method_13231, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23103, type_23102), Reflex::Literal("operator="), operator_13232, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_13233, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class BoolCache -------------------------------
static void destructor_13362(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::BoolCache*)o)->::edm::BoolCache::~BoolCache)();
}
static  void operator_13363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::BoolCache*)o)->operator=)(*(const ::edm::BoolCache*)arg[0]);
  else   (((::edm::BoolCache*)o)->operator=)(*(const ::edm::BoolCache*)arg[0]);
}

static void constructor_13364( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::BoolCache(*(const ::edm::BoolCache*)arg[0]);
  else ::new(mem) ::edm::BoolCache(*(const ::edm::BoolCache*)arg[0]);
}

static void constructor_13365( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::BoolCache();
  else ::new(mem) ::edm::BoolCache();
}

static void constructor_13366( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::BoolCache(*(bool*)arg[0]);
  else ::new(mem) ::edm::BoolCache(*(bool*)arg[0]);
}

static  void converter_13367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((::edm::BoolCache*)o)->operator bool)());
  else   (((::edm::BoolCache*)o)->operator bool)();
}

static  void operator_13368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::BoolCache*)o)->operator=)(*(bool*)arg[0]);
  else   (((::edm::BoolCache*)o)->operator=)(*(bool*)arg[0]);
}

static void method_newdel_2999( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::BoolCache >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::BoolCache >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::BoolCache >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::BoolCache >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::BoolCache >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___edm__BoolCache_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  bool &isCached_ = *(bool*)(target + OffsetOf(__shadow__::__edm__BoolCache, isCached_));

  //--- User's code ---
    isCached_=0;
    
 
}

//------Dictionary for class BoolCache -------------------------------
void __edm__BoolCache_db_datamem(Reflex::Class*);
void __edm__BoolCache_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__BoolCache_datamem_bld(&__edm__BoolCache_db_datamem);
Reflex::GenreflexMemberBuilder __edm__BoolCache_funcmem_bld(&__edm__BoolCache_db_funcmem);
void __edm__BoolCache_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "edm::BoolCache";
  rule->fTarget      = "isCached_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___edm__BoolCache_0);
  rule->fCode        = "\n    isCached_=0;\n    \n ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("edm::BoolCache"), typeid(::edm::BoolCache), sizeof(::edm::BoolCache), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddProperty("ioread", readrules )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BoolCache"), destructor_13362, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23220, type_23221), Reflex::Literal("operator="), operator_13363, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23221), Reflex::Literal("BoolCache"), constructor_13364, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BoolCache"), constructor_13365, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2811), Reflex::Literal("BoolCache"), constructor_13366, 0, "iValue", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2999, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__BoolCache_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__BoolCache_funcmem_bld);
}

//------Delayed data member builder for class BoolCache -------------------
void __edm__BoolCache_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2811, Reflex::Literal("isCached_"), OffsetOf(__shadow__::__edm__BoolCache, isCached_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT);
}
//------Delayed function member builder for class BoolCache -------------------
void __edm__BoolCache_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("operator bool"), converter_13367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23220, type_2811), Reflex::Literal("operator="), operator_13368, 0, "b", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class PtrVectorBase -------------------------------
static  void operator_13470( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVectorBase*)o)->operator=)(*(const ::edm::PtrVectorBase*)arg[0]);
  else   (((::edm::PtrVectorBase*)o)->operator=)(*(const ::edm::PtrVectorBase*)arg[0]);
}

static void constructor_13471( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVectorBase(*(const ::edm::PtrVectorBase*)arg[0]);
  else ::new(mem) ::edm::PtrVectorBase(*(const ::edm::PtrVectorBase*)arg[0]);
}

static void constructor_13472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVectorBase(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVectorBase(*(const ::edm::ProductID*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVectorBase(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1]);
  else ::new(mem) ::edm::PtrVectorBase(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVectorBase(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::PtrVectorBase(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  }
}

static void destructor_13473(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVectorBase*)o)->::edm::PtrVectorBase::~PtrVectorBase)();
}
static  void method_13474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::PtrVectorBase*)o)->isNull)());
  else   (((const ::edm::PtrVectorBase*)o)->isNull)();
}

static  void method_13475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::PtrVectorBase*)o)->isNonnull)());
  else   (((const ::edm::PtrVectorBase*)o)->isNonnull)();
}

static  void operator_13476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::PtrVectorBase*)o)->operator!)());
  else   (((const ::edm::PtrVectorBase*)o)->operator!)();
}

static  void method_13477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::PtrVectorBase*)o)->id)());
  else   (((const ::edm::PtrVectorBase*)o)->id)();
}

static  void method_13478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::PtrVectorBase*)o)->productGetter)());
  else   (((const ::edm::PtrVectorBase*)o)->productGetter)();
}

static  void method_13479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::PtrVectorBase*)o)->hasCache)());
  else   (((const ::edm::PtrVectorBase*)o)->hasCache)();
}

static  void method_13480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::PtrVectorBase*)o)->hasProductCache)());
  else   (((const ::edm::PtrVectorBase*)o)->hasProductCache)();
}

static  void method_13481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::PtrVectorBase*)o)->isAvailable)());
  else   (((const ::edm::PtrVectorBase*)o)->isAvailable)();
}

static  void method_13482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::PtrVectorBase*)o)->empty)());
  else   (((const ::edm::PtrVectorBase*)o)->empty)();
}

static  void method_13483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::PtrVectorBase*)o)->size)());
  else   (((const ::edm::PtrVectorBase*)o)->size)();
}

static  void method_13484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::PtrVectorBase*)o)->capacity)());
  else   (((const ::edm::PtrVectorBase*)o)->capacity)();
}

static  void method_13485( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::PtrVectorBase*)o)->clear)();
}

static  void operator_13486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::PtrVectorBase*)o)->operator==)(*(const ::edm::PtrVectorBase*)arg[0]));
  else   (((const ::edm::PtrVectorBase*)o)->operator==)(*(const ::edm::PtrVectorBase*)arg[0]);
}

static  void method_13487( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVectorBase*)o)->reserve)(*(unsigned long*)arg[0]);
}

static  void method_13488( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVectorBase*)o)->setProductGetter)((::edm::EDProductGetter*)arg[0]);
}

static  void method_13489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::PtrVectorBase*)o)->isTransient)());
  else   (((const ::edm::PtrVectorBase*)o)->isTransient)();
}

static  void method_13490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::PtrVectorBase*)o)->product)());
  else   (((const ::edm::PtrVectorBase*)o)->product)();
}

void read___edm__PtrVectorBase_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  std::vector<const void*> &cachedItems_ = *(std::vector<const void*>*)(target + OffsetOf(__shadow__::__edm__PtrVectorBase, cachedItems_));

  //--- User's code ---
    cachedItems_.clear();
    
  
}

//------Dictionary for class PtrVectorBase -------------------------------
void __edm__PtrVectorBase_db_datamem(Reflex::Class*);
void __edm__PtrVectorBase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVectorBase_datamem_bld(&__edm__PtrVectorBase_db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVectorBase_funcmem_bld(&__edm__PtrVectorBase_db_funcmem);
void __edm__PtrVectorBase_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "edm::PtrVectorBase";
  rule->fTarget      = "cachedItems_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___edm__PtrVectorBase_0);
  rule->fCode        = "\n    cachedItems_.clear();\n    \n  ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVectorBase"), typeid(::edm::PtrVectorBase), sizeof(::edm::PtrVectorBase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddProperty("ioread", readrules )
  .AddTypedef(type_228, Reflex::Literal("edm::PtrVectorBase::key_type"))
  .AddTypedef(type_228, Reflex::Literal("edm::PtrVectorBase::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23242, type_23243), Reflex::Literal("operator="), operator_13470, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23243), Reflex::Literal("PtrVectorBase"), constructor_13471, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_2845, type_13915), Reflex::Literal("PtrVectorBase"), constructor_13472, 0, "productID;prodPtr=0;prodGetter=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVectorBase"), destructor_13473, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandDataMemberBuilder(&__edm__PtrVectorBase_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVectorBase_funcmem_bld);
}

//------Delayed data member builder for class PtrVectorBase -------------------
void __edm__PtrVectorBase_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3056, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__PtrVectorBase, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_2278, Reflex::Literal("indicies_"), OffsetOf(__shadow__::__edm__PtrVectorBase, indicies_), ::Reflex::PRIVATE)
  .AddDataMember(type_2277, Reflex::Literal("cachedItems_"), OffsetOf(__shadow__::__edm__PtrVectorBase, cachedItems_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class PtrVectorBase -------------------
void __edm__PtrVectorBase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNull"), method_13474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNonnull"), method_13475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("operator!"), operator_13476, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_13477, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_13478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("hasCache"), method_13479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("hasProductCache"), method_13480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_13481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_13482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_228), Reflex::Literal("size"), method_13483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_228), Reflex::Literal("capacity"), method_13484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_13485, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_23243), Reflex::Literal("operator=="), operator_13486, 0, "iRHS", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_228), Reflex::Literal("reserve"), method_13487, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23244), Reflex::Literal("setProductGetter"), method_13488, 0, "iGetter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isTransient"), method_13489, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("product"), method_13490, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class DoNotRecordParents -------------------------------
static void destructor_13518(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DoNotRecordParents*)o)->::edm::DoNotRecordParents::~DoNotRecordParents)();
}
static  void operator_13519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DoNotRecordParents*)o)->operator=)(*(const ::edm::DoNotRecordParents*)arg[0]);
  else   (((::edm::DoNotRecordParents*)o)->operator=)(*(const ::edm::DoNotRecordParents*)arg[0]);
}

static void constructor_13520( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DoNotRecordParents(*(const ::edm::DoNotRecordParents*)arg[0]);
  else ::new(mem) ::edm::DoNotRecordParents(*(const ::edm::DoNotRecordParents*)arg[0]);
}

static void constructor_13521( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DoNotRecordParents();
  else ::new(mem) ::edm::DoNotRecordParents();
}

static void method_newdel_3031( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DoNotRecordParents >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DoNotRecordParents >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DoNotRecordParents >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DoNotRecordParents >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DoNotRecordParents >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DoNotRecordParents -------------------------------
void __edm__DoNotRecordParents_db_datamem(Reflex::Class*);
void __edm__DoNotRecordParents_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DoNotRecordParents_datamem_bld(&__edm__DoNotRecordParents_db_datamem);
Reflex::GenreflexMemberBuilder __edm__DoNotRecordParents_funcmem_bld(&__edm__DoNotRecordParents_db_funcmem);
void __edm__DoNotRecordParents_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DoNotRecordParents"), typeid(::edm::DoNotRecordParents), sizeof(::edm::DoNotRecordParents), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DoNotRecordParents"), destructor_13518, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23248, type_23249), Reflex::Literal("operator="), operator_13519, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23249), Reflex::Literal("DoNotRecordParents"), constructor_13520, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DoNotRecordParents"), constructor_13521, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3031, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class DoNotRecordParents -------------------
void __edm__DoNotRecordParents_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DoNotRecordParents -------------------
void __edm__DoNotRecordParents_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class RefCore -------------------------------
static void destructor_13610(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefCore*)o)->::edm::RefCore::~RefCore)();
}
static  void operator_13611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefCore*)o)->operator=)(*(const ::edm::RefCore*)arg[0]);
  else   (((::edm::RefCore*)o)->operator=)(*(const ::edm::RefCore*)arg[0]);
}

static void constructor_13612( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefCore(*(const ::edm::RefCore*)arg[0]);
  else ::new(mem) ::edm::RefCore(*(const ::edm::RefCore*)arg[0]);
}

static void constructor_13613( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefCore();
  else ::new(mem) ::edm::RefCore();
}

static void constructor_13614( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefCore(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2],
      *(bool*)arg[3]);
  else ::new(mem) ::edm::RefCore(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2],
      *(bool*)arg[3]);
}

static  void method_13615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefCore*)o)->id)());
  else   (((const ::edm::RefCore*)o)->id)();
}

static  void method_13616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefCore*)o)->productPtr)());
  else   (((const ::edm::RefCore*)o)->productPtr)();
}

static  void method_13617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCore*)o)->setProductPtr)((const void*)arg[0]);
}

static  void method_13618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCore*)o)->isNull)());
  else   (((const ::edm::RefCore*)o)->isNull)();
}

static  void method_13619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCore*)o)->isNonnull)());
  else   (((const ::edm::RefCore*)o)->isNonnull)();
}

static  void operator_13620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCore*)o)->operator!)());
  else   (((const ::edm::RefCore*)o)->operator!)();
}

static  void method_13621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCore*)o)->isAvailable)());
  else   (((const ::edm::RefCore*)o)->isAvailable)();
}

static  void method_13622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefCore*)o)->productGetter)());
  else   (((const ::edm::RefCore*)o)->productGetter)();
}

static  void method_13623( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCore*)o)->setProductGetter)((const ::edm::EDProductGetter*)arg[0]);
}

static  void method_13624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::WrapperHolder)((((const ::edm::RefCore*)o)->getProductPtr)(*(const ::std::type_info*)arg[0]));
  else   (((const ::edm::RefCore*)o)->getProductPtr)(*(const ::std::type_info*)arg[0]);
}

static  void method_13625( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCore*)o)->productNotFoundException)(*(const ::std::type_info*)arg[0]);
}

static  void method_13626( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCore*)o)->wrongTypeException)(*(const ::std::type_info*)arg[0],
    *(const ::std::type_info*)arg[1]);
}

static  void method_13627( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCore*)o)->nullPointerForTransientException)(*(const ::std::type_info*)arg[0]);
}

static  void method_13628( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefCore*)o)->swap)(*(::edm::RefCore*)arg[0]);
}

static  void method_13629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCore*)o)->isTransient)());
  else   (((const ::edm::RefCore*)o)->isTransient)();
}

static  void method_13630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::edm::RefCore*)o)->isTransientInt)());
  else   (((const ::edm::RefCore*)o)->isTransientInt)();
}

static  void method_13631( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefCore*)o)->pushBackItem)(*(const ::edm::RefCore*)arg[0],
    *(bool*)arg[1]);
}

static void method_newdel_3056( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefCore >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefCore >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefCore >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefCore >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefCore >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___edm__RefCore_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  const void* &cachePtr_ = *(const void**)(target + OffsetOf(__shadow__::__edm__RefCore, cachePtr_));

  //--- User's code ---
   
     edm::EDProductGetter::assignEDProductGetter(reinterpret_cast<edm::EDProductGetter const*&>(cachePtr_));
      
 
}

//------Dictionary for class RefCore -------------------------------
void __edm__RefCore_db_datamem(Reflex::Class*);
void __edm__RefCore_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefCore_datamem_bld(&__edm__RefCore_db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefCore_funcmem_bld(&__edm__RefCore_db_funcmem);
void __edm__RefCore_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "edm::RefCore";
  rule->fTarget      = "cachePtr_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___edm__RefCore_0);
  rule->fCode        = "\n   \n     edm::EDProductGetter::assignEDProductGetter(reinterpret_cast<edm::EDProductGetter const*&>(cachePtr_));\n      \n ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefCore"), typeid(::edm::RefCore), sizeof(::edm::RefCore), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddProperty("ioread", readrules )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefCore"), destructor_13610, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13563, type_13359), Reflex::Literal("operator="), operator_13611, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13359), Reflex::Literal("RefCore"), constructor_13612, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefCore"), constructor_13613, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_2845, type_13915, type_2811), Reflex::Literal("RefCore"), constructor_13614, 0, "theId;prodPtr;prodGetter;transient", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3056, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefCore_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefCore_funcmem_bld);
}

//------Delayed data member builder for class RefCore -------------------
void __edm__RefCore_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2845, Reflex::Literal("cachePtr_"), OffsetOf(__shadow__::__edm__RefCore, cachePtr_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2983, Reflex::Literal("processIndex_"), OffsetOf(__shadow__::__edm__RefCore, processIndex_), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_3105, Reflex::Literal("productIndex_"), OffsetOf(__shadow__::__edm__RefCore, productIndex_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefCore -------------------
void __edm__RefCore_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_13615, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("productPtr"), method_13616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2845), Reflex::Literal("setProductPtr"), method_13617, 0, "prodPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNull"), method_13618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNonnull"), method_13619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("operator!"), operator_13620, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_13621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_13622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13915), Reflex::Literal("setProductGetter"), method_13623, 0, "prodGetter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2904, type_2892), Reflex::Literal("getProductPtr"), method_13624, 0, "type", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892), Reflex::Literal("productNotFoundException"), method_13625, 0, "type", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_2892), Reflex::Literal("wrongTypeException"), method_13626, 0, "expectedType;actualType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892), Reflex::Literal("nullPointerForTransientException"), method_13627, 0, "type", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13563), Reflex::Literal("swap"), method_13628, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isTransient"), method_13629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_61), Reflex::Literal("isTransientInt"), method_13630, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13359, type_2811), Reflex::Literal("pushBackItem"), method_13631, 0, "productToBeInserted;checkPointer", ::Reflex::PUBLIC);
}
//------Stub functions for class RefVectorHolderBase -------------------------------
static  void operator_13642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefVectorHolderBase*)o)->operator=)(*(const ::edm::reftobase::RefVectorHolderBase*)arg[0]);
  else   (((::edm::reftobase::RefVectorHolderBase*)o)->operator=)(*(const ::edm::reftobase::RefVectorHolderBase*)arg[0]);
}

static void destructor_13645(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefVectorHolderBase*)o)->::edm::reftobase::RefVectorHolderBase::~RefVectorHolderBase)();
}
static  void method_13646( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefVectorHolderBase*)o)->swap)(*(::edm::reftobase::RefVectorHolderBase*)arg[0]);
}

static  void method_13647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefVectorHolderBase*)o)->empty)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->empty)();
}

static  void method_13648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefVectorHolderBase*)o)->size)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->size)();
}

static  void method_13649( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::reftobase::RefVectorHolderBase*)o)->clear)();
}

static  void method_13650( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefVectorHolderBase*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_13651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefVectorHolderBase*)o)->id)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->id)();
}

static  void method_13652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefVectorHolderBase*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->productGetter)();
}

static  void method_13653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefVectorHolderBase*)o)->clone)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->clone)();
}

static  void method_13654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefVectorHolderBase*)o)->cloneEmpty)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->cloneEmpty)();
}

static  void method_13655( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefVectorHolderBase*)o)->push_back)((const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_13656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::RefVectorHolderBase::const_iterator)((((const ::edm::reftobase::RefVectorHolderBase*)o)->begin)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->begin)();
}

static  void method_13657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::RefVectorHolderBase::const_iterator)((((const ::edm::reftobase::RefVectorHolderBase*)o)->end)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->end)();
}

static  void method_13658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefVectorHolderBase*)o)->product)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->product)();
}

static  void method_13659( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefVectorHolderBase*)o)->reallyFillView)((const void*)arg[0],
    *(const ::edm::ProductID*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_13660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefVectorHolderBase*)o)->keyForIndex)(*(::size_t*)arg[0]));
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->keyForIndex)(*(::size_t*)arg[0]);
}

static  void method_13661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefVectorHolderBase*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefVectorHolderBase*)o)->isAvailable)();
}

//------Dictionary for class RefVectorHolderBase -------------------------------
void __edm__reftobase__RefVectorHolderBase_db_datamem(Reflex::Class*);
void __edm__reftobase__RefVectorHolderBase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefVectorHolderBase_datamem_bld(&__edm__reftobase__RefVectorHolderBase_db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefVectorHolderBase_funcmem_bld(&__edm__reftobase__RefVectorHolderBase_db_funcmem);
void __edm__reftobase__RefVectorHolderBase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"), typeid(::edm::reftobase::RefVectorHolderBase), sizeof(::edm::reftobase::RefVectorHolderBase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_1489, Reflex::Literal("edm::reftobase::RefVectorHolderBase::size_type"))
  .AddTypedef(type_6785, Reflex::Literal("edm::reftobase::RefVectorHolderBase::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13940, type_23292), Reflex::Literal("operator="), operator_13642, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorHolderBase"), destructor_13645, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefVectorHolderBase_funcmem_bld);
}

//------Delayed data member builder for class RefVectorHolderBase -------------------
void __edm__reftobase__RefVectorHolderBase_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RefVectorHolderBase -------------------
void __edm__reftobase__RefVectorHolderBase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13940), Reflex::Literal("swap"), method_13646, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_13647, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_13648, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_13649, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_1489), Reflex::Literal("reserve"), method_13650, 0, "n", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_13651, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_13652, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13938), Reflex::Literal("clone"), method_13653, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13938), Reflex::Literal("cloneEmpty"), method_13654, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23293), Reflex::Literal("push_back"), method_13655, 0, "r", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13641), Reflex::Literal("begin"), method_13656, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13641), Reflex::Literal("end"), method_13657, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("product"), method_13658, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2845, type_12510, type_22439), Reflex::Literal("reallyFillView"), method_13659, 0, ";;", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489, type_1489), Reflex::Literal("keyForIndex"), method_13660, 0, "idx", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_13661, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class RefVectorBase<long unsigned int> -------------------------------
static void constructor_13757( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned long>();
  else ::new(mem) ::edm::RefVectorBase<unsigned long>();
}

static void constructor_13758( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned long>(*(const ::edm::RefVectorBase<unsigned long>*)arg[0]);
  else ::new(mem) ::edm::RefVectorBase<unsigned long>(*(const ::edm::RefVectorBase<unsigned long>*)arg[0]);
}

static void constructor_13759( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned long>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVectorBase<unsigned long>(*(const ::edm::ProductID*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned long>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1]);
  else ::new(mem) ::edm::RefVectorBase<unsigned long>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned long>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::RefVectorBase<unsigned long>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  }
}

static void destructor_13760(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVectorBase<unsigned long>*)o)->::edm::RefVectorBase<unsigned long>::~RefVectorBase)();
}
static  void method_13761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVectorBase<unsigned long>*)o)->refCore)();
  else   (((const ::edm::RefVectorBase<unsigned long>*)o)->refCore)();
}

static  void method_13762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVectorBase<unsigned long>*)o)->keys)();
  else   (((const ::edm::RefVectorBase<unsigned long>*)o)->keys)();
}

static  void method_13763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorBase<unsigned long>*)o)->empty)());
  else   (((const ::edm::RefVectorBase<unsigned long>*)o)->empty)();
}

static  void method_13764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVectorBase<unsigned long>*)o)->size)());
  else   (((const ::edm::RefVectorBase<unsigned long>*)o)->size)();
}

static  void method_13765( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVectorBase<unsigned long>*)o)->pushBack)(*(const ::edm::RefCore*)arg[0],
    *(const unsigned long*)arg[1]);
}

static  void method_13766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVectorBase<unsigned long>*)o)->capacity)());
  else   (((const ::edm::RefVectorBase<unsigned long>*)o)->capacity)();
}

static  void method_13767( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVectorBase<unsigned long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_13768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::edm::RefVectorBase<unsigned long>*)o)->eraseAtIndex)(*(::std::size_t*)arg[0]));
  else   (((::edm::RefVectorBase<unsigned long>*)o)->eraseAtIndex)(*(::std::size_t*)arg[0]);
}

static  void method_13769( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVectorBase<unsigned long>*)o)->clear)();
}

static  void method_13770( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVectorBase<unsigned long>*)o)->swap)(*(::edm::RefVectorBase<unsigned long>*)arg[0]);
}

static  void operator_13771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorBase<unsigned long>*)o)->operator=)(*(const ::edm::RefVectorBase<unsigned long>*)arg[0]);
  else   (((::edm::RefVectorBase<unsigned long>*)o)->operator=)(*(const ::edm::RefVectorBase<unsigned long>*)arg[0]);
}

static  void method_13772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVectorBase<unsigned long>*)o)->Class_Version)());
  else   (((::edm::RefVectorBase<unsigned long>*)o)->Class_Version)();
}

static void method_newdel_3069( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVectorBase<long unsigned int> -------------------------------
void __edm__RefVectorBase_unsignedslong__db_datamem(Reflex::Class*);
void __edm__RefVectorBase_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVectorBase_unsignedslong__datamem_bld(&__edm__RefVectorBase_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVectorBase_unsignedslong__funcmem_bld(&__edm__RefVectorBase_unsignedslong__db_funcmem);
void __edm__RefVectorBase_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVectorBase<unsigned long>"), typeid(::edm::RefVectorBase<unsigned long>), sizeof(::edm::RefVectorBase<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVectorBase<unsigned long>::Class_Version())
  .AddTypedef(type_2278, Reflex::Literal("edm::RefVectorBase<unsigned long>::keys_type"))
  .AddTypedef(type_228, Reflex::Literal("edm::RefVectorBase<unsigned long>::key_type"))
  .AddTypedef(type_2504, Reflex::Literal("edm::RefVectorBase<unsigned long>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorBase"), constructor_13757, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23303), Reflex::Literal("RefVectorBase"), constructor_13758, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_2845, type_13915), Reflex::Literal("RefVectorBase"), constructor_13759, 0, "productID;prodPtr=0;prodGetter=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorBase"), destructor_13760, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3069, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVectorBase_unsignedslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVectorBase_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class RefVectorBase<long unsigned int> -------------------
void __edm__RefVectorBase_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3056, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefVectorBase_unsignedslong_, product_), ::Reflex::PRIVATE)
  .AddDataMember(type_2278, Reflex::Literal("keys_"), OffsetOf(__shadow__::__edm__RefVectorBase_unsignedslong_, keys_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorBase<long unsigned int> -------------------
void __edm__RefVectorBase_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13359), Reflex::Literal("refCore"), method_13761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22440), Reflex::Literal("keys"), method_13762, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_13763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("size"), method_13764, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13359, type_5085), Reflex::Literal("pushBack"), method_13765, 0, "product;key", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("capacity"), method_13766, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504), Reflex::Literal("reserve"), method_13767, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3605, type_2504), Reflex::Literal("eraseAtIndex"), method_13768, 0, "index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_13769, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23304), Reflex::Literal("swap"), method_13770, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23304, type_23303), Reflex::Literal("operator="), operator_13771, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_13772, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVectorBase<unsigned int> -------------------------------
static void constructor_13778( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned int>();
  else ::new(mem) ::edm::RefVectorBase<unsigned int>();
}

static void constructor_13779( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned int>(*(const ::edm::RefVectorBase<unsigned int>*)arg[0]);
  else ::new(mem) ::edm::RefVectorBase<unsigned int>(*(const ::edm::RefVectorBase<unsigned int>*)arg[0]);
}

static void constructor_13780( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned int>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVectorBase<unsigned int>(*(const ::edm::ProductID*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned int>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1]);
  else ::new(mem) ::edm::RefVectorBase<unsigned int>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<unsigned int>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::RefVectorBase<unsigned int>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  }
}

static void destructor_13781(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVectorBase<unsigned int>*)o)->::edm::RefVectorBase<unsigned int>::~RefVectorBase)();
}
static  void method_13782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVectorBase<unsigned int>*)o)->refCore)();
  else   (((const ::edm::RefVectorBase<unsigned int>*)o)->refCore)();
}

static  void method_13783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVectorBase<unsigned int>*)o)->keys)();
  else   (((const ::edm::RefVectorBase<unsigned int>*)o)->keys)();
}

static  void method_13784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorBase<unsigned int>*)o)->empty)());
  else   (((const ::edm::RefVectorBase<unsigned int>*)o)->empty)();
}

static  void method_13785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVectorBase<unsigned int>*)o)->size)());
  else   (((const ::edm::RefVectorBase<unsigned int>*)o)->size)();
}

static  void method_13786( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVectorBase<unsigned int>*)o)->pushBack)(*(const ::edm::RefCore*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_13787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVectorBase<unsigned int>*)o)->capacity)());
  else   (((const ::edm::RefVectorBase<unsigned int>*)o)->capacity)();
}

static  void method_13788( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVectorBase<unsigned int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_13789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::edm::RefVectorBase<unsigned int>*)o)->eraseAtIndex)(*(::std::size_t*)arg[0]));
  else   (((::edm::RefVectorBase<unsigned int>*)o)->eraseAtIndex)(*(::std::size_t*)arg[0]);
}

static  void method_13790( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVectorBase<unsigned int>*)o)->clear)();
}

static  void method_13791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVectorBase<unsigned int>*)o)->swap)(*(::edm::RefVectorBase<unsigned int>*)arg[0]);
}

static  void operator_13792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorBase<unsigned int>*)o)->operator=)(*(const ::edm::RefVectorBase<unsigned int>*)arg[0]);
  else   (((::edm::RefVectorBase<unsigned int>*)o)->operator=)(*(const ::edm::RefVectorBase<unsigned int>*)arg[0]);
}

static  void method_13793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVectorBase<unsigned int>*)o)->Class_Version)());
  else   (((::edm::RefVectorBase<unsigned int>*)o)->Class_Version)();
}

static void method_newdel_3070( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVectorBase<unsigned int> -------------------------------
void __edm__RefVectorBase_unsignedsint__db_datamem(Reflex::Class*);
void __edm__RefVectorBase_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVectorBase_unsignedsint__datamem_bld(&__edm__RefVectorBase_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVectorBase_unsignedsint__funcmem_bld(&__edm__RefVectorBase_unsignedsint__db_funcmem);
void __edm__RefVectorBase_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVectorBase<unsigned int>"), typeid(::edm::RefVectorBase<unsigned int>), sizeof(::edm::RefVectorBase<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVectorBase<unsigned int>::Class_Version())
  .AddTypedef(type_2285, Reflex::Literal("edm::RefVectorBase<unsigned int>::keys_type"))
  .AddTypedef(type_235, Reflex::Literal("edm::RefVectorBase<unsigned int>::key_type"))
  .AddTypedef(type_2504, Reflex::Literal("edm::RefVectorBase<unsigned int>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorBase"), constructor_13778, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23000), Reflex::Literal("RefVectorBase"), constructor_13779, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_2845, type_13915), Reflex::Literal("RefVectorBase"), constructor_13780, 0, "productID;prodPtr=0;prodGetter=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorBase"), destructor_13781, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3070, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVectorBase_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVectorBase_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class RefVectorBase<unsigned int> -------------------
void __edm__RefVectorBase_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3056, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefVectorBase_unsignedsint_, product_), ::Reflex::PRIVATE)
  .AddDataMember(type_2285, Reflex::Literal("keys_"), OffsetOf(__shadow__::__edm__RefVectorBase_unsignedsint_, keys_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorBase<unsigned int> -------------------
void __edm__RefVectorBase_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13359), Reflex::Literal("refCore"), method_13782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22458), Reflex::Literal("keys"), method_13783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_13784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("size"), method_13785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13359, type_5054), Reflex::Literal("pushBack"), method_13786, 0, "product;key", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("capacity"), method_13787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504), Reflex::Literal("reserve"), method_13788, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3600, type_2504), Reflex::Literal("eraseAtIndex"), method_13789, 0, "index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_13790, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23305), Reflex::Literal("swap"), method_13791, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23305, type_23000), Reflex::Literal("operator="), operator_13792, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_13793, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVectorBase<int> -------------------------------
static void constructor_13799( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<int>();
  else ::new(mem) ::edm::RefVectorBase<int>();
}

static void constructor_13800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<int>(*(const ::edm::RefVectorBase<int>*)arg[0]);
  else ::new(mem) ::edm::RefVectorBase<int>(*(const ::edm::RefVectorBase<int>*)arg[0]);
}

static void constructor_13801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<int>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVectorBase<int>(*(const ::edm::ProductID*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<int>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1]);
  else ::new(mem) ::edm::RefVectorBase<int>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVectorBase<int>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::RefVectorBase<int>(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  }
}

static void destructor_13802(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVectorBase<int>*)o)->::edm::RefVectorBase<int>::~RefVectorBase)();
}
static  void method_13803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVectorBase<int>*)o)->refCore)();
  else   (((const ::edm::RefVectorBase<int>*)o)->refCore)();
}

static  void method_13804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVectorBase<int>*)o)->keys)();
  else   (((const ::edm::RefVectorBase<int>*)o)->keys)();
}

static  void method_13805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVectorBase<int>*)o)->empty)());
  else   (((const ::edm::RefVectorBase<int>*)o)->empty)();
}

static  void method_13806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVectorBase<int>*)o)->size)());
  else   (((const ::edm::RefVectorBase<int>*)o)->size)();
}

static  void method_13807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVectorBase<int>*)o)->pushBack)(*(const ::edm::RefCore*)arg[0],
    *(const int*)arg[1]);
}

static  void method_13808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVectorBase<int>*)o)->capacity)());
  else   (((const ::edm::RefVectorBase<int>*)o)->capacity)();
}

static  void method_13809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVectorBase<int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_13810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::edm::RefVectorBase<int>*)o)->eraseAtIndex)(*(::std::size_t*)arg[0]));
  else   (((::edm::RefVectorBase<int>*)o)->eraseAtIndex)(*(::std::size_t*)arg[0]);
}

static  void method_13811( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVectorBase<int>*)o)->clear)();
}

static  void method_13812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVectorBase<int>*)o)->swap)(*(::edm::RefVectorBase<int>*)arg[0]);
}

static  void operator_13813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVectorBase<int>*)o)->operator=)(*(const ::edm::RefVectorBase<int>*)arg[0]);
  else   (((::edm::RefVectorBase<int>*)o)->operator=)(*(const ::edm::RefVectorBase<int>*)arg[0]);
}

static  void method_13814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVectorBase<int>*)o)->Class_Version)());
  else   (((::edm::RefVectorBase<int>*)o)->Class_Version)();
}

static void method_newdel_3071( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVectorBase<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVectorBase<int> -------------------------------
void __edm__RefVectorBase_int__db_datamem(Reflex::Class*);
void __edm__RefVectorBase_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVectorBase_int__datamem_bld(&__edm__RefVectorBase_int__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVectorBase_int__funcmem_bld(&__edm__RefVectorBase_int__db_funcmem);
void __edm__RefVectorBase_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVectorBase<int>"), typeid(::edm::RefVectorBase<int>), sizeof(::edm::RefVectorBase<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVectorBase<int>::Class_Version())
  .AddTypedef(type_2286, Reflex::Literal("edm::RefVectorBase<int>::keys_type"))
  .AddTypedef(type_61, Reflex::Literal("edm::RefVectorBase<int>::key_type"))
  .AddTypedef(type_2504, Reflex::Literal("edm::RefVectorBase<int>::size_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVectorBase"), constructor_13799, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23306), Reflex::Literal("RefVectorBase"), constructor_13800, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_2845, type_13915), Reflex::Literal("RefVectorBase"), constructor_13801, 0, "productID;prodPtr=0;prodGetter=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVectorBase"), destructor_13802, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3071, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVectorBase_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVectorBase_int__funcmem_bld);
}

//------Delayed data member builder for class RefVectorBase<int> -------------------
void __edm__RefVectorBase_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3056, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefVectorBase_int_, product_), ::Reflex::PRIVATE)
  .AddDataMember(type_2286, Reflex::Literal("keys_"), OffsetOf(__shadow__::__edm__RefVectorBase_int_, keys_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVectorBase<int> -------------------
void __edm__RefVectorBase_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13359), Reflex::Literal("refCore"), method_13803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18063), Reflex::Literal("keys"), method_13804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_13805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("size"), method_13806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13359, type_5032), Reflex::Literal("pushBack"), method_13807, 0, "product;key", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2504), Reflex::Literal("capacity"), method_13808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2504), Reflex::Literal("reserve"), method_13809, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3592, type_2504), Reflex::Literal("eraseAtIndex"), method_13810, 0, "index", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_13811, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23307), Reflex::Literal("swap"), method_13812, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23307, type_23306), Reflex::Literal("operator="), operator_13813, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_13814, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<int> -------------------------------
static  void operator_13882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<int>*)o)->operator=)(*(const ::edm::Ptr<int>*)arg[0]);
  else   (((::edm::Ptr<int>*)o)->operator=)(*(const ::edm::Ptr<int>*)arg[0]);
}

static void constructor_13883( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<int>(*(const ::edm::Ptr<int>*)arg[0]);
  else ::new(mem) ::edm::Ptr<int>(*(const ::edm::Ptr<int>*)arg[0]);
}

static void constructor_13884( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<int>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<int>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_13885( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<int>(*(const ::edm::ProductID*)arg[0],
      (const int*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<int>(*(const ::edm::ProductID*)arg[0],
      (const int*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_13886( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<int>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<int>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_13887( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<int>();
  else ::new(mem) ::edm::Ptr<int>();
}

static void destructor_13888(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<int>*)o)->::edm::Ptr<int>::~Ptr)();
}
static  void operator_13889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<int>*)o)->operator*)();
  else   (((const ::edm::Ptr<int>*)o)->operator*)();
}

static  void operator_13890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<int>*)o)->operator->)());
  else   (((const ::edm::Ptr<int>*)o)->operator->)();
}

static  void method_13891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<int>*)o)->get)());
  else   (((const ::edm::Ptr<int>*)o)->get)();
}

static  void method_13892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<int>*)o)->isNull)());
  else   (((const ::edm::Ptr<int>*)o)->isNull)();
}

static  void method_13893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<int>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<int>*)o)->isNonnull)();
}

static  void operator_13894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<int>*)o)->operator!)());
  else   (((const ::edm::Ptr<int>*)o)->operator!)();
}

static  void method_13895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<int>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<int>*)o)->isAvailable)();
}

static  void method_13896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<int>*)o)->isTransient)());
  else   (((const ::edm::Ptr<int>*)o)->isTransient)();
}

static  void method_13897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<int>*)o)->id)());
  else   (((const ::edm::Ptr<int>*)o)->id)();
}

static  void method_13898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<int>*)o)->productGetter)());
  else   (((const ::edm::Ptr<int>*)o)->productGetter)();
}

static  void method_13899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<int>*)o)->key)());
  else   (((const ::edm::Ptr<int>*)o)->key)();
}

static  void method_13900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<int>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<int>*)o)->hasProductCache)();
}

static  void method_13901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<int>*)o)->refCore)();
  else   (((const ::edm::Ptr<int>*)o)->refCore)();
}

static  void method_13902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<int>*)o)->product)());
  else   (((const ::edm::Ptr<int>*)o)->product)();
}

static  void method_13903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<int>*)o)->Class_Version)());
  else   (((::edm::Ptr<int>*)o)->Class_Version)();
}

static void method_newdel_3084( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<int> -------------------------------
void __edm__Ptr_int__db_datamem(Reflex::Class*);
void __edm__Ptr_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_int__datamem_bld(&__edm__Ptr_int__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_int__funcmem_bld(&__edm__Ptr_int__db_funcmem);
void __edm__Ptr_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<int>"), typeid(::edm::Ptr<int>), sizeof(::edm::Ptr<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<int>::Class_Version())
  .AddTypedef(type_228, Reflex::Literal("edm::Ptr<int>::key_type"))
  .AddTypedef(type_61, Reflex::Literal("edm::Ptr<int>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23317, type_22994), Reflex::Literal("operator="), operator_13882, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22994), Reflex::Literal("Ptr"), constructor_13883, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_228, type_13915), Reflex::Literal("Ptr"), constructor_13884, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_5030, type_228), Reflex::Literal("Ptr"), constructor_13885, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510), Reflex::Literal("Ptr"), constructor_13886, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_13887, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_13888, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3084, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_int__funcmem_bld);
}

//------Delayed data member builder for class Ptr<int> -------------------
void __edm__Ptr_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3056, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_int_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_228, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_int_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<int> -------------------
void __edm__Ptr_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5032), Reflex::Literal("operator*"), operator_13889, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5030), Reflex::Literal("operator->"), operator_13890, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5030), Reflex::Literal("get"), method_13891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNull"), method_13892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNonnull"), method_13893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("operator!"), operator_13894, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_13895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isTransient"), method_13896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_13897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_13898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_228), Reflex::Literal("key"), method_13899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("hasProductCache"), method_13900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13359), Reflex::Literal("refCore"), method_13901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("product"), method_13902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_13903, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class DoNotSortUponInsertion -------------------------------
static void destructor_13906(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::DoNotSortUponInsertion*)o)->::edm::DoNotSortUponInsertion::~DoNotSortUponInsertion)();
}
static  void operator_13907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::DoNotSortUponInsertion*)o)->operator=)(*(const ::edm::DoNotSortUponInsertion*)arg[0]);
  else   (((::edm::DoNotSortUponInsertion*)o)->operator=)(*(const ::edm::DoNotSortUponInsertion*)arg[0]);
}

static void constructor_13908( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DoNotSortUponInsertion(*(const ::edm::DoNotSortUponInsertion*)arg[0]);
  else ::new(mem) ::edm::DoNotSortUponInsertion(*(const ::edm::DoNotSortUponInsertion*)arg[0]);
}

static void constructor_13909( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::DoNotSortUponInsertion();
  else ::new(mem) ::edm::DoNotSortUponInsertion();
}

static void method_newdel_3085( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::DoNotSortUponInsertion >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::DoNotSortUponInsertion >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::DoNotSortUponInsertion >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::DoNotSortUponInsertion >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::DoNotSortUponInsertion >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class DoNotSortUponInsertion -------------------------------
void __edm__DoNotSortUponInsertion_db_datamem(Reflex::Class*);
void __edm__DoNotSortUponInsertion_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__DoNotSortUponInsertion_datamem_bld(&__edm__DoNotSortUponInsertion_db_datamem);
Reflex::GenreflexMemberBuilder __edm__DoNotSortUponInsertion_funcmem_bld(&__edm__DoNotSortUponInsertion_db_funcmem);
void __edm__DoNotSortUponInsertion_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::DoNotSortUponInsertion"), typeid(::edm::DoNotSortUponInsertion), sizeof(::edm::DoNotSortUponInsertion), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~DoNotSortUponInsertion"), destructor_13906, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23318, type_23319), Reflex::Literal("operator="), operator_13907, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23319), Reflex::Literal("DoNotSortUponInsertion"), constructor_13908, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("DoNotSortUponInsertion"), constructor_13909, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3085, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class DoNotSortUponInsertion -------------------
void __edm__DoNotSortUponInsertion_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class DoNotSortUponInsertion -------------------
void __edm__DoNotSortUponInsertion_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Other -------------------------------
static void destructor_13910(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Other*)o)->::edm::Other::~Other)();
}
static  void operator_13911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Other*)o)->operator=)(*(const ::edm::Other*)arg[0]);
  else   (((::edm::Other*)o)->operator=)(*(const ::edm::Other*)arg[0]);
}

static void constructor_13912( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Other(*(const ::edm::Other*)arg[0]);
  else ::new(mem) ::edm::Other(*(const ::edm::Other*)arg[0]);
}

static void constructor_13913( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Other();
  else ::new(mem) ::edm::Other();
}

static void method_newdel_3086( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Other >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Other >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Other >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Other >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Other >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Other -------------------------------
void __edm__Other_db_datamem(Reflex::Class*);
void __edm__Other_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Other_datamem_bld(&__edm__Other_db_datamem);
Reflex::GenreflexMemberBuilder __edm__Other_funcmem_bld(&__edm__Other_db_funcmem);
void __edm__Other_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Other"), typeid(::edm::Other), sizeof(::edm::Other), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Other"), destructor_13910, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23320, type_23321), Reflex::Literal("operator="), operator_13911, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23321), Reflex::Literal("Other"), constructor_13912, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Other"), constructor_13913, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3086, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class Other -------------------
void __edm__Other_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class Other -------------------
void __edm__Other_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class EDProductGetter -------------------------------
static void destructor_13973(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::EDProductGetter*)o)->::edm::EDProductGetter::~EDProductGetter)();
}
static  void method_13974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::WrapperHolder)((((const ::edm::EDProductGetter*)o)->getIt)(*(const ::edm::ProductID*)arg[0]));
  else   (((const ::edm::EDProductGetter*)o)->getIt)(*(const ::edm::ProductID*)arg[0]);
}

static  void method_13975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::EDProductGetter*)o)->switchProductGetter)((const ::edm::EDProductGetter*)arg[0]));
  else   (((::edm::EDProductGetter*)o)->switchProductGetter)((const ::edm::EDProductGetter*)arg[0]);
}

static  void method_13976( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::EDProductGetter*)o)->assignEDProductGetter)(*(const ::edm::EDProductGetter**)arg[0]);
}

static void method_x63( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("boost::noncopyable_::noncopyable")), ::Reflex::BaseOffset< ::edm::EDProductGetter,::boost::noncopyable_::noncopyable >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class EDProductGetter -------------------------------
void __edm__EDProductGetter_db_datamem(Reflex::Class*);
void __edm__EDProductGetter_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__EDProductGetter_datamem_bld(&__edm__EDProductGetter_db_datamem);
Reflex::GenreflexMemberBuilder __edm__EDProductGetter_funcmem_bld(&__edm__EDProductGetter_db_funcmem);
void __edm__EDProductGetter_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::EDProductGetter"), typeid(::edm::EDProductGetter), sizeof(::edm::EDProductGetter), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_4621, ::Reflex::BaseOffset< ::edm::EDProductGetter, ::boost::noncopyable_::noncopyable >::Get(), ::Reflex::PRIVATE)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EDProductGetter"), destructor_13973, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x63, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__EDProductGetter_funcmem_bld);
}

//------Delayed data member builder for class EDProductGetter -------------------
void __edm__EDProductGetter_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class EDProductGetter -------------------
void __edm__EDProductGetter_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2904, type_12510), Reflex::Literal("getIt"), method_13974, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915, type_13915), Reflex::Literal("switchProductGetter"), method_13975, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23328), Reflex::Literal("assignEDProductGetter"), method_13976, 0, "", ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<int, std::allocator<int> >,int,edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > -------------------------------
static  void operator_13988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator=)(*(const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
  else   (((::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator=)(*(const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
}

static void constructor_13989( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
}

static void constructor_13990( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >();
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >();
}

static void constructor_13991( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::Handle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::Handle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::Handle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::Handle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_13992( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::OrphanHandle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::OrphanHandle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::OrphanHandle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::OrphanHandle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_13993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_13994( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >((const ::std::vector<int>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >((const ::std::vector<int>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >((const ::std::vector<int>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >((const ::std::vector<int>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_13995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::TestHandle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::TestHandle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::TestHandle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::TestHandle<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_13996( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_13997( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::ProductID*)arg[0],
      (const int*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<int>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::ProductID*)arg[0],
      (const int*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<int>*)arg[3]);
}

static void constructor_13998( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_13999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefProd<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefProd<std::vector<int> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_14000(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::~Ref)();
}
static  void operator_14001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator*)();
}

static  void operator_14002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator->)();
}

static  void method_14003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->get)();
}

static  void method_14004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isNull)();
}

static  void method_14005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isNonnull)();
}

static  void operator_14006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->operator!)();
}

static  void method_14007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->id)();
}

static  void method_14008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->productGetter)();
}

static  void method_14009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->product)();
}

static  void method_14010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->key)();
}

static  void method_14011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->index)();
}

static  void method_14012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->hasProductCache)();
}

static  void method_14013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isAvailable)();
}

static  void method_14014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->isTransient)();
}

static  void method_14015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->refCore)();
}

static  void method_14016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)o)->Class_Version)();
}

static void constructor_14017( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_3104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<int, std::allocator<int> >,int,edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > -------------------------------
void __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__datamem_bld(&__edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__funcmem_bld(&__edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_funcmem);
void __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >"), typeid(::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >), sizeof(::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::Class_Version())
  .AddTypedef(type_61, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::T"))
  .AddTypedef(type_12700, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::F"))
  .AddTypedef(type_12699, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::VF"))
  .AddTypedef(type_12698, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::VBF"))
  .AddTypedef(type_2286, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::product_type"))
  .AddTypedef(type_61, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::value_type"))
  .AddTypedef(type_61c, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::element_type"))
  .AddTypedef(type_12700, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::finder_type"))
  .AddTypedef(type_235, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::argument_type"))
  .AddTypedef(type_235, Reflex::Literal("edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23329, type_22999), Reflex::Literal("operator="), operator_13988, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22999), Reflex::Literal("Ref"), constructor_13989, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_13990, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23330, type_235, type_2811), Reflex::Literal("Ref"), constructor_13991, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23331, type_235, type_2811), Reflex::Literal("Ref"), constructor_13992, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22998, type_235, type_2811), Reflex::Literal("Ref"), constructor_13993, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23001, type_235, type_2811), Reflex::Literal("Ref"), constructor_13994, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23332, type_235, type_2811), Reflex::Literal("Ref"), constructor_13995, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_235, type_13915), Reflex::Literal("Ref"), constructor_13996, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_5030, type_235, type_23001), Reflex::Literal("Ref"), constructor_13997, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510), Reflex::Literal("Ref"), constructor_13998, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23333, type_235), Reflex::Literal("Ref"), constructor_13999, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_14000, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13359, type_5054), Reflex::Literal("Ref"), constructor_14017, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<int, std::allocator<int> >,int,edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > -------------------
void __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3116, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<int, std::allocator<int> >,int,edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > -------------------
void __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5032), Reflex::Literal("operator*"), operator_14001, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5030), Reflex::Literal("operator->"), operator_14002, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5030), Reflex::Literal("get"), method_14003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNull"), method_14004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNonnull"), method_14005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("operator!"), operator_14006, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_14007, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_14008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23001), Reflex::Literal("product"), method_14009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("key"), method_14010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("index"), method_14011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("hasProductCache"), method_14012, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_14013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isTransient"), method_14014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13359), Reflex::Literal("refCore"), method_14015, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_14016, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefCoreWithIndex -------------------------------
static void destructor_14038(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefCoreWithIndex*)o)->::edm::RefCoreWithIndex::~RefCoreWithIndex)();
}
static  void operator_14039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefCoreWithIndex*)o)->operator=)(*(const ::edm::RefCoreWithIndex*)arg[0]);
  else   (((::edm::RefCoreWithIndex*)o)->operator=)(*(const ::edm::RefCoreWithIndex*)arg[0]);
}

static void constructor_14040( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefCoreWithIndex(*(const ::edm::RefCoreWithIndex*)arg[0]);
  else ::new(mem) ::edm::RefCoreWithIndex(*(const ::edm::RefCoreWithIndex*)arg[0]);
}

static void constructor_14041( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefCoreWithIndex();
  else ::new(mem) ::edm::RefCoreWithIndex();
}

static void constructor_14042( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefCoreWithIndex(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2],
      *(bool*)arg[3],
      *(unsigned int*)arg[4]);
  else ::new(mem) ::edm::RefCoreWithIndex(*(const ::edm::ProductID*)arg[0],
      (const void*)arg[1],
      (const ::edm::EDProductGetter*)arg[2],
      *(bool*)arg[3],
      *(unsigned int*)arg[4]);
}

static void constructor_14043( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefCoreWithIndex(*(const ::edm::RefCore*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::RefCoreWithIndex(*(const ::edm::RefCore*)arg[0],
      *(unsigned int*)arg[1]);
}

static  void method_14044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefCoreWithIndex*)o)->id)());
  else   (((const ::edm::RefCoreWithIndex*)o)->id)();
}

static  void method_14045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefCoreWithIndex*)o)->productPtr)());
  else   (((const ::edm::RefCoreWithIndex*)o)->productPtr)();
}

static  void method_14046( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCoreWithIndex*)o)->setProductPtr)((const void*)arg[0]);
}

static  void method_14047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::RefCoreWithIndex*)o)->index)());
  else   (((const ::edm::RefCoreWithIndex*)o)->index)();
}

static  void method_14048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCoreWithIndex*)o)->isNull)());
  else   (((const ::edm::RefCoreWithIndex*)o)->isNull)();
}

static  void method_14049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCoreWithIndex*)o)->isNonnull)());
  else   (((const ::edm::RefCoreWithIndex*)o)->isNonnull)();
}

static  void operator_14050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCoreWithIndex*)o)->operator!)());
  else   (((const ::edm::RefCoreWithIndex*)o)->operator!)();
}

static  void method_14051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCoreWithIndex*)o)->isAvailable)());
  else   (((const ::edm::RefCoreWithIndex*)o)->isAvailable)();
}

static  void method_14052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefCoreWithIndex*)o)->toRefCore)();
  else   (((const ::edm::RefCoreWithIndex*)o)->toRefCore)();
}

static  void method_14053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefCoreWithIndex*)o)->productGetter)());
  else   (((const ::edm::RefCoreWithIndex*)o)->productGetter)();
}

static  void method_14054( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCoreWithIndex*)o)->setProductGetter)((const ::edm::EDProductGetter*)arg[0]);
}

static  void method_14055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::WrapperHolder)((((const ::edm::RefCoreWithIndex*)o)->getProductPtr)(*(const ::std::type_info*)arg[0]));
  else   (((const ::edm::RefCoreWithIndex*)o)->getProductPtr)(*(const ::std::type_info*)arg[0]);
}

static  void method_14056( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCoreWithIndex*)o)->productNotFoundException)(*(const ::std::type_info*)arg[0]);
}

static  void method_14057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCoreWithIndex*)o)->wrongTypeException)(*(const ::std::type_info*)arg[0],
    *(const ::std::type_info*)arg[1]);
}

static  void method_14058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefCoreWithIndex*)o)->nullPointerForTransientException)(*(const ::std::type_info*)arg[0]);
}

static  void method_14059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefCoreWithIndex*)o)->swap)(*(::edm::RefCoreWithIndex*)arg[0]);
}

static  void method_14060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefCoreWithIndex*)o)->isTransient)());
  else   (((const ::edm::RefCoreWithIndex*)o)->isTransient)();
}

static  void method_14061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::edm::RefCoreWithIndex*)o)->isTransientInt)());
  else   (((const ::edm::RefCoreWithIndex*)o)->isTransientInt)();
}

static  void method_14062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefCoreWithIndex*)o)->pushBackItem)(*(const ::edm::RefCoreWithIndex*)arg[0],
    *(bool*)arg[1]);
}

static void method_newdel_3116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefCoreWithIndex >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefCoreWithIndex >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefCoreWithIndex >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefCoreWithIndex >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefCoreWithIndex >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

void read___edm__RefCoreWithIndex_0( char *target, TVirtualObject *oldObj )
{
  //--- Variables added by the code generator ---
#if 0
  static int id_ = oldObj->GetId("");
#endif
  const void* &cachePtr_ = *(const void**)(target + OffsetOf(__shadow__::__edm__RefCoreWithIndex, cachePtr_));

  //--- User's code ---
    
      edm::EDProductGetter::assignEDProductGetter(reinterpret_cast<edm::EDProductGetter const*&>(cachePtr_));
    
  
}

//------Dictionary for class RefCoreWithIndex -------------------------------
void __edm__RefCoreWithIndex_db_datamem(Reflex::Class*);
void __edm__RefCoreWithIndex_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefCoreWithIndex_datamem_bld(&__edm__RefCoreWithIndex_db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefCoreWithIndex_funcmem_bld(&__edm__RefCoreWithIndex_db_funcmem);
void __edm__RefCoreWithIndex_dict() {
  ROOT::TSchemaHelper* rule;
  // the io read rules
  std::vector<ROOT::TSchemaHelper> readrules(1);
  rule = &readrules[0];
  rule->fSourceClass = "edm::RefCoreWithIndex";
  rule->fTarget      = "cachePtr_";
  rule->fSource      = "";
  rule->fFunctionPtr = Reflex::BuilderFunc2Void(read___edm__RefCoreWithIndex_0);
  rule->fCode        = "\n    \n      edm::EDProductGetter::assignEDProductGetter(reinterpret_cast<edm::EDProductGetter const*&>(cachePtr_));\n    \n  ";
  rule->fVersion     = "[1-]";


  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefCoreWithIndex"), typeid(::edm::RefCoreWithIndex), sizeof(::edm::RefCoreWithIndex), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddProperty("ioread", readrules )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefCoreWithIndex"), destructor_14038, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13562, type_23335), Reflex::Literal("operator="), operator_14039, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23335), Reflex::Literal("RefCoreWithIndex"), constructor_14040, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefCoreWithIndex"), constructor_14041, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510, type_2845, type_13915, type_2811, type_235), Reflex::Literal("RefCoreWithIndex"), constructor_14042, 0, "theId;prodPtr;prodGetter;transient;elementIndex", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13359, type_235), Reflex::Literal("RefCoreWithIndex"), constructor_14043, 0, "iCore;", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefCoreWithIndex_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefCoreWithIndex_funcmem_bld);
}

//------Delayed data member builder for class RefCoreWithIndex -------------------
void __edm__RefCoreWithIndex_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2845, Reflex::Literal("cachePtr_"), OffsetOf(__shadow__::__edm__RefCoreWithIndex, cachePtr_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2983, Reflex::Literal("processIndex_"), OffsetOf(__shadow__::__edm__RefCoreWithIndex, processIndex_), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_3105, Reflex::Literal("productIndex_"), OffsetOf(__shadow__::__edm__RefCoreWithIndex, productIndex_), ::Reflex::PRIVATE)
  .AddDataMember(type_235, Reflex::Literal("elementIndex_"), OffsetOf(__shadow__::__edm__RefCoreWithIndex, elementIndex_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefCoreWithIndex -------------------
void __edm__RefCoreWithIndex_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_14044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("productPtr"), method_14045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2845), Reflex::Literal("setProductPtr"), method_14046, 0, "prodPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_235), Reflex::Literal("index"), method_14047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNull"), method_14048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isNonnull"), method_14049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("operator!"), operator_14050, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_14051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13359), Reflex::Literal("toRefCore"), method_14052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_14053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13915), Reflex::Literal("setProductGetter"), method_14054, 0, "prodGetter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2904, type_2892), Reflex::Literal("getProductPtr"), method_14055, 0, "type", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892), Reflex::Literal("productNotFoundException"), method_14056, 0, "type", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892, type_2892), Reflex::Literal("wrongTypeException"), method_14057, 0, "expectedType;actualType", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_2892), Reflex::Literal("nullPointerForTransientException"), method_14058, 0, "type", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_13562), Reflex::Literal("swap"), method_14059, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isTransient"), method_14060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_61), Reflex::Literal("isTransientInt"), method_14061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_23335, type_2811), Reflex::Literal("pushBackItem"), method_14062, 0, "productToBeInserted;checkPointer", ::Reflex::PUBLIC);
}
//------Stub functions for class RefHolderBase -------------------------------
static  void operator_21969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolderBase*)o)->operator=)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
  else   (((::edm::reftobase::RefHolderBase*)o)->operator=)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static void destructor_21972(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolderBase*)o)->::edm::reftobase::RefHolderBase::~RefHolderBase)();
}
static  void method_21973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolderBase*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolderBase*)o)->clone)();
}

static  void method_21974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolderBase*)o)->id)());
  else   (((const ::edm::reftobase::RefHolderBase*)o)->id)();
}

static  void method_21975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolderBase*)o)->key)());
  else   (((const ::edm::reftobase::RefHolderBase*)o)->key)();
}

static  void method_21976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolderBase*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolderBase*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_21977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolderBase*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::string*)arg[1]));
  else   (((const ::edm::reftobase::RefHolderBase*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::string*)arg[1]);
}

static  void method_21978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolderBase*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolderBase*)o)->makeVectorHolder)();
}

static  void method_21979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolderBase*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolderBase*)o)->productGetter)();
}

static  void method_21980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolderBase*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolderBase*)o)->hasProductCache)();
}

static  void method_21981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolderBase*)o)->product)());
  else   (((const ::edm::reftobase::RefHolderBase*)o)->product)();
}

static  void method_21982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolderBase*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolderBase*)o)->isAvailable)();
}

//------Dictionary for class RefHolderBase -------------------------------
void __edm__reftobase__RefHolderBase_db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolderBase_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolderBase_datamem_bld(&__edm__reftobase__RefHolderBase_db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolderBase_funcmem_bld(&__edm__reftobase__RefHolderBase_db_funcmem);
void __edm__reftobase__RefHolderBase_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolderBase"), typeid(::edm::reftobase::RefHolderBase), sizeof(::edm::reftobase::RefHolderBase), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13713, type_30747), Reflex::Literal("operator="), operator_21969, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolderBase"), destructor_21972, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolderBase_funcmem_bld);
}

//------Delayed data member builder for class RefHolderBase -------------------
void __edm__reftobase__RefHolderBase_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class RefHolderBase -------------------
void __edm__reftobase__RefHolderBase_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13711), Reflex::Literal("clone"), method_21973, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_21974, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("key"), method_21975, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_30747), Reflex::Literal("isEqualTo"), method_21976, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811, type_13713, type_19051), Reflex::Literal("fillRefIfMyTypeMatches"), method_21977, 0, "ref;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("makeVectorHolder"), method_21978, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_21979, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("hasProductCache"), method_21980, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("product"), method_21981, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_21982, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST);
}
//------Stub functions for class VectorHolder<int,edm::RefVector<std::vector<int, std::allocator<int> >, int, edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > > -------------------------------
static void constructor_23114( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >();
  else ::new(mem) ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >();
}

static void constructor_23115( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >(*(const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >(*(const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)arg[0]);
}

static void constructor_23116( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >(*(const ::edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> >*)arg[0]);
}

static void constructor_23117( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >(*(const ::edm::ProductID*)arg[0]);
}

static void destructor_23118(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::~VectorHolder)();
}
static  void method_23119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->clone)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->clone)();
}

static  void method_23120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->cloneEmpty)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->cloneEmpty)();
}

static  void method_23121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<int>)((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->at)(*(::size_t*)arg[0]));
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_23122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->empty)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->empty)();
}

static  void method_23123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->size)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->size)();
}

static  void method_23124( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->clear)();
}

static  void method_23125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->id)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->id)();
}

static  void method_23126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->productGetter)();
}

static  void method_23127( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->swap)(*(::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)arg[0]);
}

static  void operator_23128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->operator=)(*(const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)arg[0]);
  else   (((::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->operator=)(*(const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)arg[0]);
}

static  void method_23129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<int>::const_iterator)((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->begin)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->begin)();
}

static  void method_23130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<int>::const_iterator)((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->end)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->end)();
}

static  void method_23131( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->push_back)((const ::edm::reftobase::BaseHolder<int>*)arg[0]);
}

static  void method_23132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->vectorHolder)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->vectorHolder)();
}

static  void method_23133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->product)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->product)();
}

static  void method_23134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->isAvailable)();
}

static  void method_23135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >*)o)->Class_Version)();
}

static void method_newdel_13234( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<int>")), ::Reflex::BaseOffset< ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >,::edm::reftobase::BaseVectorHolder<int> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class VectorHolder<int,edm::RefVector<std::vector<int, std::allocator<int> >, int, edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > > -------------------------------
void __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__datamem_bld(&__edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__funcmem_bld(&__edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_funcmem);
void __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >"), typeid(::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >), sizeof(::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::Class_Version())
  .AddBase(type_13239, ::Reflex::BaseOffset< ::edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >, ::edm::reftobase::BaseVectorHolder<int> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_13239, Reflex::Literal("edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::base_type"))
  .AddTypedef(type_1489, Reflex::Literal("edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::size_type"))
  .AddTypedef(type_61, Reflex::Literal("edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::element_type"))
  .AddTypedef(type_3079, Reflex::Literal("edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::base_ref_type"))
  .AddTypedef(type_13302, Reflex::Literal("edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::const_iterator"))
  .AddTypedef(type_2918, Reflex::Literal("edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::ref_vector_type"))
  .AddTypedef(type_23111, Reflex::Literal("edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > >::const_iterator_imp"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("VectorHolder"), constructor_23114, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31165), Reflex::Literal("VectorHolder"), constructor_23115, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22998), Reflex::Literal("VectorHolder"), constructor_23116, 0, "iRefVector", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12510), Reflex::Literal("VectorHolder"), constructor_23117, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~VectorHolder"), destructor_23118, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13234, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__funcmem_bld);
}

//------Delayed data member builder for class VectorHolder<int,edm::RefVector<std::vector<int, std::allocator<int> >, int, edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > > -------------------
void __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2918, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class VectorHolder<int,edm::RefVector<std::vector<int, std::allocator<int> >, int, edm::refhelper::FindUsingAdvance<std::vector<int, std::allocator<int> >, int> > > -------------------
void __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23211), Reflex::Literal("clone"), method_23119, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23211), Reflex::Literal("cloneEmpty"), method_23120, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3079c, type_1489), Reflex::Literal("at"), method_23121, 0, "idx", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_23122, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_23123, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_23124, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_23125, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_23126, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_31167), Reflex::Literal("swap"), method_23127, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31167, type_31165), Reflex::Literal("operator="), operator_23128, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13302), Reflex::Literal("begin"), method_23129, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13302), Reflex::Literal("end"), method_23130, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_31168), Reflex::Literal("push_back"), method_23131, 0, "r", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("vectorHolder"), method_23132, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("product"), method_23133, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_23134, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_23135, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class BaseVectorHolder<int> -------------------------------
static  void operator_23149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::BaseVectorHolder<int>*)o)->operator=)(*(const ::edm::reftobase::BaseVectorHolder<int>*)arg[0]);
  else   (((::edm::reftobase::BaseVectorHolder<int>*)o)->operator=)(*(const ::edm::reftobase::BaseVectorHolder<int>*)arg[0]);
}

static void destructor_23152(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::BaseVectorHolder<int>*)o)->::edm::reftobase::BaseVectorHolder<int>::~BaseVectorHolder)();
}
static  void method_23153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->clone)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->clone)();
}

static  void method_23154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->cloneEmpty)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->cloneEmpty)();
}

static  void method_23155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<int>)((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->at)(*(::size_t*)arg[0]));
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_23156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->empty)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->empty)();
}

static  void method_23157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->size)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->size)();
}

static  void method_23158( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::reftobase::BaseVectorHolder<int>*)o)->clear)();
}

static  void method_23159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->id)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->id)();
}

static  void method_23160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->productGetter)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->productGetter)();
}

static  void method_23161( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::BaseVectorHolder<int>*)o)->swap)(*(::edm::reftobase::BaseVectorHolder<int>*)arg[0]);
}

static  void method_23162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<int>::const_iterator)((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->begin)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->begin)();
}

static  void method_23163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<int>::const_iterator)((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->end)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->end)();
}

static  void method_23164( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::BaseVectorHolder<int>*)o)->push_back)((const ::edm::reftobase::BaseHolder<int>*)arg[0]);
}

static  void method_23165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->vectorHolder)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->vectorHolder)();
}

static  void method_23166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->product)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->product)();
}

static  void method_23167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseVectorHolder<int>*)o)->isAvailable)());
  else   (((const ::edm::reftobase::BaseVectorHolder<int>*)o)->isAvailable)();
}

static  void method_23168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::BaseVectorHolder<int>*)o)->Class_Version)());
  else   (((::edm::reftobase::BaseVectorHolder<int>*)o)->Class_Version)();
}

//------Dictionary for class BaseVectorHolder<int> -------------------------------
void __edm__reftobase__BaseVectorHolder_int__db_datamem(Reflex::Class*);
void __edm__reftobase__BaseVectorHolder_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__BaseVectorHolder_int__datamem_bld(&__edm__reftobase__BaseVectorHolder_int__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__BaseVectorHolder_int__funcmem_bld(&__edm__reftobase__BaseVectorHolder_int__db_funcmem);
void __edm__reftobase__BaseVectorHolder_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<int>"), typeid(::edm::reftobase::BaseVectorHolder<int>), sizeof(::edm::reftobase::BaseVectorHolder<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::BaseVectorHolder<int>::Class_Version())
  .AddTypedef(type_1489, Reflex::Literal("edm::reftobase::BaseVectorHolder<int>::size_type"))
  .AddTypedef(type_61, Reflex::Literal("edm::reftobase::BaseVectorHolder<int>::element_type"))
  .AddTypedef(type_3079, Reflex::Literal("edm::reftobase::BaseVectorHolder<int>::base_ref_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31173, type_31174), Reflex::Literal("operator="), operator_23149, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BaseVectorHolder"), destructor_23152, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__BaseVectorHolder_int__funcmem_bld);
}

//------Delayed data member builder for class BaseVectorHolder<int> -------------------
void __edm__reftobase__BaseVectorHolder_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class BaseVectorHolder<int> -------------------
void __edm__reftobase__BaseVectorHolder_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23211), Reflex::Literal("clone"), method_23153, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23211), Reflex::Literal("cloneEmpty"), method_23154, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3079c, type_1489), Reflex::Literal("at"), method_23155, 0, "idx", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_23156, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_23157, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_23158, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_23159, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_23160, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_31173), Reflex::Literal("swap"), method_23161, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13302), Reflex::Literal("begin"), method_23162, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13302), Reflex::Literal("end"), method_23163, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_31168), Reflex::Literal("push_back"), method_23164, 0, "", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("vectorHolder"), method_23165, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("product"), method_23166, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_23167, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_23168, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class IndirectVectorHolder<int> -------------------------------
static void constructor_23177( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::IndirectVectorHolder<int>();
  else ::new(mem) ::edm::reftobase::IndirectVectorHolder<int>();
}

static void constructor_23178( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::IndirectVectorHolder<int>(*(const ::edm::reftobase::IndirectVectorHolder<int>*)arg[0]);
  else ::new(mem) ::edm::reftobase::IndirectVectorHolder<int>(*(const ::edm::reftobase::IndirectVectorHolder<int>*)arg[0]);
}

static void constructor_23179( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::IndirectVectorHolder<int>(*(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[0]);
  else ::new(mem) ::edm::reftobase::IndirectVectorHolder<int>(*(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[0]);
}

static void constructor_23180( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::IndirectVectorHolder<int>((::edm::reftobase::RefVectorHolderBase*)arg[0]);
  else ::new(mem) ::edm::reftobase::IndirectVectorHolder<int>((::edm::reftobase::RefVectorHolderBase*)arg[0]);
}

static void destructor_23181(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::IndirectVectorHolder<int>*)o)->::edm::reftobase::IndirectVectorHolder<int>::~IndirectVectorHolder)();
}
static  void operator_23182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::IndirectVectorHolder<int>*)o)->operator=)(*(const ::edm::reftobase::IndirectVectorHolder<int>*)arg[0]);
  else   (((::edm::reftobase::IndirectVectorHolder<int>*)o)->operator=)(*(const ::edm::reftobase::IndirectVectorHolder<int>*)arg[0]);
}

static  void method_23183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::IndirectVectorHolder<int>*)o)->swap)(*(::edm::reftobase::IndirectVectorHolder<int>*)arg[0]);
}

static  void method_23184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->clone)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->clone)();
}

static  void method_23185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->cloneEmpty)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->cloneEmpty)();
}

static  void method_23186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->id)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->id)();
}

static  void method_23187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->productGetter)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->productGetter)();
}

static  void method_23188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->empty)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->empty)();
}

static  void method_23189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->size)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->size)();
}

static  void method_23190( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::reftobase::IndirectVectorHolder<int>*)o)->clear)();
}

static  void method_23191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefToBase<int>)((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->at)(*(::size_t*)arg[0]));
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->at)(*(::size_t*)arg[0]);
}

static  void method_23192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->vectorHolder)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->vectorHolder)();
}

static  void method_23193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::IndirectVectorHolder<int>*)o)->push_back)((const ::edm::reftobase::BaseHolder<int>*)arg[0]);
}

static  void method_23194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->product)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->product)();
}

static  void method_23195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->isAvailable)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->isAvailable)();
}

static  void method_23196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::IndirectVectorHolder<int>*)o)->Class_Version)());
  else   (((::edm::reftobase::IndirectVectorHolder<int>*)o)->Class_Version)();
}

static  void method_23197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<int>::const_iterator)((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->begin)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->begin)();
}

static  void method_23198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::reftobase::BaseVectorHolder<int>::const_iterator)((((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->end)());
  else   (((const ::edm::reftobase::IndirectVectorHolder<int>*)o)->end)();
}

static void method_newdel_13240( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::IndirectVectorHolder<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::IndirectVectorHolder<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::IndirectVectorHolder<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::IndirectVectorHolder<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::IndirectVectorHolder<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x69( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseVectorHolder<int>")), ::Reflex::BaseOffset< ::edm::reftobase::IndirectVectorHolder<int>,::edm::reftobase::BaseVectorHolder<int> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class IndirectVectorHolder<int> -------------------------------
void __edm__reftobase__IndirectVectorHolder_int__db_datamem(Reflex::Class*);
void __edm__reftobase__IndirectVectorHolder_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__IndirectVectorHolder_int__datamem_bld(&__edm__reftobase__IndirectVectorHolder_int__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__IndirectVectorHolder_int__funcmem_bld(&__edm__reftobase__IndirectVectorHolder_int__db_funcmem);
void __edm__reftobase__IndirectVectorHolder_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::IndirectVectorHolder<int>"), typeid(::edm::reftobase::IndirectVectorHolder<int>), sizeof(::edm::reftobase::IndirectVectorHolder<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::IndirectVectorHolder<int>::Class_Version())
  .AddBase(type_13239, ::Reflex::BaseOffset< ::edm::reftobase::IndirectVectorHolder<int>, ::edm::reftobase::BaseVectorHolder<int> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_13239, Reflex::Literal("edm::reftobase::IndirectVectorHolder<int>::base_type"))
  .AddTypedef(type_1489, Reflex::Literal("edm::reftobase::IndirectVectorHolder<int>::size_type"))
  .AddTypedef(type_61, Reflex::Literal("edm::reftobase::IndirectVectorHolder<int>::element_type"))
  .AddTypedef(type_3079, Reflex::Literal("edm::reftobase::IndirectVectorHolder<int>::base_ref_type"))
  .AddTypedef(type_13302, Reflex::Literal("edm::reftobase::IndirectVectorHolder<int>::const_iterator"))
  .AddTypedef(type_23111, Reflex::Literal("edm::reftobase::IndirectVectorHolder<int>::const_iterator_imp"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("IndirectVectorHolder"), constructor_23177, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31175), Reflex::Literal("IndirectVectorHolder"), constructor_23178, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3093), Reflex::Literal("IndirectVectorHolder"), constructor_23179, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13938), Reflex::Literal("IndirectVectorHolder"), constructor_23180, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~IndirectVectorHolder"), destructor_23181, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_13240, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x69, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__IndirectVectorHolder_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__IndirectVectorHolder_int__funcmem_bld);
}

//------Delayed data member builder for class IndirectVectorHolder<int> -------------------
void __edm__reftobase__IndirectVectorHolder_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_13938, Reflex::Literal("helper_"), OffsetOf(__shadow__::__edm__reftobase__IndirectVectorHolder_int_, helper_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class IndirectVectorHolder<int> -------------------
void __edm__reftobase__IndirectVectorHolder_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31176, type_31175), Reflex::Literal("operator="), operator_23182, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_31176), Reflex::Literal("swap"), method_23183, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23211), Reflex::Literal("clone"), method_23184, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23211), Reflex::Literal("cloneEmpty"), method_23185, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3052), Reflex::Literal("id"), method_23186, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13915), Reflex::Literal("productGetter"), method_23187, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("empty"), method_23188, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1489), Reflex::Literal("size"), method_23189, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776), Reflex::Literal("clear"), method_23190, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3079c, type_1489), Reflex::Literal("at"), method_23191, 0, "idx", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2021), Reflex::Literal("vectorHolder"), method_23192, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2776, type_31168), Reflex::Literal("push_back"), method_23193, 0, "r", ::Reflex::PUBLIC | ::Reflex::VIRTUAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2845), Reflex::Literal("product"), method_23194, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2811), Reflex::Literal("isAvailable"), method_23195, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968), Reflex::Literal("Class_Version"), method_23196, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13302), Reflex::Literal("begin"), method_23197, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13302), Reflex::Literal("end"), method_23198, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __std__vector_edm__EventAuxiliary__dict(); 
      __edmNew__dstvdetails__DetSetVectorTrans_dict(); 
      __edmNew__dstvdetails__DetSetVectorTrans__Item_dict(); 
      __std__vector_edmNew__dstvdetails__DetSetVectorTrans__Item__dict(); 
      __edm__HLTPathStatus_dict(); 
      __std__vector_edm__HLTPathStatus__dict(); 
      __edm__ConstPtrCache_dict(); 
      __edm__DataFrame_dict(); 
      __edm__PtrVector_int__dict(); 
      __edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__dict(); 
      __edm__ConditionsInEventBlock_dict(); 
      __edm__Wrapper_edm__ConditionsInEventBlock__dict(); 
      __edm__ConditionsInRunBlock_dict(); 
      __edm__Wrapper_edm__ConditionsInRunBlock__dict(); 
      __edm__ConditionsInLumiBlock_dict(); 
      __edm__Wrapper_edm__ConditionsInLumiBlock__dict(); 
      __edm__MergeableCounter_dict(); 
      __edm__Wrapper_edm__MergeableCounter__dict(); 
      __edm__Wrapper_std__vector_edm__ErrorSummaryEntry_s__dict(); 
      __edm__Wrapper_std__vector_edm__EventAuxiliary_s__dict(); 
      __edm__ValueMap_double__dict(); 
      __edm__Wrapper_edm__ValueMap_double_s__dict(); 
      __edm__ValueMap_float__dict(); 
      __edm__Wrapper_edm__ValueMap_float_s__dict(); 
      __edm__ValueMap_bool__dict(); 
      __edm__Wrapper_edm__ValueMap_bool_s__dict(); 
      __edm__ValueMap_unsignedsint__dict(); 
      __edm__Wrapper_edm__ValueMap_unsignedsint_s__dict(); 
      __edm__ValueMap_int__dict(); 
      __edm__Wrapper_edm__ValueMap_int_s__dict(); 
      __edm__Wrapper_edm__PtrVector_int_s__dict(); 
      __edm__RefToBaseVector_int__dict(); 
      __edm__Wrapper_edm__RefToBaseVector_int_s__dict(); 
      __edm__Wrapper_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__dict(); 
      __edm__TriggerResults_dict(); 
      __edm__Wrapper_edm__TriggerResults__dict(); 
      __edm__HLTGlobalStatus_dict(); 
      __edm__Wrapper_edm__HLTGlobalStatus__dict(); 
      __edm__Wrapper_std__vector_edm__HLTPathStatus_s__dict(); 
      __edm__Wrapper_edm__HLTPathStatus__dict(); 
      __edm__DataFrameContainer_dict(); 
      __edm__Wrapper_edm__DataFrameContainer__dict(); 
      __edm__RangeMap_int_std__vector_float__edm__CopyPolicy_float_s__dict(); 
      __edm__BoolCache_dict(); 
      __edm__PtrVectorBase_dict(); 
      __edm__DoNotRecordParents_dict(); 
      __edm__RefCore_dict(); 
      __edm__reftobase__RefVectorHolderBase_dict(); 
      __edm__RefVectorBase_unsignedslong__dict(); 
      __edm__RefVectorBase_unsignedsint__dict(); 
      __edm__RefVectorBase_int__dict(); 
      __edm__Ptr_int__dict(); 
      __edm__DoNotSortUponInsertion_dict(); 
      __edm__Other_dict(); 
      __edm__EDProductGetter_dict(); 
      __edm__Ref_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s__dict(); 
      __edm__RefCoreWithIndex_dict(); 
      __edm__reftobase__RefHolderBase_dict(); 
      __edm__reftobase__VectorHolder_int_edm__RefVector_std__vector_int__int_edm__refhelper__FindUsingAdvance_std__vector_int__int_s_s__dict(); 
      __edm__reftobase__BaseVectorHolder_int__dict(); 
      __edm__reftobase__IndirectVectorHolder_int__dict(); 
    }
    ~Dictionaries() {
      type_2280.Unload(); // class std::vector<edm::EventAuxiliary> 
      type_14844.Unload(); // class edmNew::dstvdetails::DetSetVectorTrans 
      type_5005.Unload(); // class edmNew::dstvdetails::DetSetVectorTrans::Item 
      type_2287.Unload(); // class std::vector<edmNew::dstvdetails::DetSetVectorTrans::Item> 
      type_3027.Unload(); // class edm::HLTPathStatus 
      type_2289.Unload(); // class std::vector<edm::HLTPathStatus> 
      type_2897.Unload(); // class edm::ConstPtrCache 
      type_2902.Unload(); // class edm::DataFrame 
      type_2907.Unload(); // class edm::PtrVector<int> 
      type_2918.Unload(); // class edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > 
      type_2976.Unload(); // class edm::ConditionsInEventBlock 
      type_2923.Unload(); // class edm::Wrapper<edm::ConditionsInEventBlock> 
      type_2994.Unload(); // class edm::ConditionsInRunBlock 
      type_2924.Unload(); // class edm::Wrapper<edm::ConditionsInRunBlock> 
      type_3026.Unload(); // class edm::ConditionsInLumiBlock 
      type_2925.Unload(); // class edm::Wrapper<edm::ConditionsInLumiBlock> 
      type_3062.Unload(); // class edm::MergeableCounter 
      type_2926.Unload(); // class edm::Wrapper<edm::MergeableCounter> 
      type_2927.Unload(); // class edm::Wrapper<std::vector<edm::ErrorSummaryEntry> > 
      type_2928.Unload(); // class edm::Wrapper<std::vector<edm::EventAuxiliary> > 
      type_3124.Unload(); // class edm::ValueMap<double> 
      type_2929.Unload(); // class edm::Wrapper<edm::ValueMap<double> > 
      type_3125.Unload(); // class edm::ValueMap<float> 
      type_2930.Unload(); // class edm::Wrapper<edm::ValueMap<float> > 
      type_3126.Unload(); // class edm::ValueMap<bool> 
      type_2931.Unload(); // class edm::Wrapper<edm::ValueMap<bool> > 
      type_3127.Unload(); // class edm::ValueMap<unsigned int> 
      type_2932.Unload(); // class edm::Wrapper<edm::ValueMap<unsigned int> > 
      type_3128.Unload(); // class edm::ValueMap<int> 
      type_2933.Unload(); // class edm::Wrapper<edm::ValueMap<int> > 
      type_2934.Unload(); // class edm::Wrapper<edm::PtrVector<int> > 
      type_2985.Unload(); // class edm::RefToBaseVector<int> 
      type_2935.Unload(); // class edm::Wrapper<edm::RefToBaseVector<int> > 
      type_2936.Unload(); // class edm::Wrapper<edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > 
      type_3099.Unload(); // class edm::TriggerResults 
      type_2937.Unload(); // class edm::Wrapper<edm::TriggerResults> 
      type_2973.Unload(); // class edm::HLTGlobalStatus 
      type_2938.Unload(); // class edm::Wrapper<edm::HLTGlobalStatus> 
      type_2939.Unload(); // class edm::Wrapper<std::vector<edm::HLTPathStatus> > 
      type_2940.Unload(); // class edm::Wrapper<edm::HLTPathStatus> 
      type_3023.Unload(); // class edm::DataFrameContainer 
      type_2941.Unload(); // class edm::Wrapper<edm::DataFrameContainer> 
      type_2968.Unload(); // class edm::RangeMap<int,std::vector<float>,edm::CopyPolicy<float> > 
      type_2999.Unload(); // class edm::BoolCache 
      type_3024.Unload(); // class edm::PtrVectorBase 
      type_3031.Unload(); // class edm::DoNotRecordParents 
      type_3056.Unload(); // class edm::RefCore 
      type_3058.Unload(); // class edm::reftobase::RefVectorHolderBase 
      type_3069.Unload(); // class edm::RefVectorBase<unsigned long> 
      type_3070.Unload(); // class edm::RefVectorBase<unsigned int> 
      type_3071.Unload(); // class edm::RefVectorBase<int> 
      type_3084.Unload(); // class edm::Ptr<int> 
      type_3085.Unload(); // class edm::DoNotSortUponInsertion 
      type_3086.Unload(); // class edm::Other 
      type_3102.Unload(); // class edm::EDProductGetter 
      type_3104.Unload(); // class edm::Ref<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > 
      type_3116.Unload(); // class edm::RefCoreWithIndex 
      type_6785.Unload(); // class edm::reftobase::RefHolderBase 
      type_13234.Unload(); // class edm::reftobase::VectorHolder<int,edm::RefVector<std::vector<int>,int,edm::refhelper::FindUsingAdvance<std::vector<int>,int> > > 
      type_13239.Unload(); // class edm::reftobase::BaseVectorHolder<int> 
      type_13240.Unload(); // class edm::reftobase::IndirectVectorHolder<int> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
